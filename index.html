<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Metal Building 3D Configurator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;600&family=Source+Sans+Pro:wght@400;600&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Source Sans Pro', sans-serif; background: #1a1a1a; color: #e0e0e0; overflow: hidden; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; touch-action: none; }
        canvas { display: block; cursor: grab; touch-action: none; }
        canvas:active { cursor: grabbing; }
        
        .control-panel {
            position: fixed; top: 20px; left: 20px;
            background: linear-gradient(145deg, rgba(30, 32, 35, 0.95), rgba(20, 22, 25, 0.98));
            border: 1px solid rgba(255, 180, 50, 0.2); border-radius: 8px;
            padding: 24px; width: 340px; max-height: calc(100vh - 40px); overflow-y: auto;
            backdrop-filter: blur(10px); box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        .control-panel::-webkit-scrollbar { width: 6px; }
        .control-panel::-webkit-scrollbar-thumb { background: rgba(255, 180, 50, 0.3); border-radius: 3px; }
        
        .panel-header {
            font-family: 'Oswald', sans-serif; font-size: 22px; font-weight: 600;
            text-transform: uppercase; letter-spacing: 2px; color: #ffb432;
            margin-bottom: 8px; display: flex; align-items: center; gap: 10px;
        }
        .panel-header::before { content: ''; width: 4px; height: 24px; background: linear-gradient(180deg, #ffb432, #ff8c00); border-radius: 2px; }
        .panel-subtitle { font-size: 12px; color: #888; margin-bottom: 24px; padding-left: 14px; }
        
        .section-title {
            font-family: 'Oswald', sans-serif; font-size: 14px; font-weight: 500;
            text-transform: uppercase; letter-spacing: 1.5px; color: #ffb432;
            margin-top: 20px; margin-bottom: 16px; padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 180, 50, 0.2);
        }
        
        .control-group { margin-bottom: 18px; }
        .control-label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .control-label span { font-family: 'Oswald', sans-serif; font-size: 13px; font-weight: 500; text-transform: uppercase; letter-spacing: 1px; color: #aaa; }
        .control-value { font-family: 'Oswald', sans-serif; font-size: 14px; font-weight: 600; color: #ffb432; background: rgba(255, 180, 50, 0.1); padding: 4px 10px; border-radius: 4px; min-width: 70px; text-align: center; }
        
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 6px; background: linear-gradient(90deg, rgba(255, 180, 50, 0.3), rgba(255, 140, 0, 0.3)); border-radius: 3px; outline: none; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: linear-gradient(145deg, #ffb432, #ff8c00); border-radius: 50%; cursor: pointer; }
        
        .color-row { display: flex; align-items: center; margin-bottom: 12px; gap: 12px; }
        .color-row-label { font-family: 'Oswald', sans-serif; font-size: 12px; font-weight: 500; text-transform: uppercase; letter-spacing: 1px; color: #888; min-width: 50px; }
        .color-options { display: flex; gap: 6px; flex-wrap: wrap; }
        .color-swatch { width: 28px; height: 28px; border-radius: 4px; cursor: pointer; border: 2px solid transparent; transition: all 0.2s; position: relative; }
        .color-swatch:hover { transform: scale(1.15); z-index: 1; }
        .color-swatch.active { border-color: #ffb432; box-shadow: 0 0 12px rgba(255, 180, 50, 0.5); }
        .color-swatch.active::after { content: '✓'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 12px; font-weight: bold; text-shadow: 0 1px 3px rgba(0,0,0,0.7); }
        .color-swatch.camo { background: linear-gradient(135deg, #41372d 0%, #554b3c 25%, #6e5f4b 50%, #374132 75%, #2d2823 100%); }
        .color-swatch.wood { background: linear-gradient(180deg, #8b5a41 0%, #6b4423 30%, #8b5a41 50%, #5a3a20 70%, #7a4a31 100%); }
        
        .stats-panel { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(20, 22, 25, 0.9); border: 1px solid rgba(255, 180, 50, 0.15); border-radius: 8px; padding: 16px 20px; backdrop-filter: blur(10px); display: flex; gap: 30px; }
        .stat-item { text-align: center; }
        .stats-title { font-family: 'Oswald', sans-serif; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #666; margin-bottom: 4px; }
        .stats-value { font-family: 'Oswald', sans-serif; font-size: 22px; font-weight: 600; color: #ffb432; }
        .stats-unit { font-size: 11px; color: #888; margin-left: 2px; }
        
        .instructions { position: fixed; bottom: 20px; right: 20px; background: rgba(20, 22, 25, 0.9); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 16px 20px; font-size: 12px; color: #888; line-height: 1.6; }
        .instructions strong { color: #aaa; }
        .logo { position: fixed; top: 20px; right: 20px; font-family: 'Oswald', sans-serif; font-size: 14px; font-weight: 600; text-transform: uppercase; letter-spacing: 3px; color: rgba(255, 255, 255, 0.3); }
        
        .snapshot-btn {
            position: fixed; top: 80px; right: 20px;
            background: linear-gradient(145deg, #ffb432, #ff8c00);
            border: none; border-radius: 8px; padding: 12px 20px;
            font-family: 'Oswald', sans-serif; font-size: 13px; font-weight: 600;
            text-transform: uppercase; letter-spacing: 1px; color: #1a1a1a;
            cursor: pointer; display: flex; align-items: center; gap: 8px;
            box-shadow: 0 4px 15px rgba(255, 180, 50, 0.3);
            transition: all 0.2s;
        }
        .snapshot-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255, 180, 50, 0.4); }
        .snapshot-btn:active { transform: translateY(0); }
        .snapshot-btn svg { width: 18px; height: 18px; fill: #1a1a1a; }
        .snapshot-btn.loading { opacity: 0.7; pointer-events: none; }
        
        .snapshot-progress {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(20, 22, 25, 0.95); border: 1px solid rgba(255, 180, 50, 0.3);
            border-radius: 12px; padding: 30px 40px; text-align: center;
            backdrop-filter: blur(10px); z-index: 1000; display: none;
        }
        .snapshot-progress.visible { display: block; }
        .snapshot-progress h3 { font-family: 'Oswald', sans-serif; font-size: 18px; color: #ffb432; margin-bottom: 15px; }
        .snapshot-progress p { font-size: 14px; color: #888; margin-bottom: 20px; }
        .snapshot-progress .progress-bar { width: 200px; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; margin: 0 auto; }
        .snapshot-progress .progress-fill { height: 100%; background: linear-gradient(90deg, #ffb432, #ff8c00); width: 0%; transition: width 0.3s; }
        
        .snapshot-preview-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85); z-index: 1001; display: none;
            justify-content: center; align-items: center; padding: 20px;
        }
        .snapshot-preview-overlay.visible { display: flex; }
        
        .snapshot-preview-modal {
            background: linear-gradient(145deg, rgba(30, 32, 35, 0.98), rgba(20, 22, 25, 0.98));
            border: 1px solid rgba(255, 180, 50, 0.2); border-radius: 12px;
            padding: 24px; max-width: 900px; width: 100%; max-height: 90vh; overflow-y: auto;
        }
        .snapshot-preview-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid rgba(255, 180, 50, 0.2);
        }
        .snapshot-preview-header h3 {
            font-family: 'Oswald', sans-serif; font-size: 20px; color: #ffb432;
            display: flex; align-items: center; gap: 10px;
        }
        .snapshot-preview-header h3::before {
            content: ''; width: 4px; height: 24px;
            background: linear-gradient(180deg, #ffb432, #ff8c00); border-radius: 2px;
        }
        .snapshot-preview-close {
            background: none; border: none; color: #888; font-size: 28px;
            cursor: pointer; padding: 5px 10px; transition: color 0.2s;
        }
        .snapshot-preview-close:hover { color: #fff; }
        
        .snapshot-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 20px;
        }
        @media (max-width: 768px) {
            .snapshot-grid { grid-template-columns: repeat(2, 1fr); }
        }
        .snapshot-item {
            background: rgba(0,0,0,0.3); border-radius: 8px; overflow: hidden;
            border: 2px solid transparent; transition: all 0.2s; cursor: pointer;
        }
        .snapshot-item:hover { border-color: rgba(255, 180, 50, 0.5); }
        .snapshot-item.selected { border-color: #ffb432; }
        .snapshot-item img { width: 100%; aspect-ratio: 16/9; object-fit: cover; display: block; }
        .snapshot-item-label {
            padding: 8px 12px; font-family: 'Oswald', sans-serif; font-size: 12px;
            text-transform: uppercase; letter-spacing: 1px; color: #aaa;
            display: flex; justify-content: space-between; align-items: center;
        }
        .snapshot-item-check { color: #ffb432; font-weight: bold; }
        
        .snapshot-preview-actions {
            display: flex; gap: 12px; justify-content: flex-end; flex-wrap: wrap;
        }
        .snapshot-action-btn {
            padding: 12px 24px; border-radius: 6px; font-family: 'Oswald', sans-serif;
            font-size: 14px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
            cursor: pointer; display: flex; align-items: center; gap: 8px; transition: all 0.2s;
        }
        .snapshot-action-btn.primary {
            background: linear-gradient(145deg, #ffb432, #ff8c00); border: none; color: #1a1a1a;
        }
        .snapshot-action-btn.primary:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(255, 180, 50, 0.4); }
        .snapshot-action-btn.secondary {
            background: transparent; border: 1px solid rgba(255,255,255,0.2); color: #aaa;
        }
        .snapshot-action-btn.secondary:hover { border-color: rgba(255,255,255,0.4); color: #fff; }
        .snapshot-action-btn svg { width: 16px; height: 16px; }
        .snapshot-action-btn.primary svg { fill: #1a1a1a; }
        .snapshot-action-btn.secondary svg { fill: currentColor; }
        
        .wall-toggles { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .wall-toggle { display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: rgba(255, 255, 255, 0.05); border-radius: 6px; cursor: pointer; transition: background 0.2s; }
        .wall-toggle:hover { background: rgba(255, 255, 255, 0.1); }
        .wall-toggle input { display: none; }
        .wall-toggle .checkbox { width: 18px; height: 18px; border: 2px solid #555; border-radius: 4px; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
        .wall-toggle input:checked + .checkbox { background: #ffb432; border-color: #ffb432; }
        .wall-toggle input:checked + .checkbox::after { content: '✓'; color: #1a1a1a; font-size: 12px; font-weight: bold; }
        .wall-toggle span { font-family: 'Oswald', sans-serif; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; color: #999; }
        
        /* Accessories Panel Styles */
        .wall-selector { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 16px; }
        #leanto-wall-selector { grid-template-columns: repeat(3, 1fr); }
        .wall-btn {
            padding: 10px 8px; background: rgba(255, 255, 255, 0.05); border: 2px solid transparent;
            border-radius: 6px; cursor: pointer; text-align: center; transition: all 0.2s;
            font-family: 'Oswald', sans-serif; font-size: 11px; text-transform: uppercase;
            letter-spacing: 0.5px; color: #999;
        }
        #leanto-wall-selector .wall-btn { font-size: 9px; padding: 8px 4px; }
        .wall-btn:hover { background: rgba(255, 255, 255, 0.1); }
        .wall-btn.active { border-color: #ffb432; background: rgba(255, 180, 50, 0.15); color: #ffb432; }
        
        .accessory-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 16px; }
        .accessory-btn {
            aspect-ratio: 1; background: rgba(255, 255, 255, 0.05); border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px; cursor: pointer; display: flex; flex-direction: column;
            align-items: center; justify-content: center; gap: 4px; transition: all 0.2s;
            padding: 6px;
        }
        .accessory-btn:hover { background: rgba(255, 255, 255, 0.1); border-color: rgba(255,255,255,0.2); }
        .accessory-btn.active { border-color: #ffb432; background: rgba(255, 180, 50, 0.15); }
        .accessory-btn svg { width: 26px; height: 26px; stroke: #999; fill: none; stroke-width: 1.5; }
        .accessory-btn.active svg { stroke: #ffb432; }
        .accessory-btn span { font-family: 'Oswald', sans-serif; font-size: 8px; text-transform: uppercase; color: #888; text-align: center; line-height: 1.1; }
        .accessory-btn.active span { color: #ffb432; }
        
        .size-selector { margin-bottom: 16px; }
        .size-selector label { font-family: 'Oswald', sans-serif; font-size: 11px; text-transform: uppercase; color: #888; display: block; margin-bottom: 6px; }
        .size-selector select {
            width: 100%; padding: 10px 12px; background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0;
            font-family: 'Source Sans Pro', sans-serif; font-size: 13px; cursor: pointer;
        }
        .size-selector select:focus { outline: none; border-color: #ffb432; }
        .custom-size-inputs { display: none; margin-top: 10px; }
        .custom-size-inputs.visible { display: flex; gap: 10px; }
        .custom-size-inputs .size-input-group { flex: 1; }
        .custom-size-inputs label { font-size: 10px; margin-bottom: 4px; }
        .custom-size-inputs input {
            width: 100%; padding: 8px 10px; background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0;
            font-family: 'Source Sans Pro', sans-serif; font-size: 13px;
        }
        .custom-size-inputs input:focus { outline: none; border-color: #ffb432; }
        
        .add-btn {
            width: 100%; padding: 12px; background: linear-gradient(145deg, #ffb432, #ff8c00);
            border: none; border-radius: 6px; cursor: pointer; font-family: 'Oswald', sans-serif;
            font-size: 14px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
            color: #1a1a1a; transition: all 0.2s; margin-bottom: 12px;
        }
        .add-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(255, 180, 50, 0.4); }
        .add-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
        
        .accessories-list { max-height: 250px; overflow-y: auto; }
        .accessory-item {
            padding: 10px; background: rgba(255,255,255,0.03); border-radius: 6px;
            margin-bottom: 8px; font-size: 12px; border: 1px solid rgba(255,255,255,0.05);
        }
        .accessory-item.selected { border-color: #ffb432; background: rgba(255,180,50,0.1); }
        .accessory-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .accessory-header span { color: #aaa; font-weight: 500; }
        .accessory-item .remove-btn {
            background: rgba(255,100,100,0.2); border: none; color: #ff6666;
            width: 20px; height: 20px; border-radius: 4px; cursor: pointer;
            font-size: 14px; line-height: 1;
        }
        .accessory-item .remove-btn:hover { background: rgba(255,100,100,0.4); }
        .accessory-item .duplicate-btn {
            background: rgba(100,200,100,0.2); border: none; color: #66cc66;
            width: 20px; height: 20px; border-radius: 4px; cursor: pointer;
            font-size: 12px; line-height: 1; margin-right: 4px;
        }
        .accessory-item .duplicate-btn:hover { background: rgba(100,200,100,0.4); }
        .accessory-buttons { display: flex; }
        .accessory-warning {
            background: rgba(255, 180, 50, 0.15);
            border: 1px solid rgba(255, 180, 50, 0.4);
            border-radius: 4px;
            padding: 6px 8px;
            margin-top: 8px;
            font-size: 11px;
            color: #ffb432;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .accessory-warning::before {
            content: '⚠';
            font-size: 14px;
        }
        
        /* Lean-to styles */
        .leanto-section { margin-bottom: 16px; }
        .leanto-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 10px 12px; background: rgba(255, 255, 255, 0.05);
            border-radius: 6px; cursor: pointer; margin-bottom: 8px;
        }
        .leanto-header:hover { background: rgba(255, 255, 255, 0.08); }
        .leanto-header span { font-family: 'Oswald', sans-serif; font-size: 12px; text-transform: uppercase; color: #999; }
        .leanto-header.active span { color: #ffb432; }
        .leanto-toggle { width: 40px; height: 20px; background: rgba(255,255,255,0.1); border-radius: 10px; position: relative; transition: all 0.2s; }
        .leanto-toggle::after { content: ''; position: absolute; width: 16px; height: 16px; background: #666; border-radius: 50%; top: 2px; left: 2px; transition: all 0.2s; }
        .leanto-header.active .leanto-toggle { background: rgba(255, 180, 50, 0.3); }
        .leanto-header.active .leanto-toggle::after { background: #ffb432; left: 22px; }
        .leanto-controls { display: none; padding: 0 4px; }
        .leanto-controls.visible { display: block; }
        .leanto-control { margin-bottom: 12px; }
        .leanto-control-label { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .leanto-control-label span { font-size: 11px; color: #888; }
        .leanto-control-label .value { color: #ffb432; font-weight: 600; }
        .leanto-control input[type="range"] { width: 100%; height: 4px; }
        .leanto-walls { display: flex; gap: 8px; margin-top: 8px; }
        .leanto-wall-toggle { flex: 1; padding: 6px; background: rgba(255,255,255,0.05); border-radius: 4px; text-align: center; cursor: pointer; font-size: 10px; color: #888; text-transform: uppercase; border: 1px solid transparent; }
        .leanto-wall-toggle.active { border-color: #ffb432; color: #ffb432; background: rgba(255,180,50,0.1); }
        .position-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .position-control { }
        .position-control label { display: block; font-size: 10px; color: #666; text-transform: uppercase; margin-bottom: 4px; }
        .position-control input[type="range"] { width: 100%; height: 4px; }
        .position-value { font-size: 11px; color: #ffb432; float: right; }
        .position-input { 
            width: 50px; 
            background: rgba(255,255,255,0.1); 
            border: 1px solid rgba(255,180,50,0.3); 
            border-radius: 3px; 
            color: #ffb432; 
            font-size: 11px; 
            padding: 2px 4px; 
            text-align: right;
            -moz-appearance: textfield;
        }
        .position-input::-webkit-outer-spin-button,
        .position-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .position-input:focus { outline: none; border-color: #ffb432; background: rgba(255,180,50,0.15); }
        
        /* Wrap Corners */
        .wrap-corners-section { margin-bottom: 16px; }
        .wrap-corners-info { font-size: 10px; color: #666; margin-bottom: 10px; line-height: 1.4; }
        .wrap-corners-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .wrap-corner-btn {
            padding: 10px 8px; background: rgba(255, 255, 255, 0.05); border: 2px solid transparent;
            border-radius: 6px; cursor: pointer; text-align: center; transition: all 0.2s;
            font-family: 'Oswald', sans-serif; font-size: 10px; text-transform: uppercase;
            letter-spacing: 0.5px; color: #888;
        }
        .wrap-corner-btn:hover { background: rgba(255, 255, 255, 0.1); }
        .wrap-corner-btn.active { border-color: #ffb432; background: rgba(255, 180, 50, 0.15); color: #ffb432; }
        .wrap-corner-btn.disabled { opacity: 0.4; cursor: not-allowed; }
        .wrap-corner-btn .corner-status { font-size: 8px; display: block; margin-top: 2px; color: #666; }
        .wrap-corner-btn.active .corner-status { color: #ffb432; }
        
        /* Mobile Menu Button */
        .mobile-menu-btn {
            display: none;
            position: fixed;
            top: 15px;
            left: 15px;
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, rgba(30, 32, 35, 0.95), rgba(20, 22, 25, 0.98));
            border: 1px solid rgba(255, 180, 50, 0.3);
            border-radius: 10px;
            cursor: pointer;
            z-index: 1001;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        .mobile-menu-btn span {
            display: block;
            width: 24px;
            height: 3px;
            background: #ffb432;
            border-radius: 2px;
            transition: all 0.3s;
        }
        .mobile-menu-btn.active span:nth-child(1) { transform: rotate(45deg) translate(5px, 5px); }
        .mobile-menu-btn.active span:nth-child(2) { opacity: 0; }
        .mobile-menu-btn.active span:nth-child(3) { transform: rotate(-45deg) translate(6px, -6px); }
        
        /* Mobile overlay */
        .panel-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 999;
        }
        .panel-overlay.visible { display: block; }
        
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            .mobile-menu-btn { display: flex; }
            
            .control-panel {
                position: fixed;
                top: 0;
                left: -100%;
                width: 85%;
                max-width: 340px;
                height: 100vh;
                max-height: 100vh;
                border-radius: 0;
                border-left: none;
                border-top: none;
                border-bottom: none;
                padding: 70px 20px 100px 20px;
                z-index: 1000;
                transition: left 0.3s ease;
            }
            .control-panel.open { left: 0; }
            
            .panel-header { font-size: 18px; }
            .section-title { font-size: 12px; margin-top: 16px; margin-bottom: 12px; }
            
            .control-group { margin-bottom: 14px; }
            .control-label span { font-size: 11px; }
            .control-value { font-size: 12px; padding: 3px 8px; min-width: 60px; }
            
            input[type="range"] { height: 8px; }
            input[type="range"]::-webkit-slider-thumb { width: 24px; height: 24px; }
            
            .color-swatch { width: 32px; height: 32px; }
            
            .wall-toggles { gap: 6px; }
            .wall-toggle { padding: 10px 8px; }
            .wall-toggle .checkbox { width: 20px; height: 20px; }
            
            .wall-selector { grid-template-columns: repeat(2, 1fr); gap: 6px; }
            .wall-btn { padding: 12px 8px; font-size: 10px; }
            
            .accessory-grid { grid-template-columns: repeat(4, 1fr); gap: 8px; }
            .accessory-btn { padding: 6px; }
            .accessory-btn svg { width: 28px; height: 28px; }
            .accessory-btn span { font-size: 8px; }
            
            .size-selector select { padding: 12px; font-size: 14px; }
            .add-btn { padding: 14px; font-size: 13px; }
            
            .accessories-list { max-height: 180px; }
            .accessory-item { padding: 12px; }
            .accessory-item .remove-btn, .accessory-item .duplicate-btn { width: 28px; height: 28px; font-size: 16px; }
            
            .leanto-header { padding: 12px; }
            .leanto-header span { font-size: 11px; }
            .leanto-control input[type="range"] { height: 6px; }
            .leanto-wall-toggle { padding: 8px; font-size: 9px; }
            
            .stats-panel {
                bottom: 15px;
                padding: 12px 16px;
                gap: 20px;
                border-radius: 25px;
            }
            .stats-value { font-size: 18px; }
            .stats-title { font-size: 9px; }
            
            .instructions { display: none; }
            .logo { display: none; }
        }
        
        @media (max-width: 480px) {
            .control-panel { width: 100%; max-width: 100%; padding: 70px 15px 100px 15px; }
            
            .wall-selector { grid-template-columns: repeat(4, 1fr); }
            .wall-btn { padding: 10px 4px; font-size: 9px; letter-spacing: 0; }
            
            .accessory-grid { gap: 6px; }
            .accessory-btn svg { width: 24px; height: 24px; }
            
            .color-options { gap: 4px; }
            .color-swatch { width: 28px; height: 28px; }
            
            .stats-panel { gap: 15px; padding: 10px 14px; }
            .stats-value { font-size: 16px; }
            
            .leanto-walls { flex-wrap: wrap; }
            .leanto-wall-toggle { flex: 0 0 calc(50% - 4px); }
        }
        
        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .control-panel { padding-top: 15px; padding-bottom: 15px; }
            .mobile-menu-btn { top: 10px; left: 10px; width: 40px; height: 40px; }
            .mobile-menu-btn span { width: 20px; height: 2px; }
            .stats-panel { bottom: 10px; padding: 8px 12px; }
            .stats-value { font-size: 14px; }
        }
        
        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 4px;
            margin-bottom: 20px;
            background: rgba(0,0,0,0.2);
            padding: 4px;
            border-radius: 8px;
        }
        .tab-btn {
            flex: 1;
            padding: 10px 8px;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Oswald', sans-serif;
            font-size: 11px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            transition: all 0.2s;
        }
        .tab-btn:hover {
            color: #aaa;
            background: rgba(255,255,255,0.05);
        }
        .tab-btn.active {
            background: linear-gradient(145deg, rgba(255, 180, 50, 0.2), rgba(255, 140, 0, 0.15));
            color: #ffb432;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        @media (max-width: 768px) {
            .tab-btn { padding: 12px 6px; font-size: 10px; }
        }
        
        /* Accessory Overlay Panel */
        .accessory-overlay {
            position: fixed;
            background: rgba(20, 22, 25, 0.95);
            border: 1px solid rgba(255, 180, 50, 0.4);
            border-radius: 8px;
            padding: 10px 12px;
            min-width: 180px;
            z-index: 100;
            pointer-events: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            display: none;
        }
        .accessory-overlay.visible {
            display: block;
        }
        .accessory-overlay-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .accessory-overlay-title {
            font-family: 'Oswald', sans-serif;
            font-size: 12px;
            font-weight: 500;
            text-transform: uppercase;
            color: #ffb432;
        }
        .accessory-overlay-buttons {
            display: flex;
            gap: 6px;
        }
        .accessory-overlay-buttons button {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .overlay-duplicate-btn {
            background: rgba(100, 200, 100, 0.2);
            color: #66cc66;
        }
        .overlay-duplicate-btn:hover {
            background: rgba(100, 200, 100, 0.4);
        }
        .overlay-delete-btn {
            background: rgba(255, 100, 100, 0.2);
            color: #ff6666;
        }
        .overlay-delete-btn:hover {
            background: rgba(255, 100, 100, 0.4);
        }
        .accessory-overlay-info {
            font-size: 11px;
            color: #aaa;
        }
        .accessory-overlay-info div {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
        }
        .accessory-overlay-info .label {
            color: #888;
        }
        .accessory-overlay-info .value {
            color: #ffb432;
            font-weight: 600;
        }
        .accessory-overlay-info .warning {
            color: #ff9944;
        }
        
        /* View Control Toolbar */
        .view-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            padding: 8px 12px;
            border-radius: 25px;
            border: 1px solid rgba(255, 180, 50, 0.3);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            z-index: 100;
        }
        .view-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 20px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .view-btn:hover {
            background: rgba(255, 180, 50, 0.3);
            color: #ffb432;
        }
        .view-btn:active {
            transform: scale(0.95);
            background: rgba(255, 180, 50, 0.5);
        }
        .view-separator {
            width: 1px;
            height: 24px;
            background: rgba(255,255,255,0.2);
            margin: 0 5px;
        }
        @media (max-width: 768px) {
            .view-controls {
                bottom: 70px;
                padding: 6px 10px;
            }
            .view-btn {
                width: 36px;
                height: 36px;
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- View Control Toolbar -->
    <div class="view-controls" id="view-controls">
        <button class="view-btn" id="btn-rotate-left" title="Rotate Left">↺</button>
        <button class="view-btn" id="btn-rotate-right" title="Rotate Right">↻</button>
        <div class="view-separator"></div>
        <button class="view-btn" id="btn-zoom-in" title="Zoom In">+</button>
        <button class="view-btn" id="btn-zoom-out" title="Zoom Out">−</button>
        <div class="view-separator"></div>
        <button class="view-btn" id="btn-reset-view" title="Reset View">⌂</button>
    </div>
    
    <div class="panel-overlay" id="panel-overlay"></div>
    
    <button class="mobile-menu-btn" id="mobile-menu-btn">
        <span></span>
        <span></span>
        <span></span>
    </button>
    
    <div class="control-panel" id="control-panel">
        <div class="panel-header">Metal Building</div>
        <div class="panel-subtitle">3D Configuration Tool</div>
        
        <!-- Tab Navigation -->
        <div class="tab-nav">
            <button class="tab-btn active" data-tab="building">Building</button>
            <button class="tab-btn" data-tab="leantos">Lean-Tos</button>
            <button class="tab-btn" data-tab="accessories">Accessories</button>
            <button class="tab-btn" data-tab="options">Options</button>
        </div>
        
        <!-- Building Tab -->
        <div class="tab-content active" id="tab-building">
            <div class="section-title">Dimensions</div>
            <div class="control-group">
                <div class="control-label"><span>Width</span><div class="control-value"><span id="width-value">60</span> ft</div></div>
                <input type="range" id="width" min="20" max="300" value="60" step="5">
            </div>
            <div class="control-group">
                <div class="control-label"><span>Length</span><div class="control-value"><span id="length-value">100</span> ft</div></div>
                <input type="range" id="length" min="40" max="500" value="100" step="5">
            </div>
            <div class="control-group">
                <div class="control-label"><span>Eave Height</span><div class="control-value"><span id="height-value">16</span> ft</div></div>
                <input type="range" id="height" min="10" max="40" value="16">
            </div>
            <div class="control-group">
                <div class="control-label"><span>Roof Pitch</span><div class="control-value"><span id="pitch-value">3</span>:12</div></div>
                <input type="range" id="pitch" min="1" max="6" value="3" step="0.5">
            </div>
            <div class="control-group">
                <div class="control-label"><span>Side Bay Spacing</span><div class="control-value"><span id="bay-value">25</span> ft</div></div>
                <select id="bay" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0; font-size: 13px;">
                    <option value="20">20 ft</option>
                    <option value="25" selected>25 ft</option>
                    <option value="30">30 ft</option>
                    <option value="35">35 ft</option>
                    <option value="40">40 ft</option>
                </select>
            </div>
            <div class="control-group">
                <label class="wall-toggle" style="margin-bottom: 8px;">
                    <input type="checkbox" id="toggle-front-back-bays" checked>
                    <div class="checkbox"></div>
                    <span>Front/Back Bay Framing</span>
                </label>
                <div id="front-back-bay-controls" style="display: block;">
                    <div class="control-label"><span>Front/Back Bay Spacing</span><div class="control-value"><span id="front-back-bay-value">25</span> ft</div></div>
                    <select id="front-back-bay-spacing" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0; font-size: 13px;">
                        <option value="20">20 ft</option>
                        <option value="25" selected>25 ft</option>
                        <option value="30">30 ft</option>
                        <option value="35">35 ft</option>
                        <option value="40">40 ft</option>
                    </select>
                </div>
            </div>
            <div class="control-group">
                <div class="control-label"><span>Eave Overhang (Sides)</span><div class="control-value"><span id="eave-overhang-value">0</span></div></div>
                <select id="eave-overhang" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0; font-size: 13px;">
                    <option value="0" selected>None (0")</option>
                    <option value="0.5">6"</option>
                    <option value="1">1 ft</option>
                    <option value="1.5">1 ft 6"</option>
                    <option value="2">2 ft</option>
                    <option value="3">3 ft</option>
                    <option value="4">4 ft</option>
                    <option value="5">5 ft</option>
                    <option value="6">6 ft</option>
                </select>
            </div>
            <div class="control-group">
                <div class="control-label"><span>Gable Overhang (Ends)</span><div class="control-value"><span id="gable-overhang-value">0</span></div></div>
                <select id="gable-overhang" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0; font-size: 13px;">
                    <option value="0" selected>None (0")</option>
                    <option value="0.5">6"</option>
                    <option value="1">1 ft</option>
                    <option value="1.5">1 ft 6"</option>
                    <option value="2">2 ft</option>
                    <option value="3">3 ft</option>
                    <option value="4">4 ft</option>
                    <option value="5">5 ft</option>
                    <option value="6">6 ft</option>
                </select>
            </div>
        </div>
        
        <!-- Lean-Tos Tab -->
        <div class="tab-content" id="tab-leantos">
            <div class="section-title">Lean-To Extensions</div>
            
            <div class="leanto-section">
                <div class="leanto-header" data-leanto="left">
                    <span>Left Lean-To</span>
                    <div class="leanto-toggle"></div>
                </div>
                <div class="leanto-controls" id="leanto-left-controls">
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Width</span><span class="value" id="leanto-left-width-val">20 ft</span></div>
                        <input type="range" id="leanto-left-width" min="10" max="40" value="20" step="2">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Length</span><span class="value" id="leanto-left-length-val">60 ft</span></div>
                        <input type="range" id="leanto-left-length" min="20" max="500" value="60" step="5">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Position</span><span class="value" id="leanto-left-offset-val">0 ft</span></div>
                        <input type="range" id="leanto-left-offset" min="-100" max="100" value="0" step="5">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Eave Height</span><span class="value" id="leanto-left-height-val">12 ft</span></div>
                        <input type="range" id="leanto-left-height" min="8" max="20" value="12" step="1">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Roof Pitch</span><span class="value" id="leanto-left-pitch-val">1:12</span></div>
                        <input type="range" id="leanto-left-pitch" min="0.5" max="4" value="1" step="0.5">
                    </div>
                    <div class="leanto-walls">
                        <div class="leanto-wall-toggle active" data-leanto="left" data-wall="endwalls">Endwalls</div>
                        <div class="leanto-wall-toggle active" data-leanto="left" data-wall="sidewall">Sidewall</div>
                        <div class="leanto-wall-toggle active" data-leanto="left" data-wall="overhang">Overhang</div>
                    </div>
                </div>
            </div>
            
            <div class="leanto-section">
                <div class="leanto-header" data-leanto="right">
                    <span>Right Lean-To</span>
                    <div class="leanto-toggle"></div>
                </div>
                <div class="leanto-controls" id="leanto-right-controls">
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Width</span><span class="value" id="leanto-right-width-val">20 ft</span></div>
                        <input type="range" id="leanto-right-width" min="10" max="40" value="20" step="2">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Length</span><span class="value" id="leanto-right-length-val">60 ft</span></div>
                        <input type="range" id="leanto-right-length" min="20" max="500" value="60" step="5">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Position</span><span class="value" id="leanto-right-offset-val">0 ft</span></div>
                        <input type="range" id="leanto-right-offset" min="-100" max="100" value="0" step="5">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Eave Height</span><span class="value" id="leanto-right-height-val">12 ft</span></div>
                        <input type="range" id="leanto-right-height" min="8" max="20" value="12" step="1">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Roof Pitch</span><span class="value" id="leanto-right-pitch-val">1:12</span></div>
                        <input type="range" id="leanto-right-pitch" min="0.5" max="4" value="1" step="0.5">
                    </div>
                    <div class="leanto-walls">
                        <div class="leanto-wall-toggle active" data-leanto="right" data-wall="endwalls">Endwalls</div>
                        <div class="leanto-wall-toggle active" data-leanto="right" data-wall="sidewall">Sidewall</div>
                        <div class="leanto-wall-toggle active" data-leanto="right" data-wall="overhang">Overhang</div>
                    </div>
                </div>
            </div>
            
            <div class="leanto-section">
                <div class="leanto-header" data-leanto="front">
                    <span>Front Lean-To</span>
                    <div class="leanto-toggle"></div>
                </div>
                <div class="leanto-controls" id="leanto-front-controls">
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Depth</span><span class="value" id="leanto-front-depth-val">15 ft</span></div>
                        <input type="range" id="leanto-front-depth" min="8" max="30" value="15" step="2">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Width</span><span class="value" id="leanto-front-width-val">40 ft</span></div>
                        <input type="range" id="leanto-front-width" min="20" max="300" value="40" step="5">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Position</span><span class="value" id="leanto-front-offset-val">0 ft</span></div>
                        <input type="range" id="leanto-front-offset" min="-100" max="100" value="0" step="5">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Eave Height</span><span class="value" id="leanto-front-height-val">12 ft</span></div>
                        <input type="range" id="leanto-front-height" min="8" max="20" value="12" step="1">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Roof Pitch</span><span class="value" id="leanto-front-pitch-val">1:12</span></div>
                        <input type="range" id="leanto-front-pitch" min="0.5" max="4" value="1" step="0.5">
                    </div>
                    <div class="leanto-walls">
                        <div class="leanto-wall-toggle active" data-leanto="front" data-wall="endwalls">Endwalls</div>
                        <div class="leanto-wall-toggle active" data-leanto="front" data-wall="sidewall">Front Wall</div>
                        <div class="leanto-wall-toggle active" data-leanto="front" data-wall="overhang">Overhang</div>
                    </div>
                </div>
            </div>
            
            <div class="leanto-section">
                <div class="leanto-header" data-leanto="back">
                    <span>Back Lean-To</span>
                    <div class="leanto-toggle"></div>
                </div>
                <div class="leanto-controls" id="leanto-back-controls">
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Depth</span><span class="value" id="leanto-back-depth-val">15 ft</span></div>
                        <input type="range" id="leanto-back-depth" min="8" max="30" value="15" step="2">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Width</span><span class="value" id="leanto-back-width-val">40 ft</span></div>
                        <input type="range" id="leanto-back-width" min="20" max="300" value="40" step="5">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Position</span><span class="value" id="leanto-back-offset-val">0 ft</span></div>
                        <input type="range" id="leanto-back-offset" min="-100" max="100" value="0" step="5">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Eave Height</span><span class="value" id="leanto-back-height-val">12 ft</span></div>
                        <input type="range" id="leanto-back-height" min="8" max="20" value="12" step="1">
                    </div>
                    <div class="leanto-control">
                        <div class="leanto-control-label"><span>Roof Pitch</span><span class="value" id="leanto-back-pitch-val">1:12</span></div>
                        <input type="range" id="leanto-back-pitch" min="0.5" max="4" value="1" step="0.5">
                    </div>
                    <div class="leanto-walls">
                        <div class="leanto-wall-toggle active" data-leanto="back" data-wall="endwalls">Endwalls</div>
                        <div class="leanto-wall-toggle active" data-leanto="back" data-wall="sidewall">Back Wall</div>
                        <div class="leanto-wall-toggle active" data-leanto="back" data-wall="overhang">Overhang</div>
                    </div>
                </div>
            </div>
            
            <div class="wrap-corners-section" id="wrap-corners-section" style="display:none;">
                <div class="section-title">Wrap-Around Corners</div>
                <div class="wrap-corners-info">When adjacent lean-tos match pitch & height, enable wrap to connect them.</div>
                <div class="wrap-corners-grid" id="wrap-corners-grid"></div>
            </div>
        </div>
        
        <!-- Accessories Tab -->
        <div class="tab-content" id="tab-accessories">
            <div class="section-title">Add Accessories</div>
            
            <div class="wall-selector" id="wall-selector">
                <div class="wall-btn active" data-wall="front">Front</div>
                <div class="wall-btn" data-wall="back">Back</div>
                <div class="wall-btn" data-wall="left">Left</div>
                <div class="wall-btn" data-wall="right">Right</div>
            </div>
            <div class="wall-selector" id="leanto-wall-selector" style="display:none; margin-top: 8px;">
            </div>
            
            <div class="accessory-grid">
                <div class="accessory-btn" data-type="door">
                    <svg viewBox="0 0 40 40">
                        <rect x="8" y="4" width="24" height="32" rx="1"/>
                        <circle cx="26" cy="22" r="2"/>
                    </svg>
                    <span>Walk Door</span>
                </div>
                <div class="accessory-btn" data-type="glassdoor">
                    <svg viewBox="0 0 40 40">
                        <rect x="4" y="4" width="14" height="32" rx="1" fill="none" stroke="currentColor" stroke-width="2"/>
                        <rect x="22" y="4" width="14" height="32" rx="1" fill="none" stroke="currentColor" stroke-width="2"/>
                        <line x1="11" y1="20" x2="11" y2="24" stroke-width="2"/>
                        <line x1="29" y1="20" x2="29" y2="24" stroke-width="2"/>
                    </svg>
                    <span>Glass Door</span>
                </div>
                <div class="accessory-btn" data-type="window">
                    <svg viewBox="0 0 40 40">
                        <rect x="6" y="8" width="28" height="24" rx="1"/>
                        <line x1="20" y1="8" x2="20" y2="32"/>
                        <line x1="6" y1="20" x2="34" y2="20"/>
                    </svg>
                    <span>Window</span>
                </div>
                <div class="accessory-btn" data-type="rollup">
                    <svg viewBox="0 0 40 40">
                        <rect x="4" y="6" width="32" height="28" rx="1"/>
                        <line x1="4" y1="12" x2="36" y2="12"/>
                        <line x1="4" y1="18" x2="36" y2="18"/>
                        <line x1="4" y1="24" x2="36" y2="24"/>
                    </svg>
                    <span>Rollup</span>
                </div>
                <div class="accessory-btn" data-type="overhead">
                    <svg viewBox="0 0 40 40">
                        <rect x="2" y="6" width="36" height="28" rx="1"/>
                        <line x1="2" y1="11" x2="38" y2="11"/>
                        <line x1="2" y1="16" x2="38" y2="16"/>
                        <line x1="2" y1="21" x2="38" y2="21"/>
                        <line x1="2" y1="26" x2="38" y2="26"/>
                        <rect x="16" y="2" width="8" height="6" rx="1"/>
                    </svg>
                    <span>Overhead</span>
                </div>
                <div class="accessory-btn" data-type="overheadglass">
                    <svg viewBox="0 0 40 40">
                        <rect x="2" y="6" width="36" height="28" rx="1" fill="none" stroke="currentColor" stroke-width="2"/>
                        <rect x="4" y="8" width="7" height="6" rx="0.5" fill="none" stroke="currentColor"/>
                        <rect x="13" y="8" width="7" height="6" rx="0.5" fill="none" stroke="currentColor"/>
                        <rect x="22" y="8" width="7" height="6" rx="0.5" fill="none" stroke="currentColor"/>
                        <rect x="31" y="8" width="7" height="6" rx="0.5" fill="none" stroke="currentColor"/>
                        <rect x="4" y="16" width="7" height="6" rx="0.5" fill="none" stroke="currentColor"/>
                        <rect x="13" y="16" width="7" height="6" rx="0.5" fill="none" stroke="currentColor"/>
                        <rect x="22" y="16" width="7" height="6" rx="0.5" fill="none" stroke="currentColor"/>
                        <rect x="31" y="16" width="7" height="6" rx="0.5" fill="none" stroke="currentColor"/>
                        <rect x="4" y="24" width="7" height="6" rx="0.5" fill="none" stroke="currentColor"/>
                        <rect x="13" y="24" width="7" height="6" rx="0.5" fill="none" stroke="currentColor"/>
                        <rect x="22" y="24" width="7" height="6" rx="0.5" fill="none" stroke="currentColor"/>
                        <rect x="31" y="24" width="7" height="6" rx="0.5" fill="none" stroke="currentColor"/>
                    </svg>
                    <span>Glass OH</span>
                </div>
                <div class="accessory-btn" data-type="barndoor">
                    <svg viewBox="0 0 40 40">
                        <rect x="4" y="4" width="14" height="32" rx="1"/>
                        <rect x="22" y="4" width="14" height="32" rx="1"/>
                        <line x1="4" y1="20" x2="18" y2="4"/>
                        <line x1="4" y1="20" x2="18" y2="36"/>
                        <line x1="22" y1="20" x2="36" y2="4"/>
                        <line x1="22" y1="20" x2="36" y2="36"/>
                    </svg>
                    <span>Barn Door</span>
                </div>
                <div class="accessory-btn" data-type="hangar">
                    <svg viewBox="0 0 40 40">
                        <rect x="1" y="10" width="38" height="24" rx="1"/>
                        <line x1="10" y1="10" x2="10" y2="34"/>
                        <line x1="20" y1="10" x2="20" y2="34"/>
                        <line x1="30" y1="10" x2="30" y2="34"/>
                        <path d="M1 10 Q20 2 39 10" fill="none" stroke="currentColor" stroke-width="2"/>
                    </svg>
                    <span>Hangar</span>
                </div>
                <div class="accessory-btn" data-type="frameout">
                    <svg viewBox="0 0 40 40">
                        <rect x="6" y="6" width="28" height="28" rx="1"/>
                    </svg>
                    <span>Frameout</span>
                </div>
            </div>
            
            <div class="size-selector" id="size-selector" style="display:none;">
                <label>Select Size</label>
                <select id="accessory-size"></select>
                <div class="custom-size-inputs" id="custom-size-inputs">
                    <div class="size-input-group">
                        <label>Width (ft)</label>
                        <input type="number" id="custom-width" min="1" max="50" step="0.5" value="4">
                    </div>
                    <div class="size-input-group">
                        <label>Height (ft)</label>
                        <input type="number" id="custom-height" min="1" max="20" step="0.5" value="4">
                    </div>
                </div>
            </div>
            
            <button class="add-btn" id="add-accessory-btn" disabled>Add to Wall</button>
            
            <div class="section-title" style="display: flex; justify-content: space-between; align-items: center;">
                <span>Placed Accessories</span>
                <button id="center-all-btn" style="background: #555; color: #fff; border: none; padding: 4px 10px; border-radius: 4px; font-size: 11px; cursor: pointer; display: none;">⟷ SPACE EVENLY</button>
            </div>
            <div class="accessories-list" id="accessories-list"></div>
        </div>
        
        <!-- Options Tab (Colors & Visibility) -->
        <div class="tab-content" id="tab-options">
            <div class="section-title">Wall Visibility</div>
            <div class="wall-toggles">
                <label class="wall-toggle"><input type="checkbox" id="toggle-front" checked><div class="checkbox"></div><span>Front Wall</span></label>
                <label class="wall-toggle"><input type="checkbox" id="toggle-back" checked><div class="checkbox"></div><span>Back Wall</span></label>
                <label class="wall-toggle"><input type="checkbox" id="toggle-left" checked><div class="checkbox"></div><span>Left Wall</span></label>
                <label class="wall-toggle"><input type="checkbox" id="toggle-right" checked><div class="checkbox"></div><span>Right Wall</span></label>
                <label class="wall-toggle"><input type="checkbox" id="toggle-roof" checked><div class="checkbox"></div><span>Roof</span></label>
                <label class="wall-toggle"><input type="checkbox" id="toggle-framing" checked><div class="checkbox"></div><span>Framing</span></label>
            </div>
            
            <div class="section-title">Endwall Inset (Utility Style)</div>
            <div class="control-group">
                <div class="control-label"><span>Front Endwall Inset</span><div class="control-value"><span id="front-inset-value">0</span> bays</div></div>
                <select id="front-inset" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0; font-size: 13px;">
                    <option value="0" selected>Full (no inset)</option>
                    <option value="1">1 bay in</option>
                    <option value="2">2 bays in</option>
                    <option value="3">3 bays in</option>
                    <option value="4">4 bays in</option>
                </select>
                <div id="front-inset-walls" style="display: none; margin-top: 8px;">
                    <div style="font-size: 11px; color: #888; margin-bottom: 6px;">Open bay walls:</div>
                    <div class="wall-toggles">
                        <label class="wall-toggle"><input type="checkbox" id="front-inset-left" checked><div class="checkbox"></div><span>Left Wall</span></label>
                        <label class="wall-toggle"><input type="checkbox" id="front-inset-right" checked><div class="checkbox"></div><span>Right Wall</span></label>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <div class="control-label"><span>Back Endwall Inset</span><div class="control-value"><span id="back-inset-value">0</span> bays</div></div>
                <select id="back-inset" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0; font-size: 13px;">
                    <option value="0" selected>Full (no inset)</option>
                    <option value="1">1 bay in</option>
                    <option value="2">2 bays in</option>
                    <option value="3">3 bays in</option>
                    <option value="4">4 bays in</option>
                </select>
                <div id="back-inset-walls" style="display: none; margin-top: 8px;">
                    <div style="font-size: 11px; color: #888; margin-bottom: 6px;">Open bay walls:</div>
                    <div class="wall-toggles">
                        <label class="wall-toggle"><input type="checkbox" id="back-inset-left" checked><div class="checkbox"></div><span>Left Wall</span></label>
                        <label class="wall-toggle"><input type="checkbox" id="back-inset-right" checked><div class="checkbox"></div><span>Right Wall</span></label>
                    </div>
                </div>
            </div>
            
            <div class="section-title">Colors</div>
            <div class="color-row">
                <span class="color-row-label">Walls</span>
                <div class="color-options" id="wall-colors">
                    <div class="color-swatch" data-color="#36454F" style="background:#36454F;" title="Charcoal"></div>
                    <div class="color-swatch" data-color="#6A7B8B" style="background:#6A7B8B;" title="Slate Blue"></div>
                    <div class="color-swatch" data-color="#6D6552" style="background:#6D6552;" title="Burnished Slate"></div>
                    <div class="color-swatch" data-color="#228B22" style="background:#228B22;" title="Forest Green"></div>
                    <div class="color-swatch active" data-color="#F0F0F0" style="background:#F0F0F0;" title="Polar White"></div>
                    <div class="color-swatch" data-color="#D3D3D3" style="background:#D3D3D3;" title="Light Grey"></div>
                    <div class="color-swatch" data-color="#EDC9AF" style="background:#EDC9AF;" title="Desert Sand"></div>
                    <div class="color-swatch" data-color="#DC143C" style="background:#DC143C;" title="Crimson Red"></div>
                    <div class="color-swatch" data-color="#00C5CD" style="background:#00C5CD;" title="Hawaiian Blue"></div>
                    <div class="color-swatch" data-color="#B0C4DE" style="background:#B0C4DE;" title="Gallery Blue"></div>
                    <div class="color-swatch" data-color="#5C755E" style="background:#5C755E;" title="Colony Green"></div>
                    <div class="color-swatch" data-color="#AD6F69" style="background:#AD6F69;" title="Copper Penny"></div>
                    <div class="color-swatch" data-color="#8B2500" style="background:#8B2500;" title="Rustic Red"></div>
                    <div class="color-swatch" data-color="#D2B48C" style="background:#D2B48C;" title="Tan"></div>
                    <div class="color-swatch" data-color="#5C4033" style="background:#5C4033;" title="Brown"></div>
                    <div class="color-swatch" data-color="#1C1C1C" style="background:#1C1C1C;" title="Black"></div>
                    <div class="color-swatch" data-color="#800020" style="background:#800020;" title="Burgundy"></div>
                    <div class="color-swatch" data-color="#8A7D72" style="background:#8A7D72;" title="Clay"></div>
                    <div class="color-swatch" data-color="#B2BEB5" style="background:#B2BEB5;" title="Ash Grey"></div>
                    <div class="color-swatch" data-color="#4B6F44" style="background:#4B6F44;" title="Ivy Green"></div>
                    <div class="color-swatch" data-color="#A8A9AD" style="background:#A8A9AD;" title="Galvalume"></div>
                    <div class="color-swatch" data-color="#7C0A02" style="background:#7C0A02;" title="Barn Red"></div>
                    <div class="color-swatch" data-color="#C4B6A6" style="background:#C4B6A6;" title="Stone Beige"></div>
                    <div class="color-swatch" data-color="#ADD8E6" style="background:#ADD8E6;" title="Light Blue"></div>
                    <div class="color-swatch" data-color="#1E4D7B" style="background:#1E4D7B;" title="Ocean Blue"></div>
                    <div class="color-swatch camo" data-color="camo" title="Camo"></div>
                    <div class="color-swatch wood" data-color="wood" title="Wood Grain"></div>
                </div>
            </div>
            <div class="color-row">
                <span class="color-row-label">Roof</span>
                <div class="color-options" id="roof-colors">
                    <div class="color-swatch active" data-color="#36454F" style="background:#36454F;" title="Charcoal"></div>
                    <div class="color-swatch" data-color="#6A7B8B" style="background:#6A7B8B;" title="Slate Blue"></div>
                    <div class="color-swatch" data-color="#6D6552" style="background:#6D6552;" title="Burnished Slate"></div>
                    <div class="color-swatch" data-color="#228B22" style="background:#228B22;" title="Forest Green"></div>
                    <div class="color-swatch" data-color="#F0F0F0" style="background:#F0F0F0;" title="Polar White"></div>
                    <div class="color-swatch" data-color="#D3D3D3" style="background:#D3D3D3;" title="Light Grey"></div>
                    <div class="color-swatch" data-color="#EDC9AF" style="background:#EDC9AF;" title="Desert Sand"></div>
                    <div class="color-swatch" data-color="#DC143C" style="background:#DC143C;" title="Crimson Red"></div>
                    <div class="color-swatch" data-color="#00C5CD" style="background:#00C5CD;" title="Hawaiian Blue"></div>
                    <div class="color-swatch" data-color="#B0C4DE" style="background:#B0C4DE;" title="Gallery Blue"></div>
                    <div class="color-swatch" data-color="#5C755E" style="background:#5C755E;" title="Colony Green"></div>
                    <div class="color-swatch" data-color="#AD6F69" style="background:#AD6F69;" title="Copper Penny"></div>
                    <div class="color-swatch" data-color="#8B2500" style="background:#8B2500;" title="Rustic Red"></div>
                    <div class="color-swatch" data-color="#D2B48C" style="background:#D2B48C;" title="Tan"></div>
                    <div class="color-swatch" data-color="#5C4033" style="background:#5C4033;" title="Brown"></div>
                    <div class="color-swatch" data-color="#1C1C1C" style="background:#1C1C1C;" title="Black"></div>
                    <div class="color-swatch" data-color="#800020" style="background:#800020;" title="Burgundy"></div>
                    <div class="color-swatch" data-color="#8A7D72" style="background:#8A7D72;" title="Clay"></div>
                    <div class="color-swatch" data-color="#B2BEB5" style="background:#B2BEB5;" title="Ash Grey"></div>
                    <div class="color-swatch" data-color="#4B6F44" style="background:#4B6F44;" title="Ivy Green"></div>
                    <div class="color-swatch" data-color="#A8A9AD" style="background:#A8A9AD;" title="Galvalume"></div>
                    <div class="color-swatch" data-color="#7C0A02" style="background:#7C0A02;" title="Barn Red"></div>
                    <div class="color-swatch" data-color="#C4B6A6" style="background:#C4B6A6;" title="Stone Beige"></div>
                    <div class="color-swatch" data-color="#ADD8E6" style="background:#ADD8E6;" title="Light Blue"></div>
                    <div class="color-swatch" data-color="#1E4D7B" style="background:#1E4D7B;" title="Ocean Blue"></div>
                    <div class="color-swatch camo" data-color="camo" title="Camo"></div>
                    <div class="color-swatch wood" data-color="wood" title="Wood Grain"></div>
                </div>
            </div>
            <div class="color-row">
                <span class="color-row-label">Trim</span>
                <div class="color-options" id="trim-colors">
                    <div class="color-swatch" data-color="#36454F" style="background:#36454F;" title="Charcoal"></div>
                    <div class="color-swatch" data-color="#6A7B8B" style="background:#6A7B8B;" title="Slate Blue"></div>
                    <div class="color-swatch" data-color="#6D6552" style="background:#6D6552;" title="Burnished Slate"></div>
                    <div class="color-swatch" data-color="#228B22" style="background:#228B22;" title="Forest Green"></div>
                    <div class="color-swatch active" data-color="#F0F0F0" style="background:#F0F0F0;" title="Polar White"></div>
                    <div class="color-swatch" data-color="#D3D3D3" style="background:#D3D3D3;" title="Light Grey"></div>
                    <div class="color-swatch" data-color="#EDC9AF" style="background:#EDC9AF;" title="Desert Sand"></div>
                    <div class="color-swatch" data-color="#DC143C" style="background:#DC143C;" title="Crimson Red"></div>
                    <div class="color-swatch" data-color="#00C5CD" style="background:#00C5CD;" title="Hawaiian Blue"></div>
                    <div class="color-swatch" data-color="#B0C4DE" style="background:#B0C4DE;" title="Gallery Blue"></div>
                    <div class="color-swatch" data-color="#5C755E" style="background:#5C755E;" title="Colony Green"></div>
                    <div class="color-swatch" data-color="#AD6F69" style="background:#AD6F69;" title="Copper Penny"></div>
                    <div class="color-swatch" data-color="#8B2500" style="background:#8B2500;" title="Rustic Red"></div>
                    <div class="color-swatch" data-color="#D2B48C" style="background:#D2B48C;" title="Tan"></div>
                    <div class="color-swatch" data-color="#5C4033" style="background:#5C4033;" title="Brown"></div>
                    <div class="color-swatch" data-color="#1C1C1C" style="background:#1C1C1C;" title="Black"></div>
                    <div class="color-swatch" data-color="#800020" style="background:#800020;" title="Burgundy"></div>
                    <div class="color-swatch" data-color="#8A7D72" style="background:#8A7D72;" title="Clay"></div>
                    <div class="color-swatch" data-color="#B2BEB5" style="background:#B2BEB5;" title="Ash Grey"></div>
                    <div class="color-swatch" data-color="#4B6F44" style="background:#4B6F44;" title="Ivy Green"></div>
                    <div class="color-swatch" data-color="#A8A9AD" style="background:#A8A9AD;" title="Galvalume"></div>
                    <div class="color-swatch" data-color="#7C0A02" style="background:#7C0A02;" title="Barn Red"></div>
                    <div class="color-swatch" data-color="#C4B6A6" style="background:#C4B6A6;" title="Stone Beige"></div>
                    <div class="color-swatch" data-color="#ADD8E6" style="background:#ADD8E6;" title="Light Blue"></div>
                    <div class="color-swatch" data-color="#1E4D7B" style="background:#1E4D7B;" title="Ocean Blue"></div>
                </div>
            </div>
            <div class="color-row" style="flex-direction: column; align-items: flex-start;">
                <label class="wall-toggle" style="margin-bottom: 8px;">
                    <input type="checkbox" id="toggle-wainscot">
                    <div class="checkbox"></div>
                    <span>Wainscot (3ft)</span>
                </label>
                <div id="wainscot-controls" style="display: none; width: 100%;">
                    <div class="color-options" id="wainscot-colors">
                        <div class="color-swatch active" data-color="#36454F" style="background:#36454F;" title="Charcoal"></div>
                        <div class="color-swatch" data-color="#6A7B8B" style="background:#6A7B8B;" title="Slate Blue"></div>
                        <div class="color-swatch" data-color="#6D6552" style="background:#6D6552;" title="Burnished Slate"></div>
                        <div class="color-swatch" data-color="#228B22" style="background:#228B22;" title="Forest Green"></div>
                        <div class="color-swatch" data-color="#F0F0F0" style="background:#F0F0F0;" title="Polar White"></div>
                        <div class="color-swatch" data-color="#D3D3D3" style="background:#D3D3D3;" title="Light Grey"></div>
                        <div class="color-swatch" data-color="#EDC9AF" style="background:#EDC9AF;" title="Desert Sand"></div>
                        <div class="color-swatch" data-color="#DC143C" style="background:#DC143C;" title="Crimson Red"></div>
                        <div class="color-swatch" data-color="#00C5CD" style="background:#00C5CD;" title="Hawaiian Blue"></div>
                        <div class="color-swatch" data-color="#B0C4DE" style="background:#B0C4DE;" title="Gallery Blue"></div>
                        <div class="color-swatch" data-color="#5C755E" style="background:#5C755E;" title="Colony Green"></div>
                        <div class="color-swatch" data-color="#AD6F69" style="background:#AD6F69;" title="Copper Penny"></div>
                        <div class="color-swatch" data-color="#8B2500" style="background:#8B2500;" title="Rustic Red"></div>
                        <div class="color-swatch" data-color="#D2B48C" style="background:#D2B48C;" title="Tan"></div>
                        <div class="color-swatch" data-color="#5C4033" style="background:#5C4033;" title="Brown"></div>
                        <div class="color-swatch" data-color="#1C1C1C" style="background:#1C1C1C;" title="Black"></div>
                        <div class="color-swatch" data-color="#800020" style="background:#800020;" title="Burgundy"></div>
                        <div class="color-swatch" data-color="#8A7D72" style="background:#8A7D72;" title="Clay"></div>
                        <div class="color-swatch" data-color="#B2BEB5" style="background:#B2BEB5;" title="Ash Grey"></div>
                        <div class="color-swatch" data-color="#4B6F44" style="background:#4B6F44;" title="Ivy Green"></div>
                        <div class="color-swatch" data-color="#A8A9AD" style="background:#A8A9AD;" title="Galvalume"></div>
                        <div class="color-swatch" data-color="#7C0A02" style="background:#7C0A02;" title="Barn Red"></div>
                        <div class="color-swatch" data-color="#C4B6A6" style="background:#C4B6A6;" title="Stone Beige"></div>
                        <div class="color-swatch" data-color="#ADD8E6" style="background:#ADD8E6;" title="Light Blue"></div>
                        <div class="color-swatch" data-color="#1E4D7B" style="background:#1E4D7B;" title="Ocean Blue"></div>
                        <div class="color-swatch camo" data-color="camo" title="Camo"></div>
                        <div class="color-swatch wood" data-color="wood" title="Wood Grain"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="stats-panel">
        <div class="stat-item"><div class="stats-title">Square Footage</div><div class="stats-value"><span id="sqft-value">6,000</span><span class="stats-unit">sq ft</span></div></div>
        <div class="stat-item"><div class="stats-title">Frame Bays</div><div class="stats-value"><span id="bays-value">4</span><span class="stats-unit">bays</span></div></div>
    </div>
    
    <div class="instructions"><strong>Controls:</strong> Drag to rotate • Scroll/pinch to zoom • Right-drag/two-finger to pan<br><strong>Accessories:</strong> Tap to select • Drag to move</div>
    
    <button class="snapshot-btn" id="snapshot-btn" title="Capture 6 angles">
        <svg viewBox="0 0 24 24"><path d="M12 15.2a3.2 3.2 0 1 0 0-6.4 3.2 3.2 0 0 0 0 6.4z"/><path d="M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/></svg>
        Snapshots
    </button>
    
    <div class="snapshot-progress" id="snapshot-progress">
        <h3>Capturing Building Views</h3>
        <p id="snapshot-status">Preparing...</p>
        <div class="progress-bar"><div class="progress-fill" id="snapshot-progress-fill"></div></div>
    </div>
    
    <div class="snapshot-preview-overlay" id="snapshot-preview-overlay">
        <div class="snapshot-preview-modal">
            <div class="snapshot-preview-header">
                <h3>Building Snapshots</h3>
                <button class="snapshot-preview-close" id="snapshot-preview-close">&times;</button>
            </div>
            <div class="snapshot-grid" id="snapshot-grid"></div>
            <div class="snapshot-preview-actions">
                <button class="snapshot-action-btn secondary" id="snapshot-select-all">
                    <svg viewBox="0 0 24 24"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14zM17.99 9l-1.41-1.42-6.59 6.59-2.58-2.57-1.42 1.41 4 3.99z"/></svg>
                    Select All
                </button>
                <button class="snapshot-action-btn secondary" id="snapshot-download-individual">
                    <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                    Download Selected
                </button>
                <button class="snapshot-action-btn primary" id="snapshot-download-zip">
                    <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                    Download ZIP
                </button>
            </div>
        </div>
    </div>
    <div class="logo">Steel Structure Pro</div>
    
    <!-- Accessory Overlay Panel -->
    <div class="accessory-overlay" id="accessory-overlay">
        <div class="accessory-overlay-header">
            <span class="accessory-overlay-title" id="overlay-title">Door</span>
            <div class="accessory-overlay-buttons">
                <button class="overlay-duplicate-btn" id="overlay-duplicate" title="Duplicate">⧉</button>
                <button class="overlay-delete-btn" id="overlay-delete" title="Delete">×</button>
            </div>
        </div>
        <div class="accessory-overlay-info" id="overlay-info">
            <div><span class="label">Position:</span><span class="value" id="overlay-position">0.0 ft</span></div>
            <div><span class="label">Left Edge:</span><span class="value" id="overlay-left-dist">--</span></div>
            <div><span class="label">Right Edge:</span><span class="value" id="overlay-right-dist">--</span></div>
            <div><span class="label">Nearest Item:</span><span class="value" id="overlay-nearest">--</span></div>
        </div>
    </div>

    <script>
        let scene, camera, renderer;
        let groups = {};
        let accessoryMeshes = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedAccessoryId = null;
        let isDraggingAccessory = false;
        let soffitMat = null; // Will be created in createBuilding
        
        const colors = { wall: 0xF0F0F0, roof: 0x36454F, trim: 0xF0F0F0, wainscot: 0x36454F };
        const params = { width: 60, length: 100, height: 16, pitch: 3, baySpacing: 25, frontBackBaySpacing: 25, showFrontBackBays: true, showWainscot: false, showFront: true, showBack: true, showLeft: true, showRight: true, showRoof: true, showFraming: true, eaveOverhang: 0, gableOverhang: 0, frontInset: 0, backInset: 0, frontInsetLeftWall: true, frontInsetRightWall: true, backInsetLeftWall: true, backInsetRightWall: true };
        
        // Lean-to parameters
        const leanTos = {
            left: { enabled: false, width: 20, length: 60, offset: 0, height: 12, pitch: 1, showEndwalls: true, showSidewall: true, showOverhang: true },
            right: { enabled: false, width: 20, length: 60, offset: 0, height: 12, pitch: 1, showEndwalls: true, showSidewall: true, showOverhang: true },
            front: { enabled: false, depth: 15, width: 40, offset: 0, height: 12, pitch: 1, showEndwalls: true, showSidewall: true, showOverhang: true },
            back: { enabled: false, depth: 15, width: 40, offset: 0, height: 12, pitch: 1, showEndwalls: true, showSidewall: true, showOverhang: true }
        };
        
        // Wrap-around corners (when adjacent lean-tos match)
        const wrapCorners = {
            leftFront: false,
            leftBack: false,
            rightFront: false,
            rightBack: false,
            // Wall visibility for each corner
            leftFrontSidewall: true,
            leftFrontFrontwall: true,
            leftBackSidewall: true,
            leftBackBackwall: true,
            rightFrontSidewall: true,
            rightFrontFrontwall: true,
            rightBackSidewall: true,
            rightBackBackwall: true
        };
        
        // Accessories data
        let selectedWall = 'front';
        let selectedAccessory = null;
        let accessories = [];
        let accessoryIdCounter = 0;
        
        const accessorySizes = {
            door: [
                { label: "3' x 7' Walk Door", width: 3, height: 7 },
                { label: "3' x 6'8\" Walk Door", width: 3, height: 6.67 },
                { label: "4' x 7' Walk Door", width: 4, height: 7 }
            ],
            glassdoor: [
                { label: "3' x 7' Glass Door", width: 3, height: 7 },
                { label: "6' x 7' Double Glass Door", width: 6, height: 7 },
                { label: "6' x 8' Double Glass Door", width: 6, height: 8 }
            ],
            window: [
                { label: "3' x 3' Window", width: 3, height: 3 },
                { label: "4' x 3' Window", width: 4, height: 3 },
                { label: "3' x 4' Window", width: 3, height: 4 },
                { label: "4' x 4' Window", width: 4, height: 4 },
                { label: "6' x 4' Window", width: 6, height: 4 }
            ],
            frameout: [
                { label: "4' x 4' Frameout", width: 4, height: 4 },
                { label: "6' x 6' Frameout", width: 6, height: 6 },
                { label: "8' x 8' Frameout", width: 8, height: 8 },
                { label: "10' x 10' Frameout", width: 10, height: 10 },
                { label: "Custom Size", width: 0, height: 0, custom: true }
            ],
            rollup: [
                { label: "8' x 8' Rollup Door", width: 8, height: 8 },
                { label: "10' x 10' Rollup Door", width: 10, height: 10 },
                { label: "12' x 12' Rollup Door", width: 12, height: 12 },
                { label: "14' x 14' Rollup Door", width: 14, height: 14 },
                { label: "10' x 12' Rollup Door", width: 10, height: 12 },
                { label: "12' x 14' Rollup Door", width: 12, height: 14 }
            ],
            overhead: [
                { label: "8' x 7' Overhead Door", width: 8, height: 7 },
                { label: "9' x 7' Overhead Door", width: 9, height: 7 },
                { label: "10' x 8' Overhead Door", width: 10, height: 8 },
                { label: "16' x 7' Overhead Door", width: 16, height: 7 },
                { label: "16' x 8' Overhead Door", width: 16, height: 8 },
                { label: "18' x 8' Overhead Door", width: 18, height: 8 }
            ],
            overheadglass: [
                { label: "8' x 7' Glass Overhead", width: 8, height: 7 },
                { label: "9' x 7' Glass Overhead", width: 9, height: 7 },
                { label: "10' x 8' Glass Overhead", width: 10, height: 8 },
                { label: "16' x 7' Glass Overhead", width: 16, height: 7 },
                { label: "16' x 8' Glass Overhead", width: 16, height: 8 }
            ],
            barndoor: [
                { label: "8' x 8' Barn Door", width: 8, height: 8 },
                { label: "10' x 10' Barn Door", width: 10, height: 10 },
                { label: "12' x 10' Barn Door", width: 12, height: 10 },
                { label: "12' x 12' Barn Door", width: 12, height: 12 },
                { label: "14' x 12' Barn Door", width: 14, height: 12 }
            ],
            hangar: [
                { label: "30' x 12' Hangar Door", width: 30, height: 12 },
                { label: "40' x 14' Hangar Door", width: 40, height: 14 },
                { label: "50' x 14' Hangar Door", width: 50, height: 14 },
                { label: "60' x 16' Hangar Door", width: 60, height: 16 }
            ]
        };
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xe8e8e8);
            
            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const sun = new THREE.DirectionalLight(0xffffff, 0.6);
            sun.position.set(100, 150, 100);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.left = -200;
            sun.shadow.camera.right = 200;
            sun.shadow.camera.top = 200;
            sun.shadow.camera.bottom = -200;
            scene.add(sun);
            
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(800, 800),
                new THREE.MeshStandardMaterial({ color: 0xd0d0d0, roughness: 0.9 })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            createBuilding();
            setupControls();
            setupEventListeners();
            setupAccessoryControls();
            updateLeantoWallSelector();
            updateWrapCornersUI();
            animate();
        }
        
        // Special texture types
        const specialTextures = {
            camo: true,
            wood: true
        };
        
        function createPanelTexture(color) {
            // Handle special textures
            if (color === 'camo') {
                return createCamoTexture();
            } else if (color === 'wood') {
                return createWoodTexture();
            }
            
            // PBR Panel specs: 36" panel, 12" rib spacing, 1.25" rib height
            // Ribs run vertically on walls
            const canvas = document.createElement('canvas');
            canvas.width = 360; // 36 inches at 10px per inch
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            const c = new THREE.Color(color);
            const baseR = Math.floor(c.r * 255);
            const baseG = Math.floor(c.g * 255);
            const baseB = Math.floor(c.b * 255);
            
            // Fill base color
            ctx.fillStyle = `rgb(${baseR},${baseG},${baseB})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ribs at 12" intervals (every 120px)
            const ribPositions = [0, 120, 240];
            const ribWidth = 14;
            
            for (let ribCenter of ribPositions) {
                const ribStart = ribCenter - Math.floor(ribWidth / 2);
                
                // Deep shadow
                ctx.fillStyle = `rgb(${Math.floor(baseR * 0.3)},${Math.floor(baseG * 0.3)},${Math.floor(baseB * 0.35)})`;
                ctx.fillRect(ribStart, 0, 2, canvas.height);
                
                // Left slope
                ctx.fillStyle = `rgb(${Math.floor(baseR * 0.5)},${Math.floor(baseG * 0.5)},${Math.floor(baseB * 0.55)})`;
                ctx.fillRect(ribStart + 2, 0, 1, canvas.height);
                
                ctx.fillStyle = `rgb(${Math.floor(baseR * 0.7)},${Math.floor(baseG * 0.7)},${Math.floor(baseB * 0.7)})`;
                ctx.fillRect(ribStart + 3, 0, 1, canvas.height);
                
                // Highlight
                ctx.fillStyle = `rgb(${Math.min(255, Math.floor(baseR * 1.2))},${Math.min(255, Math.floor(baseG * 1.2))},${Math.min(255, Math.floor(baseB * 1.2))})`;
                ctx.fillRect(ribStart + 4, 0, 1, canvas.height);
                
                // Bright top
                ctx.fillStyle = `rgb(${Math.min(255, Math.floor(baseR * 1.25))},${Math.min(255, Math.floor(baseG * 1.25))},${Math.min(255, Math.floor(baseB * 1.25))})`;
                ctx.fillRect(ribStart + 5, 0, 4, canvas.height);
                
                // Right highlight
                ctx.fillStyle = `rgb(${Math.min(255, Math.floor(baseR * 1.15))},${Math.min(255, Math.floor(baseG * 1.15))},${Math.min(255, Math.floor(baseB * 1.15))})`;
                ctx.fillRect(ribStart + 9, 0, 1, canvas.height);
                
                // Right slope
                ctx.fillStyle = `rgb(${Math.floor(baseR * 0.6)},${Math.floor(baseG * 0.6)},${Math.floor(baseB * 0.6)})`;
                ctx.fillRect(ribStart + 10, 0, 1, canvas.height);
                
                ctx.fillStyle = `rgb(${Math.floor(baseR * 0.45)},${Math.floor(baseG * 0.45)},${Math.floor(baseB * 0.5)})`;
                ctx.fillRect(ribStart + 11, 0, 1, canvas.height);
                
                // Deep shadow
                ctx.fillStyle = `rgb(${Math.floor(baseR * 0.25)},${Math.floor(baseG * 0.25)},${Math.floor(baseB * 0.3)})`;
                ctx.fillRect(ribStart + 12, 0, 2, canvas.height);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        // Create roof-specific texture (ribs run horizontally for peak-to-eave direction)
        function createRoofTexture(color) {
            if (color === 'camo') return createCamoTexture();
            if (color === 'wood') return createWoodTexture();
            
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 360; // 36 inches, ribs run vertically in texture
            const ctx = canvas.getContext('2d');
            
            const c = new THREE.Color(color);
            const baseR = Math.floor(c.r * 255);
            const baseG = Math.floor(c.g * 255);
            const baseB = Math.floor(c.b * 255);
            
            // Fill base
            ctx.fillStyle = `rgb(${baseR},${baseG},${baseB})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw horizontal ribs at 12" intervals (every 120px in Y)
            const ribPositions = [0, 120, 240];
            const ribWidth = 14;
            
            for (let ribCenter of ribPositions) {
                const ribStart = ribCenter - Math.floor(ribWidth / 2);
                
                // Deep shadow
                ctx.fillStyle = `rgb(${Math.floor(baseR * 0.3)},${Math.floor(baseG * 0.3)},${Math.floor(baseB * 0.35)})`;
                ctx.fillRect(0, ribStart, canvas.width, 2);
                
                // Left slope
                ctx.fillStyle = `rgb(${Math.floor(baseR * 0.5)},${Math.floor(baseG * 0.5)},${Math.floor(baseB * 0.55)})`;
                ctx.fillRect(0, ribStart + 2, canvas.width, 1);
                
                ctx.fillStyle = `rgb(${Math.floor(baseR * 0.7)},${Math.floor(baseG * 0.7)},${Math.floor(baseB * 0.7)})`;
                ctx.fillRect(0, ribStart + 3, canvas.width, 1);
                
                // Highlight
                ctx.fillStyle = `rgb(${Math.min(255, Math.floor(baseR * 1.2))},${Math.min(255, Math.floor(baseG * 1.2))},${Math.min(255, Math.floor(baseB * 1.2))})`;
                ctx.fillRect(0, ribStart + 4, canvas.width, 1);
                
                // Bright top
                ctx.fillStyle = `rgb(${Math.min(255, Math.floor(baseR * 1.25))},${Math.min(255, Math.floor(baseG * 1.25))},${Math.min(255, Math.floor(baseB * 1.25))})`;
                ctx.fillRect(0, ribStart + 5, canvas.width, 4);
                
                // Right highlight
                ctx.fillStyle = `rgb(${Math.min(255, Math.floor(baseR * 1.15))},${Math.min(255, Math.floor(baseG * 1.15))},${Math.min(255, Math.floor(baseB * 1.15))})`;
                ctx.fillRect(0, ribStart + 9, canvas.width, 1);
                
                // Right slope
                ctx.fillStyle = `rgb(${Math.floor(baseR * 0.6)},${Math.floor(baseG * 0.6)},${Math.floor(baseB * 0.6)})`;
                ctx.fillRect(0, ribStart + 10, canvas.width, 1);
                
                ctx.fillStyle = `rgb(${Math.floor(baseR * 0.45)},${Math.floor(baseG * 0.45)},${Math.floor(baseB * 0.5)})`;
                ctx.fillRect(0, ribStart + 11, canvas.width, 1);
                
                // Deep shadow
                ctx.fillStyle = `rgb(${Math.floor(baseR * 0.25)},${Math.floor(baseG * 0.25)},${Math.floor(baseB * 0.3)})`;
                ctx.fillRect(0, ribStart + 12, canvas.width, 2);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        // Helper function to add proper UVs to ShapeGeometry for wall panels
        function addWallUVs(geom, wallWidth, wallHeight) {
            const positions = geom.attributes.position.array;
            const uvs = new Float32Array((positions.length / 3) * 2);
            for (let i = 0; i < positions.length / 3; i++) {
                const x = positions[i * 3];
                const y = positions[i * 3 + 1];
                uvs[i * 2] = (x + wallWidth/2) / wallWidth;
                uvs[i * 2 + 1] = (y + wallHeight/2) / wallHeight;
            }
            geom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
            return geom;
        }
        
        // Create camo pattern texture
        function createCamoTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base colors for realistic tree bark camo
            const camoColors = [
                'rgb(65, 55, 45)',    // Dark brown
                'rgb(85, 75, 60)',    // Medium brown
                'rgb(110, 95, 75)',   // Light brown
                'rgb(55, 65, 50)',    // Dark green-gray
                'rgb(75, 70, 55)',    // Olive brown
                'rgb(45, 40, 35)'     // Very dark
            ];
            
            // Fill with base color
            ctx.fillStyle = camoColors[1];
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add irregular camo patches
            for (let i = 0; i < 80; i++) {
                ctx.fillStyle = camoColors[Math.floor(Math.random() * camoColors.length)];
                ctx.beginPath();
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const w = 20 + Math.random() * 60;
                const h = 30 + Math.random() * 80;
                
                // Create organic blob shapes
                ctx.moveTo(x, y);
                for (let j = 0; j < 8; j++) {
                    const angle = (j / 8) * Math.PI * 2;
                    const radius = (w/2) * (0.6 + Math.random() * 0.8);
                    ctx.lineTo(
                        x + Math.cos(angle) * radius,
                        y + Math.sin(angle) * radius * (h/w)
                    );
                }
                ctx.closePath();
                ctx.fill();
            }
            
            // Add small details/noise
            for (let i = 0; i < 200; i++) {
                ctx.fillStyle = camoColors[Math.floor(Math.random() * camoColors.length)];
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                ctx.fillRect(x, y, 3 + Math.random() * 8, 3 + Math.random() * 12);
            }
            
            // Add ribbing effect
            const ribWidth = 32;
            for (let x = 0; x < canvas.width; x++) {
                const ribPos = x % ribWidth;
                let alpha;
                if (ribPos < ribWidth * 0.1 || ribPos > ribWidth * 0.9) {
                    alpha = 0.3;
                } else if (ribPos < ribWidth * 0.2 || ribPos > ribWidth * 0.8) {
                    alpha = 0.15;
                } else {
                    alpha = 0;
                }
                if (alpha > 0) {
                    ctx.fillStyle = `rgba(0,0,0,${alpha})`;
                    ctx.fillRect(x, 0, 1, canvas.height);
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        // Create wood grain texture
        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Panel width for the ribbed metal look
            const panelWidth = 32;
            const numPanels = Math.ceil(canvas.width / panelWidth);
            
            // Draw each panel as a separate wood plank with slight color variation
            for (let p = 0; p < numPanels; p++) {
                const panelX = p * panelWidth;
                
                // Each plank has slightly different base color (like real wood panels)
                const plankVariation = (Math.random() - 0.5) * 30;
                const baseR = 135 + plankVariation + Math.random() * 20;
                const baseG = 85 + plankVariation * 0.7 + Math.random() * 15;
                const baseB = 55 + plankVariation * 0.5 + Math.random() * 10;
                
                // Fill panel base
                ctx.fillStyle = `rgb(${Math.floor(baseR)},${Math.floor(baseG)},${Math.floor(baseB)})`;
                ctx.fillRect(panelX, 0, panelWidth, canvas.height);
                
                // Add horizontal wood grain lines within each panel
                for (let y = 0; y < canvas.height; y++) {
                    // Natural grain variation
                    const grainWave = Math.sin(y * 0.015 + p) * 8 + Math.sin(y * 0.04 + p * 2) * 4;
                    const grainNoise = (Math.random() - 0.5) * 12;
                    
                    for (let x = panelX; x < panelX + panelWidth && x < canvas.width; x++) {
                        const localX = x - panelX;
                        
                        // Ribbing effect (raised center, darker edges)
                        let ribShade = 0;
                        if (localX < 3 || localX > panelWidth - 4) {
                            ribShade = -40; // Dark seam between panels
                        } else if (localX < 6 || localX > panelWidth - 7) {
                            ribShade = -20;
                        } else if (localX > panelWidth/2 - 4 && localX < panelWidth/2 + 4) {
                            ribShade = 10; // Slight highlight in center
                        }
                        
                        // Horizontal grain streaks
                        const grainStreak = Math.sin((y + localX * 0.3) * 0.08) * 15;
                        
                        const r = Math.max(0, Math.min(255, baseR + grainWave + grainNoise + ribShade + grainStreak));
                        const g = Math.max(0, Math.min(255, baseG + (grainWave + grainNoise) * 0.7 + ribShade * 0.8 + grainStreak * 0.7));
                        const b = Math.max(0, Math.min(255, baseB + (grainWave + grainNoise) * 0.5 + ribShade * 0.6 + grainStreak * 0.5));
                        
                        ctx.fillStyle = `rgb(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)})`;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
                
                // Add darker wood grain lines (knots and grain patterns)
                for (let i = 0; i < 4; i++) {
                    const grainX = panelX + 5 + Math.random() * (panelWidth - 10);
                    ctx.strokeStyle = `rgba(70, 45, 25, ${0.15 + Math.random() * 0.2})`;
                    ctx.lineWidth = 1 + Math.random() * 1.5;
                    ctx.beginPath();
                    ctx.moveTo(grainX, 0);
                    let curX = grainX;
                    for (let y = 0; y < canvas.height; y += 8) {
                        curX += (Math.random() - 0.5) * 2;
                        curX = Math.max(panelX + 3, Math.min(panelX + panelWidth - 3, curX));
                        ctx.lineTo(curX, y);
                    }
                    ctx.stroke();
                }
                
                // Add occasional knot marks
                if (Math.random() > 0.6) {
                    const knotX = panelX + panelWidth/2 + (Math.random() - 0.5) * 15;
                    const knotY = Math.random() * canvas.height;
                    const knotSize = 3 + Math.random() * 5;
                    
                    const gradient = ctx.createRadialGradient(knotX, knotY, 0, knotX, knotY, knotSize);
                    gradient.addColorStop(0, 'rgba(50, 30, 15, 0.6)');
                    gradient.addColorStop(0.5, 'rgba(70, 45, 25, 0.3)');
                    gradient.addColorStop(1, 'rgba(90, 60, 35, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(knotX, knotY, knotSize, knotSize * 1.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Add subtle horizontal lines to simulate the printed grain texture
            for (let y = 0; y < canvas.height; y += 2) {
                if (Math.random() > 0.7) {
                    ctx.strokeStyle = `rgba(60, 40, 20, ${0.05 + Math.random() * 0.08})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        function createBuilding() {
            Object.keys(groups).forEach(key => {
                if (groups[key]) {
                    scene.remove(groups[key]);
                    groups[key].traverse(c => {
                        if (c.geometry) c.geometry.dispose();
                        if (c.material) c.material.dispose();
                    });
                }
                groups[key] = null;
            });
            
            const S = 1/3;
            const W = params.width * S;
            const L = params.length * S;
            const H = params.height * S;
            const rise = (W / 2) * (params.pitch / 12);
            const roofAngle = Math.atan2(rise, W/2);
            const rafterLen = Math.sqrt((W/2) * (W/2) + rise * rise);
            const numBays = Math.max(1, Math.floor(params.length / params.baySpacing));
            
            document.getElementById('bays-value').textContent = numBays;
            
            const redIronMat = new THREE.MeshStandardMaterial({ color: 0x8B3A3A, roughness: 0.5, metalness: 0.4 });
            const purlinMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.4, metalness: 0.5 });
            const trimMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5 });
            soffitMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide });
            
            // ========== FRAMING ==========
            groups.framing = new THREE.Group();
            
            const colW = 0.35, colD = 0.2, rafH = 0.3, rafW = 0.15, frameInset = 0.15;
            
            for (let i = 0; i <= numBays; i++) {
                const z = -L/2 + frameInset + i * (L - frameInset * 2) / numBays;
                
                const colGeom = new THREE.BoxGeometry(colW, H, colD);
                const leftCol = new THREE.Mesh(colGeom, redIronMat);
                leftCol.position.set(-W/2 + colW/2, H/2, z);
                groups.framing.add(leftCol);
                
                const rightCol = new THREE.Mesh(colGeom, redIronMat);
                rightCol.position.set(W/2 - colW/2, H/2, z);
                groups.framing.add(rightCol);
                
                const rafGeom = new THREE.BoxGeometry(rafterLen, rafH, rafW);
                const leftRaf = new THREE.Mesh(rafGeom, redIronMat);
                leftRaf.position.set(-W/4, H + rise/2 - 0.25, z);
                leftRaf.rotation.z = roofAngle;
                groups.framing.add(leftRaf);
                
                const rightRaf = new THREE.Mesh(rafGeom, redIronMat);
                rightRaf.position.set(W/4, H + rise/2 - 0.25, z);
                rightRaf.rotation.z = -roofAngle;
                groups.framing.add(rightRaf);
            }
            
            const purlinLen = L - frameInset * 2 - 0.1;
            const purlinGeom = new THREE.BoxGeometry(0.08, 0.1, purlinLen);
            for (let p = 0; p <= Math.ceil(rafterLen / 1.0); p++) {
                const t = (p * 1.0) / rafterLen;
                if (t <= 1) {
                    const xOff = t * (W/2), yOff = t * rise;
                    const lp = new THREE.Mesh(purlinGeom, purlinMat);
                    lp.position.set(-W/2 + xOff, H + yOff - 0.15, 0);
                    groups.framing.add(lp);
                    if (p > 0) {
                        const rp = new THREE.Mesh(purlinGeom, purlinMat);
                        rp.position.set(W/2 - xOff, H + yOff - 0.15, 0);
                        groups.framing.add(rp);
                    }
                }
            }
            
            // Framing girts - need to account for open inset areas
            const frontInsetDistFrame = params.frontInset * params.baySpacing * S;
            const backInsetDistFrame = params.backInset * params.baySpacing * S;
            
            // Left side girts - only run through enclosed section
            const leftGirtFrontEnd = L/2 - (params.frontInset > 0 && !params.frontInsetLeftWall ? frontInsetDistFrame : 0);
            const leftGirtBackEnd = -L/2 + (params.backInset > 0 && !params.backInsetLeftWall ? backInsetDistFrame : 0);
            const leftGirtLen = leftGirtFrontEnd - leftGirtBackEnd;
            const leftGirtCenter = (leftGirtFrontEnd + leftGirtBackEnd) / 2;
            
            // Right side girts - only run through enclosed section
            const rightGirtFrontEnd = L/2 - (params.frontInset > 0 && !params.frontInsetRightWall ? frontInsetDistFrame : 0);
            const rightGirtBackEnd = -L/2 + (params.backInset > 0 && !params.backInsetRightWall ? backInsetDistFrame : 0);
            const rightGirtLen = rightGirtFrontEnd - rightGirtBackEnd;
            const rightGirtCenter = (rightGirtFrontEnd + rightGirtBackEnd) / 2;
            
            for (let g = 1; g < H / 1.5; g++) {
                const y = g * 1.5;
                if (leftGirtLen > 0) {
                    const lgGeom = new THREE.BoxGeometry(0.08, 0.1, leftGirtLen);
                    const lg = new THREE.Mesh(lgGeom, purlinMat);
                    lg.position.set(-W/2 + colW + 0.05, y, leftGirtCenter);
                    groups.framing.add(lg);
                }
                if (rightGirtLen > 0) {
                    const rgGeom = new THREE.BoxGeometry(0.08, 0.1, rightGirtLen);
                    const rg = new THREE.Mesh(rgGeom, purlinMat);
                    rg.position.set(W/2 - colW - 0.05, y, rightGirtCenter);
                    groups.framing.add(rg);
                }
            }
            
            scene.add(groups.framing);
            groups.framing.visible = params.showFraming;
            
            // ========== FRONT/BACK BAY FRAMING ==========
            groups.frontBackBayFraming = new THREE.Group();
            if (params.showFrontBackBays) {
                const numFrontBackBays = Math.max(1, Math.floor(params.width / params.frontBackBaySpacing));
                const frontBackBayWidth = W / numFrontBackBays;
                const roofThickness = 0.15; // Keep framing below roof surface
                
                // Calculate inset positions for bay framing
                const frontInsetDist = params.frontInset * params.baySpacing * S;
                const backInsetDist = params.backInset * params.baySpacing * S;
                const frontFrameZ = L/2 - frontInsetDist - frameInset;
                const backFrameZ = -L/2 + backInsetDist + frameInset;
                
                // Front and back bay columns
                for (let i = 1; i < numFrontBackBays; i++) {
                    const x = -W/2 + i * frontBackBayWidth;
                    
                    // Calculate height at this X position (gable shape) - stop below roof
                    const distFromCenter = Math.abs(x);
                    const roofHeightAtX = H + rise - (distFromCenter / (W/2)) * rise;
                    const colHeight = roofHeightAtX - roofThickness;
                    
                    // Front bay column (at inset position)
                    const frontColGeom = new THREE.BoxGeometry(colW, colHeight, colD);
                    const frontCol = new THREE.Mesh(frontColGeom, redIronMat);
                    frontCol.position.set(x, colHeight/2, frontFrameZ);
                    groups.frontBackBayFraming.add(frontCol);
                    
                    // Back bay column (at inset position)
                    const backCol = new THREE.Mesh(frontColGeom, redIronMat);
                    backCol.position.set(x, colHeight/2, backFrameZ);
                    groups.frontBackBayFraming.add(backCol);
                    
                    // Diagonal rafter from column top to ridge (below roof surface)
                    // Rafter goes from (x, colHeight) to (0, H + rise - roofThickness)
                    const ridgeHeight = H + rise - roofThickness;
                    const rafterDx = Math.abs(x);
                    const rafterDy = ridgeHeight - colHeight;
                    const rafterLen = Math.sqrt(rafterDx * rafterDx + rafterDy * rafterDy);
                    const rafterAngle = Math.atan2(rafterDy, rafterDx);
                    
                    // Front rafter
                    const frontRafter = new THREE.Mesh(new THREE.BoxGeometry(rafterLen, rafH * 0.6, rafW), redIronMat);
                    frontRafter.position.set(x/2, (colHeight + ridgeHeight)/2, frontFrameZ);
                    frontRafter.rotation.z = x < 0 ? rafterAngle : Math.PI - rafterAngle;
                    groups.frontBackBayFraming.add(frontRafter);
                    
                    // Back rafter
                    const backRafter = frontRafter.clone();
                    backRafter.position.z = backFrameZ;
                    groups.frontBackBayFraming.add(backRafter);
                }
            }
            scene.add(groups.frontBackBayFraming);
            groups.frontBackBayFraming.visible = params.showFrontBackBays && params.showFraming;
            
            // ========== ROOF ==========
            groups.roof = new THREE.Group();
            
            // Overhang values
            const eaveOH = params.eaveOverhang * S; // Side overhang (extends roof slope outward)
            const gableOH = params.gableOverhang * S; // End overhang (extends roof along length)
            
            // Roof panels run from ridge down to eave - ribs perpendicular to ridge
            const roofSlopeLen = Math.sqrt((W/2) * (W/2) + rise * rise);
            const roofSlopeLenWithOH = Math.sqrt((W/2 + eaveOH) * (W/2 + eaveOH) + (rise + eaveOH * (rise/(W/2))) * (rise + eaveOH * (rise/(W/2))));
            const roofLengthWithOH = L + gableOH * 2;
            const roofPanelsAcross = (params.length + params.gableOverhang * 2) / 3; // 3ft panels along ridge
            
            // Calculate overhang drop - roof continues at same slope past the wall
            const slopeRatio = rise / (W/2); // rise per horizontal unit
            const eaveOHdrop = eaveOH * slopeRatio; // how much lower the overhang edge is
            
            // Left roof with overhang - single continuous surface from ridge to overhang edge
            // Ridge is at (0, H+rise), wall line is at (-W/2, H), overhang edge is at (-W/2-eaveOH, H-eaveOHdrop)
            const leftRoofVerts = new Float32Array([
                // Triangle 1
                0, H + rise, -L/2 - gableOH,  // Ridge front
                -W/2 - eaveOH, H - eaveOHdrop, -L/2 - gableOH,  // Overhang edge front
                0, H + rise, L/2 + gableOH,   // Ridge back
                // Triangle 2
                -W/2 - eaveOH, H - eaveOHdrop, -L/2 - gableOH,  // Overhang edge front
                -W/2 - eaveOH, H - eaveOHdrop, L/2 + gableOH,   // Overhang edge back
                0, H + rise, L/2 + gableOH    // Ridge back
            ]);
            const leftRoofUVs = new Float32Array([
                0, 0,  1, 0,  0, 1,
                1, 0,  1, 1,  0, 1
            ]);
            const leftRoofGeom = new THREE.BufferGeometry();
            leftRoofGeom.setAttribute('position', new THREE.BufferAttribute(leftRoofVerts, 3));
            leftRoofGeom.setAttribute('uv', new THREE.BufferAttribute(leftRoofUVs, 2));
            leftRoofGeom.computeVertexNormals();
            const leftRoofTex = createRoofTexture(colors.roof);
            leftRoofTex.repeat.set(1, roofPanelsAcross);
            const leftRoof = new THREE.Mesh(leftRoofGeom, new THREE.MeshStandardMaterial({ map: leftRoofTex, roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide }));
            groups.roof.add(leftRoof);
            
            // Right roof with overhang
            const rightRoofVerts = new Float32Array([
                // Triangle 1
                0, H + rise, -L/2 - gableOH,  // Ridge front
                0, H + rise, L/2 + gableOH,   // Ridge back
                W/2 + eaveOH, H - eaveOHdrop, -L/2 - gableOH,  // Overhang edge front
                // Triangle 2
                0, H + rise, L/2 + gableOH,   // Ridge back
                W/2 + eaveOH, H - eaveOHdrop, L/2 + gableOH,   // Overhang edge back
                W/2 + eaveOH, H - eaveOHdrop, -L/2 - gableOH   // Overhang edge front
            ]);
            const rightRoofUVs = new Float32Array([
                0, 0,  0, 1,  1, 0,
                0, 1,  1, 1,  1, 0
            ]);
            const rightRoofGeom = new THREE.BufferGeometry();
            rightRoofGeom.setAttribute('position', new THREE.BufferAttribute(rightRoofVerts, 3));
            rightRoofGeom.setAttribute('uv', new THREE.BufferAttribute(rightRoofUVs, 2));
            rightRoofGeom.computeVertexNormals();
            const rightRoofTex = createRoofTexture(colors.roof);
            rightRoofTex.repeat.set(1, roofPanelsAcross);
            const rightRoof = new THREE.Mesh(rightRoofGeom, new THREE.MeshStandardMaterial({ map: rightRoofTex, roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide }));
            groups.roof.add(rightRoof);
            
            // Ridge trim (extended for gable overhang)
            const ridge = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.06, L + gableOH * 2 + 0.1), trimMat.clone());
            ridge.position.set(0, H + rise + 0.03, 0);
            groups.roof.add(ridge);
            
            // Eave trim at the outer edge of overhang (or at wall line if no overhang)
            const eaveTrimY = eaveOH > 0 ? H - eaveOHdrop : H;
            const eaveTrimXLeft = eaveOH > 0 ? -W/2 - eaveOH - 0.04 : -W/2 - 0.04;
            const eaveTrimXRight = eaveOH > 0 ? W/2 + eaveOH + 0.04 : W/2 + 0.04;
            
            const leftEaveTrim = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, L + gableOH * 2), trimMat.clone());
            leftEaveTrim.position.set(eaveTrimXLeft, eaveTrimY, 0);
            groups.roof.add(leftEaveTrim);
            
            const rightEaveTrim = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, L + gableOH * 2), trimMat.clone());
            rightEaveTrim.position.set(eaveTrimXRight, eaveTrimY, 0);
            groups.roof.add(rightEaveTrim);
            
            // Soffit (underside of eave overhang) - trim color
            if (eaveOH > 0) {
                // Left soffit - only extends along the building length (not past gable)
                const leftSoffitGeom = new THREE.PlaneGeometry(eaveOH, L);
                const leftSoffit = new THREE.Mesh(leftSoffitGeom, new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide }));
                leftSoffit.position.set(-W/2 - eaveOH/2, H - eaveOHdrop + 0.01, 0);
                leftSoffit.rotation.x = Math.PI/2;
                groups.roof.add(leftSoffit);
                
                // Right soffit
                const rightSoffit = new THREE.Mesh(leftSoffitGeom.clone(), new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide }));
                rightSoffit.position.set(W/2 + eaveOH/2, H - eaveOHdrop + 0.01, 0);
                rightSoffit.rotation.x = Math.PI/2;
                groups.roof.add(rightSoffit);
            }
            
            // Gable overhang trim (rake trim on front and back)
            if (gableOH > 0) {
                // Front rake trims (left and right slopes)
                const rakeLength = Math.sqrt((W/2 + eaveOH) * (W/2 + eaveOH) + (rise + eaveOHdrop) * (rise + eaveOHdrop));
                
                const frontLeftRake = new THREE.Mesh(new THREE.BoxGeometry(rakeLength, 0.08, 0.12), trimMat.clone());
                frontLeftRake.rotation.z = roofAngle;
                frontLeftRake.position.set(-W/4 - eaveOH/2, H + rise/2 - eaveOHdrop/2, L/2 + gableOH + 0.04);
                groups.roof.add(frontLeftRake);
                
                const frontRightRake = new THREE.Mesh(new THREE.BoxGeometry(rakeLength, 0.08, 0.12), trimMat.clone());
                frontRightRake.rotation.z = -roofAngle;
                frontRightRake.position.set(W/4 + eaveOH/2, H + rise/2 - eaveOHdrop/2, L/2 + gableOH + 0.04);
                groups.roof.add(frontRightRake);
                
                // Back rake trims
                const backLeftRake = new THREE.Mesh(new THREE.BoxGeometry(rakeLength, 0.08, 0.12), trimMat.clone());
                backLeftRake.rotation.z = roofAngle;
                backLeftRake.position.set(-W/4 - eaveOH/2, H + rise/2 - eaveOHdrop/2, -L/2 - gableOH - 0.04);
                groups.roof.add(backLeftRake);
                
                const backRightRake = new THREE.Mesh(new THREE.BoxGeometry(rakeLength, 0.08, 0.12), trimMat.clone());
                backRightRake.rotation.z = -roofAngle;
                backRightRake.position.set(W/4 + eaveOH/2, H + rise/2 - eaveOHdrop/2, -L/2 - gableOH - 0.04);
                groups.roof.add(backRightRake);
                
                // Gable soffits - angled panels following roof pitch, just below roof surface
                // These create the trim-colored underside of the gable overhang
                const gableSoffitMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide });
                const soffitGap = 0.02; // Small gap to prevent z-fighting
                
                // Front gable soffits - skip if front lean-to is enabled (lean-to covers this area)
                if (!leanTos.front.enabled) {
                    // Left side - from left eave to ridge
                    const frontLeftSoffitVerts = new Float32Array([
                        // Triangle 1
                        -W/2 - eaveOH, H - eaveOHdrop - soffitGap, L/2,  // Eave corner (inside)
                        -W/2 - eaveOH, H - eaveOHdrop - soffitGap, L/2 + gableOH,  // Eave corner (outside)
                        0, H + rise - soffitGap, L/2,  // Ridge (inside)
                        // Triangle 2
                        0, H + rise - soffitGap, L/2,  // Ridge (inside)
                        -W/2 - eaveOH, H - eaveOHdrop - soffitGap, L/2 + gableOH,  // Eave corner (outside)
                        0, H + rise - soffitGap, L/2 + gableOH  // Ridge (outside)
                    ]);
                    const frontLeftSoffitGeom = new THREE.BufferGeometry();
                    frontLeftSoffitGeom.setAttribute('position', new THREE.BufferAttribute(frontLeftSoffitVerts, 3));
                    frontLeftSoffitGeom.computeVertexNormals();
                    const frontLeftSoffit = new THREE.Mesh(frontLeftSoffitGeom, gableSoffitMat.clone());
                    groups.roof.add(frontLeftSoffit);
                    
                    // Front right side - from ridge to right eave
                    const frontRightSoffitVerts = new Float32Array([
                        // Triangle 1
                        0, H + rise - soffitGap, L/2,  // Ridge (inside)
                        0, H + rise - soffitGap, L/2 + gableOH,  // Ridge (outside)
                        W/2 + eaveOH, H - eaveOHdrop - soffitGap, L/2,  // Eave corner (inside)
                        // Triangle 2
                        W/2 + eaveOH, H - eaveOHdrop - soffitGap, L/2,  // Eave corner (inside)
                        0, H + rise - soffitGap, L/2 + gableOH,  // Ridge (outside)
                        W/2 + eaveOH, H - eaveOHdrop - soffitGap, L/2 + gableOH  // Eave corner (outside)
                    ]);
                    const frontRightSoffitGeom = new THREE.BufferGeometry();
                    frontRightSoffitGeom.setAttribute('position', new THREE.BufferAttribute(frontRightSoffitVerts, 3));
                    frontRightSoffitGeom.computeVertexNormals();
                    const frontRightSoffit = new THREE.Mesh(frontRightSoffitGeom, gableSoffitMat.clone());
                    groups.roof.add(frontRightSoffit);
                }
                
                // Back gable soffits - skip if back lean-to is enabled
                if (!leanTos.back.enabled) {
                    // Left side
                    const backLeftSoffitVerts = new Float32Array([
                        // Triangle 1
                        -W/2 - eaveOH, H - eaveOHdrop - soffitGap, -L/2,  // Eave corner (inside)
                        0, H + rise - soffitGap, -L/2,  // Ridge (inside)
                        -W/2 - eaveOH, H - eaveOHdrop - soffitGap, -L/2 - gableOH,  // Eave corner (outside)
                        // Triangle 2
                        -W/2 - eaveOH, H - eaveOHdrop - soffitGap, -L/2 - gableOH,  // Eave corner (outside)
                        0, H + rise - soffitGap, -L/2,  // Ridge (inside)
                        0, H + rise - soffitGap, -L/2 - gableOH  // Ridge (outside)
                    ]);
                    const backLeftSoffitGeom = new THREE.BufferGeometry();
                    backLeftSoffitGeom.setAttribute('position', new THREE.BufferAttribute(backLeftSoffitVerts, 3));
                    backLeftSoffitGeom.computeVertexNormals();
                    const backLeftSoffit = new THREE.Mesh(backLeftSoffitGeom, gableSoffitMat.clone());
                    groups.roof.add(backLeftSoffit);
                    
                    // Back right side
                    const backRightSoffitVerts = new Float32Array([
                        // Triangle 1
                        0, H + rise - soffitGap, -L/2,  // Ridge (inside)
                        W/2 + eaveOH, H - eaveOHdrop - soffitGap, -L/2,  // Eave corner (inside)
                        0, H + rise - soffitGap, -L/2 - gableOH,  // Ridge (outside)
                        // Triangle 2
                        0, H + rise - soffitGap, -L/2 - gableOH,  // Ridge (outside)
                        W/2 + eaveOH, H - eaveOHdrop - soffitGap, -L/2,  // Eave corner (inside)
                        W/2 + eaveOH, H - eaveOHdrop - soffitGap, -L/2 - gableOH  // Eave corner (outside)
                    ]);
                    const backRightSoffitGeom = new THREE.BufferGeometry();
                    backRightSoffitGeom.setAttribute('position', new THREE.BufferAttribute(backRightSoffitVerts, 3));
                    backRightSoffitGeom.computeVertexNormals();
                    const backRightSoffit = new THREE.Mesh(backRightSoffitGeom, gableSoffitMat.clone());
                    groups.roof.add(backRightSoffit);
                }
                
                // Corner soffits - fill the triangular gap at each corner between eave soffit and gable soffit
                // These are horizontal triangles at each corner
                // Skip corners where lean-tos exist (lean-tos handle their own soffits)
                
                // Front left corner soffit - skip if front or left lean-to exists
                if (!leanTos.front.enabled && !leanTos.left.enabled) {
                    const flCornerSoffitVerts = new Float32Array([
                        -W/2, H - eaveOHdrop - soffitGap, L/2,  // Wall corner
                        -W/2 - eaveOH, H - eaveOHdrop - soffitGap, L/2,  // Eave edge at building end
                        -W/2 - eaveOH, H - eaveOHdrop - soffitGap, L/2 + gableOH  // Outer corner
                    ]);
                    const flCornerSoffitGeom = new THREE.BufferGeometry();
                    flCornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(flCornerSoffitVerts, 3));
                    flCornerSoffitGeom.computeVertexNormals();
                    groups.roof.add(new THREE.Mesh(flCornerSoffitGeom, gableSoffitMat.clone()));
                }
                
                // Front right corner soffit - skip if front or right lean-to exists
                if (!leanTos.front.enabled && !leanTos.right.enabled) {
                    const frCornerSoffitVerts = new Float32Array([
                        W/2, H - eaveOHdrop - soffitGap, L/2,  // Wall corner
                        W/2 + eaveOH, H - eaveOHdrop - soffitGap, L/2 + gableOH,  // Outer corner
                        W/2 + eaveOH, H - eaveOHdrop - soffitGap, L/2  // Eave edge at building end
                    ]);
                    const frCornerSoffitGeom = new THREE.BufferGeometry();
                    frCornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(frCornerSoffitVerts, 3));
                    frCornerSoffitGeom.computeVertexNormals();
                    groups.roof.add(new THREE.Mesh(frCornerSoffitGeom, gableSoffitMat.clone()));
                }
                
                // Back left corner soffit - skip if back or left lean-to exists
                if (!leanTos.back.enabled && !leanTos.left.enabled) {
                    const blCornerSoffitVerts = new Float32Array([
                        -W/2, H - eaveOHdrop - soffitGap, -L/2,  // Wall corner
                        -W/2 - eaveOH, H - eaveOHdrop - soffitGap, -L/2 - gableOH,  // Outer corner
                        -W/2 - eaveOH, H - eaveOHdrop - soffitGap, -L/2  // Eave edge at building end
                    ]);
                    const blCornerSoffitGeom = new THREE.BufferGeometry();
                    blCornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(blCornerSoffitVerts, 3));
                    blCornerSoffitGeom.computeVertexNormals();
                    groups.roof.add(new THREE.Mesh(blCornerSoffitGeom, gableSoffitMat.clone()));
                }
                
                // Back right corner soffit - skip if back or right lean-to exists
                if (!leanTos.back.enabled && !leanTos.right.enabled) {
                    const brCornerSoffitVerts = new Float32Array([
                        W/2, H - eaveOHdrop - soffitGap, -L/2,  // Wall corner
                        W/2 + eaveOH, H - eaveOHdrop - soffitGap, -L/2,  // Eave edge at building end
                        W/2 + eaveOH, H - eaveOHdrop - soffitGap, -L/2 - gableOH  // Outer corner
                    ]);
                    const brCornerSoffitGeom = new THREE.BufferGeometry();
                    brCornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(brCornerSoffitVerts, 3));
                    brCornerSoffitGeom.computeVertexNormals();
                    groups.roof.add(new THREE.Mesh(brCornerSoffitGeom, gableSoffitMat.clone()));
                }
            }
            
            scene.add(groups.roof);
            groups.roof.visible = params.showRoof;
            
            // ========== WALLS ==========
            const wallOffset = 0.05;
            
            // Helper function to create wall with holes for frameouts
            function createWallWithHoles(wallName, isEndwall, wallWidth, wallHeight, rise) {
                const S = 1/3;
                const wallFrameouts = accessories.filter(a => a.wall === wallName && a.type === 'frameout');
                
                // If no frameouts, use PlaneGeometry for proper UVs
                if (wallFrameouts.length === 0 && !isEndwall) {
                    return new THREE.PlaneGeometry(wallWidth, wallHeight);
                }
                
                let shape;
                if (isEndwall) {
                    // Gable shape
                    shape = new THREE.Shape();
                    shape.moveTo(-wallWidth/2 - wallOffset, 0);
                    shape.lineTo(wallWidth/2 + wallOffset, 0);
                    shape.lineTo(wallWidth/2 + wallOffset, wallHeight);
                    shape.lineTo(0, wallHeight + rise);
                    shape.lineTo(-wallWidth/2 - wallOffset, wallHeight);
                    shape.closePath();
                } else {
                    // Rectangle
                    shape = new THREE.Shape();
                    shape.moveTo(-wallWidth/2, -wallHeight/2);
                    shape.lineTo(wallWidth/2, -wallHeight/2);
                    shape.lineTo(wallWidth/2, wallHeight/2);
                    shape.lineTo(-wallWidth/2, wallHeight/2);
                    shape.closePath();
                }
                
                // Cut holes for frameouts
                wallFrameouts.forEach(acc => {
                    const fw = acc.width * S;
                    const fh = acc.height * S;
                    let fx = acc.posX || 0;
                    if (wallName === 'left' || wallName === 'right') {
                        fx = -fx;
                    }
                    const heightOffset = acc.posY || 0;
                    let fy;
                    if (isEndwall) {
                        fy = fh/2 + heightOffset;
                    } else {
                        fy = fh/2 + heightOffset - wallHeight/2;
                    }
                    
                    const hole = new THREE.Path();
                    hole.moveTo(fx - fw/2, fy - fh/2);
                    hole.lineTo(fx + fw/2, fy - fh/2);
                    hole.lineTo(fx + fw/2, fy + fh/2);
                    hole.lineTo(fx - fw/2, fy + fh/2);
                    hole.closePath();
                    shape.holes.push(hole);
                });
                
                const geom = new THREE.ShapeGeometry(shape);
                
                // Generate proper UVs based on wall dimensions
                const positions = geom.attributes.position.array;
                const uvs = new Float32Array((positions.length / 3) * 2);
                
                for (let i = 0; i < positions.length / 3; i++) {
                    const x = positions[i * 3];
                    const y = positions[i * 3 + 1];
                    
                    if (isEndwall) {
                        // Endwall: UV based on position, Y starts at 0
                        uvs[i * 2] = (x + wallWidth/2 + wallOffset) / (wallWidth + wallOffset * 2);
                        uvs[i * 2 + 1] = y / (wallHeight + rise);
                    } else {
                        // Sidewall: centered geometry
                        uvs[i * 2] = (x + wallWidth/2) / wallWidth;
                        uvs[i * 2 + 1] = (y + wallHeight/2) / wallHeight;
                    }
                }
                
                geom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
                return geom;
            }
            
            // LEFT
            groups.left = new THREE.Group();
            
            // Calculate the actual sidewall length accounting for insets
            const frontInsetDist = params.frontInset * params.baySpacing * S;
            const backInsetDist = params.backInset * params.baySpacing * S;
            
            // Determine if we need to shorten the main sidewall
            const leftWallFrontEnd = L/2 - (params.frontInset > 0 && !params.frontInsetLeftWall ? frontInsetDist : 0);
            const leftWallBackEnd = -L/2 + (params.backInset > 0 && !params.backInsetLeftWall ? backInsetDist : 0);
            const leftWallLength = leftWallFrontEnd - leftWallBackEnd;
            const leftWallCenter = (leftWallFrontEnd + leftWallBackEnd) / 2;
            
            const leftTex = createPanelTexture(colors.wall);
            leftTex.repeat.set(leftWallLength * 0.8 / S, 1);
            const leftGeom = new THREE.PlaneGeometry(leftWallLength, H);
            const leftWall = new THREE.Mesh(leftGeom, new THREE.MeshStandardMaterial({ map: leftTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
            leftWall.position.set(-W/2 - wallOffset, H/2, leftWallCenter);
            leftWall.rotation.y = -Math.PI/2;
            groups.left.add(leftWall);
            
            // Base trim - shorten to match wall length
            const leftBaseTrimLen = leftWallLength > 0 ? leftWallLength : 0;
            if (leftBaseTrimLen > 0) {
                groups.left.add(new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, leftBaseTrimLen + 0.1), trimMat.clone()).translateY(0.075).translateX(-W/2 - wallOffset).translateZ(leftWallCenter));
            }
            // Top trim only when no eave overhang (otherwise roof eave trim handles it)
            if (eaveOH === 0 && leftWallLength > 0) {
                groups.left.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, leftWallLength + 0.1), trimMat.clone()).translateY(H + 0.03).translateX(-W/2 - wallOffset).translateZ(leftWallCenter));
            }
            // Corner trim - only add at ends where there's no open inset
            // Front corner (Z = L/2) - skip if front inset with left wall open
            if (!(params.frontInset > 0 && !params.frontInsetLeftWall)) {
                groups.left.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, H, 0.08), trimMat.clone()).translateY(H/2).translateX(-W/2 - wallOffset).translateZ(L/2 + wallOffset));
            }
            // Back corner (Z = -L/2) - skip if back inset with left wall open
            if (!(params.backInset > 0 && !params.backInsetLeftWall)) {
                groups.left.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, H, 0.08), trimMat.clone()).translateY(H/2).translateX(-W/2 - wallOffset).translateZ(-L/2 - wallOffset));
            }
            
            // Add girts only in the enclosed section
            const girtMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.5, metalness: 0.4 });
            const girtHeight1 = H * 0.33;
            const girtHeight2 = H * 0.66;
            if (leftWallLength > 0) {
                groups.left.add(new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.08, leftWallLength), girtMat.clone()).translateY(girtHeight1).translateX(-W/2 - wallOffset + 0.04).translateZ(leftWallCenter));
                groups.left.add(new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.08, leftWallLength), girtMat.clone()).translateY(girtHeight2).translateX(-W/2 - wallOffset + 0.04).translateZ(leftWallCenter));
            }
            
            scene.add(groups.left);
            groups.left.visible = params.showLeft;
            
            // RIGHT
            groups.right = new THREE.Group();
            
            // Determine if we need to shorten the main sidewall for right side
            const rightWallFrontEnd = L/2 - (params.frontInset > 0 && !params.frontInsetRightWall ? frontInsetDist : 0);
            const rightWallBackEnd = -L/2 + (params.backInset > 0 && !params.backInsetRightWall ? backInsetDist : 0);
            const rightWallLength = rightWallFrontEnd - rightWallBackEnd;
            const rightWallCenter = (rightWallFrontEnd + rightWallBackEnd) / 2;
            
            const rightTex = createPanelTexture(colors.wall);
            rightTex.repeat.set(rightWallLength * 0.8 / S, 1);
            const rightGeom = new THREE.PlaneGeometry(rightWallLength, H);
            const rightWall = new THREE.Mesh(rightGeom, new THREE.MeshStandardMaterial({ map: rightTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
            rightWall.position.set(W/2 + wallOffset, H/2, rightWallCenter);
            rightWall.rotation.y = Math.PI/2;
            groups.right.add(rightWall);
            
            // Base trim - shorten to match wall length
            const rightBaseTrimLen = rightWallLength > 0 ? rightWallLength : 0;
            if (rightBaseTrimLen > 0) {
                groups.right.add(new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, rightBaseTrimLen + 0.1), trimMat.clone()).translateY(0.075).translateX(W/2 + wallOffset).translateZ(rightWallCenter));
            }
            // Top trim only when no eave overhang
            if (eaveOH === 0 && rightWallLength > 0) {
                groups.right.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, rightWallLength + 0.1), trimMat.clone()).translateY(H + 0.03).translateX(W/2 + wallOffset).translateZ(rightWallCenter));
            }
            // Corner trim - only add at ends where there's no open inset
            // Front corner (Z = L/2) - skip if front inset with right wall open
            if (!(params.frontInset > 0 && !params.frontInsetRightWall)) {
                groups.right.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, H, 0.08), trimMat.clone()).translateY(H/2).translateX(W/2 + wallOffset).translateZ(L/2 + wallOffset));
            }
            // Back corner (Z = -L/2) - skip if back inset with right wall open
            if (!(params.backInset > 0 && !params.backInsetRightWall)) {
                groups.right.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, H, 0.08), trimMat.clone()).translateY(H/2).translateX(W/2 + wallOffset).translateZ(-L/2 - wallOffset));
            }
            
            // Add girts only in the enclosed section
            if (rightWallLength > 0) {
                groups.right.add(new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.08, rightWallLength), girtMat.clone()).translateY(girtHeight1).translateX(W/2 + wallOffset - 0.04).translateZ(rightWallCenter));
                groups.right.add(new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.08, rightWallLength), girtMat.clone()).translateY(girtHeight2).translateX(W/2 + wallOffset - 0.04).translateZ(rightWallCenter));
            }
            
            scene.add(groups.right);
            groups.right.visible = params.showRight;
            
            // FRONT (with potential inset for utility style)
            groups.front = new THREE.Group();
            // frontInsetDist and backInsetDist already calculated above for sidewalls
            const frontWallZ = L/2 - frontInsetDist; // New wall Z position
            
            const frontTex = createPanelTexture(colors.wall);
            frontTex.repeat.set(W * 0.8, 1);
            const frontGeom = createWallWithHoles('front', true, W, H, rise);
            const frontWall = new THREE.Mesh(frontGeom, new THREE.MeshStandardMaterial({ map: frontTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
            frontWall.position.set(0, 0, frontWallZ + wallOffset);
            groups.front.add(frontWall);
            
            // Only add trim to front endwall if there's NO inset (full endwall at building edge)
            if (params.frontInset === 0) {
                // Base trim
                groups.front.add(new THREE.Mesh(new THREE.BoxGeometry(W + wallOffset*2 + 0.1, 0.15, 0.12), trimMat.clone()).translateY(0.075).translateZ(frontWallZ + wallOffset));
                // Corner trim
                groups.front.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, H, 0.08), trimMat.clone()).translateY(H/2).translateX(-W/2 - wallOffset).translateZ(frontWallZ + wallOffset));
                groups.front.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, H, 0.08), trimMat.clone()).translateY(H/2).translateX(W/2 + wallOffset).translateZ(frontWallZ + wallOffset));
                // Rake trim only when no gable overhang
                if (gableOH === 0) {
                    const rakeLen = rafterLen + 0.1;
                    const rakeGeom = new THREE.BoxGeometry(rakeLen, 0.12, 0.08);
                    const flr = new THREE.Mesh(rakeGeom, trimMat.clone());
                    flr.position.set(-W/4, H + rise/2, frontWallZ + wallOffset + 0.04);
                    flr.rotation.z = roofAngle;
                    groups.front.add(flr);
                    const frr = new THREE.Mesh(rakeGeom, trimMat.clone());
                    frr.position.set(W/4, H + rise/2, frontWallZ + wallOffset + 0.04);
                    frr.rotation.z = -roofAngle;
                    groups.front.add(frr);
                }
            }
            // When there IS an inset, no trim on the inset endwall - it's an interior partition
            
            // If there's a front inset, add partial sidewalls from the inset wall to the original front edge
            if (params.frontInset > 0) {
                const insetSidewallLen = frontInsetDist;
                const insetSidewallTex = createPanelTexture(colors.wall);
                insetSidewallTex.repeat.set(insetSidewallLen * 2, 1);
                insetSidewallTex.rotation = Math.PI / 2;
                insetSidewallTex.center.set(0.5, 0.5);
                
                // Left inset sidewall (only if enabled)
                if (params.frontInsetLeftWall) {
                    const leftInsetWall = new THREE.Mesh(
                        new THREE.PlaneGeometry(insetSidewallLen, H),
                        new THREE.MeshStandardMaterial({ map: insetSidewallTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide })
                    );
                    leftInsetWall.position.set(-W/2 - wallOffset, H/2, frontWallZ + insetSidewallLen/2);
                    leftInsetWall.rotation.y = Math.PI/2;
                    groups.front.add(leftInsetWall);
                    // No trim on inset sidewalls
                }
                
                // Right inset sidewall (only if enabled)
                if (params.frontInsetRightWall) {
                    const rightInsetTex = createPanelTexture(colors.wall);
                    rightInsetTex.repeat.set(insetSidewallLen * 2, 1);
                    rightInsetTex.rotation = Math.PI / 2;
                    rightInsetTex.center.set(0.5, 0.5);
                    const rightInsetWall = new THREE.Mesh(
                        new THREE.PlaneGeometry(insetSidewallLen, H),
                        new THREE.MeshStandardMaterial({ map: rightInsetTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide })
                    );
                    rightInsetWall.position.set(W/2 + wallOffset, H/2, frontWallZ + insetSidewallLen/2);
                    rightInsetWall.rotation.y = -Math.PI/2;
                    groups.front.add(rightInsetWall);
                    // No trim on inset sidewalls
                }
                
                // Add columns at the front edge (where the roof extends to)
                const colMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.4, metalness: 0.5 });
                const leftCol = new THREE.Mesh(new THREE.BoxGeometry(0.2, H, 0.2), colMat.clone());
                leftCol.position.set(-W/2, H/2, L/2);
                groups.front.add(leftCol);
                
                const rightCol = new THREE.Mesh(new THREE.BoxGeometry(0.2, H, 0.2), colMat.clone());
                rightCol.position.set(W/2, H/2, L/2);
                groups.front.add(rightCol);
                
                // Header beam at the front edge
                const headerMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.4, metalness: 0.5 });
                const header = new THREE.Mesh(new THREE.BoxGeometry(W, 0.25, 0.2), headerMat);
                header.position.set(0, H, L/2);
                groups.front.add(header);
            }
            scene.add(groups.front);
            groups.front.visible = params.showFront;
            
            // BACK (with potential inset for utility style)
            groups.back = new THREE.Group();
            // backInsetDist already calculated above for sidewalls
            const backWallZ = -L/2 + backInsetDist; // New wall Z position
            
            const backTex = createPanelTexture(colors.wall);
            backTex.repeat.set(W * 0.8, 1);
            const backGeom = createWallWithHoles('back', true, W, H, rise);
            const backWall = new THREE.Mesh(backGeom, new THREE.MeshStandardMaterial({ map: backTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
            backWall.position.set(0, 0, backWallZ - wallOffset);
            backWall.rotation.y = Math.PI;
            groups.back.add(backWall);
            
            // Only add trim to back endwall if there's NO inset (full endwall at building edge)
            if (params.backInset === 0) {
                // Base trim
                groups.back.add(new THREE.Mesh(new THREE.BoxGeometry(W + wallOffset*2 + 0.1, 0.15, 0.12), trimMat.clone()).translateY(0.075).translateZ(backWallZ - wallOffset));
                // Corner trim
                groups.back.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, H, 0.08), trimMat.clone()).translateY(H/2).translateX(-W/2 - wallOffset).translateZ(backWallZ - wallOffset));
                groups.back.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, H, 0.08), trimMat.clone()).translateY(H/2).translateX(W/2 + wallOffset).translateZ(backWallZ - wallOffset));
                // Rake trim only when no gable overhang
                if (gableOH === 0) {
                    const rakeLen = rafterLen + 0.1;
                    const rakeGeom = new THREE.BoxGeometry(rakeLen, 0.12, 0.08);
                    const blr = new THREE.Mesh(rakeGeom, trimMat.clone());
                    blr.position.set(-W/4, H + rise/2, backWallZ - wallOffset - 0.04);
                    blr.rotation.z = roofAngle;
                    groups.back.add(blr);
                    const brr = new THREE.Mesh(rakeGeom, trimMat.clone());
                    brr.position.set(W/4, H + rise/2, backWallZ - wallOffset - 0.04);
                    brr.rotation.z = -roofAngle;
                    groups.back.add(brr);
                }
            }
            // When there IS an inset, no trim on the inset endwall - it's an interior partition
            
            // If there's a back inset, add partial sidewalls from the inset wall to the original back edge
            if (params.backInset > 0) {
                const insetSidewallLen = backInsetDist;
                const insetSidewallTex = createPanelTexture(colors.wall);
                insetSidewallTex.repeat.set(insetSidewallLen * 2, 1);
                insetSidewallTex.rotation = Math.PI / 2;
                insetSidewallTex.center.set(0.5, 0.5);
                
                // Left inset sidewall (only if enabled)
                if (params.backInsetLeftWall) {
                    const leftInsetWall = new THREE.Mesh(
                        new THREE.PlaneGeometry(insetSidewallLen, H),
                        new THREE.MeshStandardMaterial({ map: insetSidewallTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide })
                    );
                    leftInsetWall.position.set(-W/2 - wallOffset, H/2, backWallZ - insetSidewallLen/2);
                    leftInsetWall.rotation.y = Math.PI/2;
                    groups.back.add(leftInsetWall);
                    // No trim on inset sidewalls
                }
                
                // Right inset sidewall (only if enabled)
                if (params.backInsetRightWall) {
                    const rightInsetTex = createPanelTexture(colors.wall);
                    rightInsetTex.repeat.set(insetSidewallLen * 2, 1);
                    rightInsetTex.rotation = Math.PI / 2;
                    rightInsetTex.center.set(0.5, 0.5);
                    const rightInsetWall = new THREE.Mesh(
                        new THREE.PlaneGeometry(insetSidewallLen, H),
                        new THREE.MeshStandardMaterial({ map: rightInsetTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide })
                    );
                    rightInsetWall.position.set(W/2 + wallOffset, H/2, backWallZ - insetSidewallLen/2);
                    rightInsetWall.rotation.y = -Math.PI/2;
                    groups.back.add(rightInsetWall);
                    // No trim on inset sidewalls
                }
                
                // Add columns at the back edge (where the roof extends to)
                const colMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.4, metalness: 0.5 });
                const leftCol = new THREE.Mesh(new THREE.BoxGeometry(0.2, H, 0.2), colMat.clone());
                leftCol.position.set(-W/2, H/2, -L/2);
                groups.back.add(leftCol);
                
                const rightCol = new THREE.Mesh(new THREE.BoxGeometry(0.2, H, 0.2), colMat.clone());
                rightCol.position.set(W/2, H/2, -L/2);
                groups.back.add(rightCol);
                
                // Header beam at the back edge
                const headerMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.4, metalness: 0.5 });
                const header = new THREE.Mesh(new THREE.BoxGeometry(W, 0.25, 0.2), headerMat);
                header.position.set(0, H, -L/2);
                groups.back.add(header);
            }
            scene.add(groups.back);
            groups.back.visible = params.showBack;
            
            // ========== WAINSCOT ==========
            groups.wainscot = new THREE.Group();
            if (params.showWainscot) {
                const wainscotH = 3 * S; // 3 feet
                const wainscotTex = createPanelTexture(colors.wainscot);
                const wainscotMat = new THREE.MeshStandardMaterial({ map: wainscotTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide });
                const wainscotTrimMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.3, metalness: 0.5 });
                
                // Left wall wainscot
                if (params.showLeft) {
                    const lwTex = wainscotTex.clone();
                    lwTex.repeat.set(L * 0.8, 1);
                    const lwGeom = new THREE.PlaneGeometry(L, wainscotH);
                    const lw = new THREE.Mesh(lwGeom, new THREE.MeshStandardMaterial({ map: lwTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    lw.position.set(-W/2 - wallOffset - 0.01, wainscotH/2, 0);
                    lw.rotation.y = -Math.PI/2;
                    groups.wainscot.add(lw);
                    // Wainscot trim (horizontal line at top of wainscot)
                    const lwTrim = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, L + 0.1), wainscotTrimMat.clone());
                    lwTrim.position.set(-W/2 - wallOffset - 0.04, wainscotH + 0.03, 0);
                    groups.wainscot.add(lwTrim);
                }
                
                // Right wall wainscot
                if (params.showRight) {
                    const rwTex = wainscotTex.clone();
                    rwTex.repeat.set(L * 0.8, 1);
                    const rwGeom = new THREE.PlaneGeometry(L, wainscotH);
                    const rw = new THREE.Mesh(rwGeom, new THREE.MeshStandardMaterial({ map: rwTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    rw.position.set(W/2 + wallOffset + 0.01, wainscotH/2, 0);
                    rw.rotation.y = Math.PI/2;
                    groups.wainscot.add(rw);
                    // Wainscot trim
                    const rwTrim = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, L + 0.1), wainscotTrimMat.clone());
                    rwTrim.position.set(W/2 + wallOffset + 0.04, wainscotH + 0.03, 0);
                    groups.wainscot.add(rwTrim);
                }
                
                // Front wall wainscot
                if (params.showFront) {
                    const fwTex = wainscotTex.clone();
                    fwTex.repeat.set(W * 0.8, 1);
                    const fwGeom = new THREE.PlaneGeometry(W + wallOffset*2, wainscotH);
                    const fw = new THREE.Mesh(fwGeom, new THREE.MeshStandardMaterial({ map: fwTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    fw.position.set(0, wainscotH/2, L/2 + wallOffset + 0.01);
                    groups.wainscot.add(fw);
                    // Wainscot trim
                    const fwTrim = new THREE.Mesh(new THREE.BoxGeometry(W + wallOffset*2 + 0.1, 0.06, 0.08), wainscotTrimMat.clone());
                    fwTrim.position.set(0, wainscotH + 0.03, L/2 + wallOffset + 0.04);
                    groups.wainscot.add(fwTrim);
                }
                
                // Back wall wainscot
                if (params.showBack) {
                    const bwTex = wainscotTex.clone();
                    bwTex.repeat.set(W * 0.8, 1);
                    const bwGeom = new THREE.PlaneGeometry(W + wallOffset*2, wainscotH);
                    const bw = new THREE.Mesh(bwGeom, new THREE.MeshStandardMaterial({ map: bwTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    bw.position.set(0, wainscotH/2, -L/2 - wallOffset - 0.01);
                    bw.rotation.y = Math.PI;
                    groups.wainscot.add(bw);
                    // Wainscot trim
                    const bwTrim = new THREE.Mesh(new THREE.BoxGeometry(W + wallOffset*2 + 0.1, 0.06, 0.08), wainscotTrimMat.clone());
                    bwTrim.position.set(0, wainscotH + 0.03, -L/2 - wallOffset - 0.04);
                    groups.wainscot.add(bwTrim);
                }
                
                // LEFT LEAN-TO WAINSCOT
                if (leanTos.left.enabled) {
                    const ltW = leanTos.left.width * S;
                    const ltL = leanTos.left.length * S;
                    const ltH = leanTos.left.height * S;
                    const ltOffset = leanTos.left.offset * S;
                    const maxOff = (L - ltL) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    const wH = Math.min(wainscotH, ltH);
                    const ltFrontZ = ltL/2 + clampedOff;
                    const ltBackZ = -ltL/2 + clampedOff;
                    
                    // Sidewall wainscot
                    if (leanTos.left.showSidewall) {
                        const ltSwTex = wainscotTex.clone();
                        ltSwTex.repeat.set(ltL * 0.8, 1);
                        const ltSwGeom = new THREE.PlaneGeometry(ltL, wH);
                        const ltSw = new THREE.Mesh(ltSwGeom, new THREE.MeshStandardMaterial({ map: ltSwTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        ltSw.position.set(-W/2 - ltW - wallOffset - 0.01, wH/2, clampedOff);
                        ltSw.rotation.y = Math.PI/2;
                        groups.wainscot.add(ltSw);
                        const ltSwTrim = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, ltL + 0.1), wainscotTrimMat.clone());
                        ltSwTrim.position.set(-W/2 - ltW - wallOffset - 0.04, wH + 0.03, clampedOff);
                        groups.wainscot.add(ltSwTrim);
                    }
                    
                    // Front endwall wainscot
                    if (leanTos.left.showEndwalls) {
                        const ltEwTex = wainscotTex.clone();
                        ltEwTex.repeat.set(ltW * 0.8, 1);
                        const ltEwGeom = new THREE.PlaneGeometry(ltW, wH);
                        const ltEwF = new THREE.Mesh(ltEwGeom, new THREE.MeshStandardMaterial({ map: ltEwTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        ltEwF.position.set(-W/2 - ltW/2, wH/2, ltFrontZ + wallOffset + 0.02);
                        groups.wainscot.add(ltEwF);
                        const ltEwFTrim = new THREE.Mesh(new THREE.BoxGeometry(ltW + wallOffset*2 + 0.1, 0.06, 0.08), wainscotTrimMat.clone());
                        ltEwFTrim.position.set(-W/2 - ltW/2, wH + 0.03, ltFrontZ + wallOffset + 0.05);
                        groups.wainscot.add(ltEwFTrim);
                        
                        // Back endwall wainscot
                        const ltEwB = new THREE.Mesh(ltEwGeom.clone(), new THREE.MeshStandardMaterial({ map: ltEwTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        ltEwB.position.set(-W/2 - ltW/2, wH/2, ltBackZ - wallOffset - 0.02);
                        ltEwB.rotation.y = Math.PI;
                        groups.wainscot.add(ltEwB);
                        const ltEwBTrim = new THREE.Mesh(new THREE.BoxGeometry(ltW + wallOffset*2 + 0.1, 0.06, 0.08), wainscotTrimMat.clone());
                        ltEwBTrim.position.set(-W/2 - ltW/2, wH + 0.03, ltBackZ - wallOffset - 0.05);
                        groups.wainscot.add(ltEwBTrim);
                    }
                }
                
                // RIGHT LEAN-TO WAINSCOT
                if (leanTos.right.enabled) {
                    const ltW = leanTos.right.width * S;
                    const ltL = leanTos.right.length * S;
                    const ltH = leanTos.right.height * S;
                    const ltOffset = leanTos.right.offset * S;
                    const maxOff = (L - ltL) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    const wH = Math.min(wainscotH, ltH);
                    const ltFrontZ = ltL/2 + clampedOff;
                    const ltBackZ = -ltL/2 + clampedOff;
                    
                    // Sidewall wainscot
                    if (leanTos.right.showSidewall) {
                        const ltSwTex = wainscotTex.clone();
                        ltSwTex.repeat.set(ltL * 0.8, 1);
                        const ltSwGeom = new THREE.PlaneGeometry(ltL, wH);
                        const ltSw = new THREE.Mesh(ltSwGeom, new THREE.MeshStandardMaterial({ map: ltSwTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        ltSw.position.set(W/2 + ltW + wallOffset + 0.01, wH/2, clampedOff);
                        ltSw.rotation.y = Math.PI/2;
                        groups.wainscot.add(ltSw);
                        const ltSwTrim = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, ltL + 0.1), wainscotTrimMat.clone());
                        ltSwTrim.position.set(W/2 + ltW + wallOffset + 0.04, wH + 0.03, clampedOff);
                        groups.wainscot.add(ltSwTrim);
                    }
                    
                    // Front endwall wainscot
                    if (leanTos.right.showEndwalls) {
                        const ltEwTex = wainscotTex.clone();
                        ltEwTex.repeat.set(ltW * 0.8, 1);
                        const ltEwGeom = new THREE.PlaneGeometry(ltW, wH);
                        const ltEwF = new THREE.Mesh(ltEwGeom, new THREE.MeshStandardMaterial({ map: ltEwTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        ltEwF.position.set(W/2 + ltW/2, wH/2, ltFrontZ + wallOffset + 0.02);
                        groups.wainscot.add(ltEwF);
                        const ltEwFTrim = new THREE.Mesh(new THREE.BoxGeometry(ltW + wallOffset*2 + 0.1, 0.06, 0.08), wainscotTrimMat.clone());
                        ltEwFTrim.position.set(W/2 + ltW/2, wH + 0.03, ltFrontZ + wallOffset + 0.05);
                        groups.wainscot.add(ltEwFTrim);
                        
                        // Back endwall wainscot
                        const ltEwB = new THREE.Mesh(ltEwGeom.clone(), new THREE.MeshStandardMaterial({ map: ltEwTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        ltEwB.position.set(W/2 + ltW/2, wH/2, ltBackZ - wallOffset - 0.02);
                        ltEwB.rotation.y = Math.PI;
                        groups.wainscot.add(ltEwB);
                        const ltEwBTrim = new THREE.Mesh(new THREE.BoxGeometry(ltW + wallOffset*2 + 0.1, 0.06, 0.08), wainscotTrimMat.clone());
                        ltEwBTrim.position.set(W/2 + ltW/2, wH + 0.03, ltBackZ - wallOffset - 0.05);
                        groups.wainscot.add(ltEwBTrim);
                    }
                }
                
                // FRONT LEAN-TO WAINSCOT
                if (leanTos.front.enabled) {
                    const ltD = leanTos.front.depth * S;
                    const ltW = leanTos.front.width * S;
                    const ltH = leanTos.front.height * S;
                    const ltOffset = leanTos.front.offset * S;
                    const maxOff = (W - ltW) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    // Match the actual wall calculations
                    const ltLeftX = -ltW/2 + clampedOff;
                    const ltRightX = ltW/2 + clampedOff;
                    const actualWidth = ltRightX - ltLeftX;
                    const fwCenterX = (ltLeftX + ltRightX) / 2;
                    const wH = Math.min(wainscotH, ltH);
                    
                    // Front wall wainscot - position matches wall at L/2 + ltD
                    if (leanTos.front.showSidewall) {
                        const ltFwTex = wainscotTex.clone();
                        ltFwTex.repeat.set(actualWidth * 0.8, 1);
                        const ltFwGeom = new THREE.PlaneGeometry(actualWidth, wH);
                        const ltFw = new THREE.Mesh(ltFwGeom, new THREE.MeshStandardMaterial({ map: ltFwTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        ltFw.position.set(fwCenterX, wH/2, L/2 + ltD + 0.02);
                        groups.wainscot.add(ltFw);
                        const ltFwTrim = new THREE.Mesh(new THREE.BoxGeometry(actualWidth + 0.1, 0.06, 0.08), wainscotTrimMat.clone());
                        ltFwTrim.position.set(fwCenterX, wH + 0.03, L/2 + ltD + 0.05);
                        groups.wainscot.add(ltFwTrim);
                    }
                    
                    // Left and Right endwall wainscot
                    if (leanTos.front.showEndwalls) {
                        const ltEwTex = wainscotTex.clone();
                        ltEwTex.repeat.set(ltD * 0.8, 1);
                        const ltEwGeom = new THREE.PlaneGeometry(ltD, wH);
                        
                        // Left endwall
                        const ltEwL = new THREE.Mesh(ltEwGeom, new THREE.MeshStandardMaterial({ map: ltEwTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        ltEwL.position.set(ltLeftX - wallOffset - 0.02, wH/2, L/2 + ltD/2);
                        ltEwL.rotation.y = -Math.PI/2;
                        groups.wainscot.add(ltEwL);
                        const ltEwLTrim = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, ltD + 0.1), wainscotTrimMat.clone());
                        ltEwLTrim.position.set(ltLeftX - wallOffset - 0.05, wH + 0.03, L/2 + ltD/2);
                        groups.wainscot.add(ltEwLTrim);
                        
                        // Right endwall
                        const ltEwR = new THREE.Mesh(ltEwGeom.clone(), new THREE.MeshStandardMaterial({ map: ltEwTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        ltEwR.position.set(ltRightX + wallOffset + 0.02, wH/2, L/2 + ltD/2);
                        ltEwR.rotation.y = Math.PI/2;
                        groups.wainscot.add(ltEwR);
                        const ltEwRTrim = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, ltD + 0.1), wainscotTrimMat.clone());
                        ltEwRTrim.position.set(ltRightX + wallOffset + 0.05, wH + 0.03, L/2 + ltD/2);
                        groups.wainscot.add(ltEwRTrim);
                    }
                }
                
                // BACK LEAN-TO WAINSCOT
                if (leanTos.back.enabled) {
                    const ltD = leanTos.back.depth * S;
                    const ltW = leanTos.back.width * S;
                    const ltH = leanTos.back.height * S;
                    const ltOffset = leanTos.back.offset * S;
                    const maxOff = (W - ltW) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    // Match the actual wall calculations
                    const ltLeftX = -ltW/2 + clampedOff;
                    const ltRightX = ltW/2 + clampedOff;
                    const actualWidth = ltRightX - ltLeftX;
                    const bwCenterX = (ltLeftX + ltRightX) / 2;
                    const wH = Math.min(wainscotH, ltH);
                    
                    // Back wall wainscot - position matches wall at -L/2 - ltD
                    if (leanTos.back.showSidewall) {
                        const ltBwTex = wainscotTex.clone();
                        ltBwTex.repeat.set(actualWidth * 0.8, 1);
                        const ltBwGeom = new THREE.PlaneGeometry(actualWidth, wH);
                        const ltBw = new THREE.Mesh(ltBwGeom, new THREE.MeshStandardMaterial({ map: ltBwTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        ltBw.position.set(bwCenterX, wH/2, -L/2 - ltD - 0.02);
                        ltBw.rotation.y = Math.PI;
                        groups.wainscot.add(ltBw);
                        const ltBwTrim = new THREE.Mesh(new THREE.BoxGeometry(actualWidth + 0.1, 0.06, 0.08), wainscotTrimMat.clone());
                        ltBwTrim.position.set(bwCenterX, wH + 0.03, -L/2 - ltD - 0.05);
                        groups.wainscot.add(ltBwTrim);
                    }
                    
                    // Left and Right endwall wainscot
                    if (leanTos.back.showEndwalls) {
                        const ltEwTex = wainscotTex.clone();
                        ltEwTex.repeat.set(ltD * 0.8, 1);
                        const ltEwGeom = new THREE.PlaneGeometry(ltD, wH);
                        
                        // Left endwall
                        const ltEwL = new THREE.Mesh(ltEwGeom, new THREE.MeshStandardMaterial({ map: ltEwTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        ltEwL.position.set(ltLeftX - wallOffset - 0.02, wH/2, -L/2 - ltD/2);
                        ltEwL.rotation.y = -Math.PI/2;
                        groups.wainscot.add(ltEwL);
                        const ltEwLTrim = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, ltD + 0.1), wainscotTrimMat.clone());
                        ltEwLTrim.position.set(ltLeftX - wallOffset - 0.05, wH + 0.03, -L/2 - ltD/2);
                        groups.wainscot.add(ltEwLTrim);
                        
                        // Right endwall
                        const ltEwR = new THREE.Mesh(ltEwGeom.clone(), new THREE.MeshStandardMaterial({ map: ltEwTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        ltEwR.position.set(ltRightX + wallOffset + 0.02, wH/2, -L/2 - ltD/2);
                        ltEwR.rotation.y = Math.PI/2;
                        groups.wainscot.add(ltEwR);
                        const ltEwRTrim = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, ltD + 0.1), wainscotTrimMat.clone());
                        ltEwRTrim.position.set(ltRightX + wallOffset + 0.05, wH + 0.03, -L/2 - ltD/2);
                        groups.wainscot.add(ltEwRTrim);
                    }
                }
            }
            scene.add(groups.wainscot);
            
            // ========== LEAN-TOS ==========
            buildLeanTos(W, L, H, rise, trimMat, wallOffset);
            
            rebuildAccessories();
        }
        
        function buildLeanTos(W, L, H, mainRise, trimMat, wallOffset) {
            const S = 1/3;
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x8B3A3A, roughness: 0.5, metalness: 0.4 });
            const purlinMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.4, metalness: 0.5 });
            const frameInset = 0.2; // Keep framing well inside walls
            
            // Clear existing lean-to groups and wrap corners
            ['leantoLeft', 'leantoRight', 'leantoFront', 'leantoBack', 'wrapLeftFront', 'wrapRightFront', 'wrapLeftBack', 'wrapRightBack'].forEach(key => {
                if (groups[key]) {
                    scene.remove(groups[key]);
                    groups[key].traverse(c => {
                        if (c.geometry) c.geometry.dispose();
                        if (c.material) c.material.dispose();
                    });
                    groups[key] = null;
                }
            });
            
            // LEFT LEAN-TO
            if (leanTos.left.enabled) {
                groups.leantoLeft = new THREE.Group();
                const ltW = leanTos.left.width * S;
                let ltL = leanTos.left.length * S;  // Allow full length
                const ltOffset = leanTos.left.offset * S;
                const ltH = leanTos.left.height * S;
                const ltPitch = leanTos.left.pitch;
                const ltRise = ltW * (ltPitch / 12);
                const highPoint = ltH + ltRise; // Height at main building connection
                
                // Overhang for this lean-to (inherit from main if enabled)
                const ltEaveOH = leanTos.left.showOverhang ? params.eaveOverhang * S : 0;
                const ltGableOH = leanTos.left.showOverhang ? params.gableOverhang * S : 0;
                const ltEaveOHdrop = ltEaveOH * (ltPitch / 12);
                
                // Position with offset (no extension - wrap corners handle the corner geometry)
                const maxOffset = (L - ltL) / 2;
                const clampedOffset = Math.max(-maxOffset, Math.min(maxOffset, ltOffset));
                const ltBackZ = -ltL/2 + clampedOffset;  // Back end (toward -Z)
                const ltFrontZ = ltL/2 + clampedOffset;   // Front end (toward +Z)
                const actualLength = ltFrontZ - ltBackZ;
                
                const numLtBays = Math.max(1, Math.floor(ltL / S / params.baySpacing));
                const ltBaySpacing = actualLength / numLtBays;
                
                // Gable overhang - don't extend into wrap corner areas
                const frontGableOH = (wrapCorners.leftFront && leanTos.front.enabled) ? 0 : ltGableOH;
                const backGableOH = (wrapCorners.leftBack && leanTos.back.enabled) ? 0 : ltGableOH;
                
                // Roof with overhang - slopes from main building (high) down to outer edge (low)
                const ltRoofVerts = new Float32Array([
                    -W/2 - ltW - ltEaveOH, ltH - ltEaveOHdrop, ltBackZ - backGableOH,
                    -W/2, highPoint, ltBackZ - backGableOH,
                    -W/2 - ltW - ltEaveOH, ltH - ltEaveOHdrop, ltFrontZ + frontGableOH,
                    -W/2, highPoint, ltBackZ - backGableOH,
                    -W/2, highPoint, ltFrontZ + frontGableOH,
                    -W/2 - ltW - ltEaveOH, ltH - ltEaveOHdrop, ltFrontZ + frontGableOH
                ]);
                const ltRoofUVs = new Float32Array([0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1]);
                const ltRoofGeom = new THREE.BufferGeometry();
                ltRoofGeom.setAttribute('position', new THREE.BufferAttribute(ltRoofVerts, 3));
                ltRoofGeom.setAttribute('uv', new THREE.BufferAttribute(ltRoofUVs, 2));
                ltRoofGeom.computeVertexNormals();
                const ltRoofTex = createRoofTexture(colors.roof);
                ltRoofTex.repeat.set(1, (actualLength + frontGableOH + backGableOH) / 3);
                const ltRoof = new THREE.Mesh(ltRoofGeom, new THREE.MeshStandardMaterial({ map: ltRoofTex, roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide }));
                groups.leantoLeft.add(ltRoof);
                
                // Eave trim at outer edge of overhang
                // Stop at wrap corner boundaries to avoid visible seams
                if (ltEaveOH > 0) {
                    let trimFrontZ = ltFrontZ;
                    let trimBackZ = ltBackZ;
                    if (wrapCorners.leftFront && leanTos.front.enabled) {
                        trimFrontZ = L/2;  // Stop at main building front edge
                    }
                    if (wrapCorners.leftBack && leanTos.back.enabled) {
                        trimBackZ = -L/2;  // Stop at main building back edge
                    }
                    const trimLength = trimFrontZ - trimBackZ;
                    const ltEaveTrim = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, trimLength), trimMat.clone());
                    ltEaveTrim.position.set(-W/2 - ltW - ltEaveOH - 0.04, ltH - ltEaveOHdrop, (trimFrontZ + trimBackZ) / 2);
                    groups.leantoLeft.add(ltEaveTrim);
                    
                    // Soffit (underside of eave overhang) - only along the lean-to length (not corner)
                    // Calculate trim bounds - exclude wrap corner areas for soffit only
                    let soffitFrontZ = ltFrontZ;
                    let soffitBackZ = ltBackZ;
                    if (wrapCorners.leftFront && leanTos.front.enabled) {
                        soffitFrontZ = L/2;  // Stop at main building front edge
                    }
                    if (wrapCorners.leftBack && leanTos.back.enabled) {
                        soffitBackZ = -L/2;  // Stop at main building back edge
                    }
                    const soffitLength = soffitFrontZ - soffitBackZ;
                    
                    if (soffitLength > 0.1) {
                        const soffitGeom = new THREE.PlaneGeometry(ltEaveOH, soffitLength);
                        const soffit = new THREE.Mesh(soffitGeom, new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide }));
                        soffit.position.set(-W/2 - ltW - ltEaveOH/2, ltH - ltEaveOHdrop + 0.01, (soffitFrontZ + soffitBackZ) / 2);
                        soffit.rotation.x = Math.PI/2;
                        groups.leantoLeft.add(soffit);
                    }
                }
                
                // Gable rake trim at overhang edge (front and back)
                if (ltGableOH > 0) {
                    const rakeLen = Math.sqrt((ltW + ltEaveOH) * (ltW + ltEaveOH) + (ltRise + ltEaveOHdrop) * (ltRise + ltEaveOHdrop));
                    const rakeAngle = Math.atan2(ltRise + ltEaveOHdrop, ltW + ltEaveOH);
                    
                    // Front gable rake - skip if wrapped with front lean-to
                    if (!wrapCorners.leftFront || !leanTos.front.enabled) {
                        const rakeFrontOH = new THREE.Mesh(new THREE.BoxGeometry(rakeLen, 0.12, 0.08), trimMat.clone());
                        rakeFrontOH.position.set(-W/2 - (ltW + ltEaveOH)/2, ltH + ltRise/2 - ltEaveOHdrop/2, ltFrontZ + ltGableOH + 0.04);
                        rakeFrontOH.rotation.z = rakeAngle;
                        groups.leantoLeft.add(rakeFrontOH);
                    }
                    
                    // Back gable rake - skip if wrapped with back lean-to
                    if (!wrapCorners.leftBack || !leanTos.back.enabled) {
                        const rakeBackOH = new THREE.Mesh(new THREE.BoxGeometry(rakeLen, 0.12, 0.08), trimMat.clone());
                        rakeBackOH.position.set(-W/2 - (ltW + ltEaveOH)/2, ltH + ltRise/2 - ltEaveOHdrop/2, ltBackZ - ltGableOH - 0.04);
                        rakeBackOH.rotation.z = rakeAngle;
                        groups.leantoLeft.add(rakeBackOH);
                    }
                    
                    // Front and back gable soffits - angled to follow roof pitch
                    const gableSoffitMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide });
                    const soffitGap = 0.02; // Small gap to prevent z-fighting
                    
                    // Front gable soffit - skip if wrapped with front lean-to
                    if (!wrapCorners.leftFront || !leanTos.front.enabled) {
                        const frontSoffitVerts = new Float32Array([
                            // Triangle 1
                            -W/2, ltH + ltRise - soffitGap, ltFrontZ,  // Inner top (at main wall)
                            -W/2, ltH + ltRise - soffitGap, ltFrontZ + ltGableOH,  // Inner top (outside)
                            -W/2 - ltW - ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltFrontZ,  // Outer eave (inside)
                            // Triangle 2
                            -W/2 - ltW - ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltFrontZ,  // Outer eave (inside)
                            -W/2, ltH + ltRise - soffitGap, ltFrontZ + ltGableOH,  // Inner top (outside)
                            -W/2 - ltW - ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltFrontZ + ltGableOH  // Outer eave (outside)
                        ]);
                        const frontSoffitGeom = new THREE.BufferGeometry();
                        frontSoffitGeom.setAttribute('position', new THREE.BufferAttribute(frontSoffitVerts, 3));
                        frontSoffitGeom.computeVertexNormals();
                        groups.leantoLeft.add(new THREE.Mesh(frontSoffitGeom, gableSoffitMat.clone()));
                        
                        // Front corner soffit
                        const frontCornerSoffitVerts = new Float32Array([
                            -W/2 - ltW, ltH - ltEaveOHdrop - soffitGap, ltFrontZ,  // Inner corner
                            -W/2 - ltW - ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltFrontZ,  // Eave edge
                            -W/2 - ltW - ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltFrontZ + ltGableOH  // Outer corner
                        ]);
                        const frontCornerSoffitGeom = new THREE.BufferGeometry();
                        frontCornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(frontCornerSoffitVerts, 3));
                        frontCornerSoffitGeom.computeVertexNormals();
                        groups.leantoLeft.add(new THREE.Mesh(frontCornerSoffitGeom, gableSoffitMat.clone()));
                    }
                    
                    // Back gable soffit - skip if wrapped with back lean-to
                    if (!wrapCorners.leftBack || !leanTos.back.enabled) {
                        const backSoffitVerts = new Float32Array([
                            // Triangle 1
                            -W/2, ltH + ltRise - soffitGap, ltBackZ,  // Inner top (at main wall)
                            -W/2 - ltW - ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltBackZ,  // Outer eave (inside)
                            -W/2, ltH + ltRise - soffitGap, ltBackZ - ltGableOH,  // Inner top (outside)
                            // Triangle 2
                            -W/2, ltH + ltRise - soffitGap, ltBackZ - ltGableOH,  // Inner top (outside)
                            -W/2 - ltW - ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltBackZ,  // Outer eave (inside)
                            -W/2 - ltW - ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltBackZ - ltGableOH  // Outer eave (outside)
                        ]);
                        const backSoffitGeom = new THREE.BufferGeometry();
                        backSoffitGeom.setAttribute('position', new THREE.BufferAttribute(backSoffitVerts, 3));
                        backSoffitGeom.computeVertexNormals();
                        groups.leantoLeft.add(new THREE.Mesh(backSoffitGeom, gableSoffitMat.clone()));
                        
                        // Back corner soffit
                        const backCornerSoffitVerts = new Float32Array([
                            -W/2 - ltW, ltH - ltEaveOHdrop - soffitGap, ltBackZ,  // Inner corner
                            -W/2 - ltW - ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltBackZ - ltGableOH,  // Outer corner
                            -W/2 - ltW - ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltBackZ  // Eave edge
                        ]);
                        const backCornerSoffitGeom = new THREE.BufferGeometry();
                        backCornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(backCornerSoffitVerts, 3));
                        backCornerSoffitGeom.computeVertexNormals();
                        groups.leantoLeft.add(new THREE.Mesh(backCornerSoffitGeom, gableSoffitMat.clone()));
                    }
                }
                
                // Outer Sidewall
                if (leanTos.left.showSidewall) {
                    const swTex = createPanelTexture(colors.wall);
                    swTex.repeat.set(actualLength * 0.8, 1);
                    const swCenterZ = (ltFrontZ + ltBackZ) / 2;
                    
                    // Check for frameouts on this wall
                    const swFrameouts = accessories.filter(a => a.wall === 'lt-left-side' && a.type === 'frameout');
                    let swGeom;
                    if (swFrameouts.length > 0) {
                        const shape = new THREE.Shape();
                        shape.moveTo(-actualLength/2, -ltH/2);
                        shape.lineTo(actualLength/2, -ltH/2);
                        shape.lineTo(actualLength/2, ltH/2);
                        shape.lineTo(-actualLength/2, ltH/2);
                        shape.closePath();
                        swFrameouts.forEach(acc => {
                            const fw = acc.width * S;
                            const fh = acc.height * S;
                            // Wall rotated by PI/2: local +X → world +Z
                            // Accessory posX maps to world Z offset from swCenterZ
                            const fx = acc.posX || 0;
                            // Height: wall centered, so fy = fh/2 + posY - ltH/2
                            const fy = fh/2 + (acc.posY || 0) - ltH/2;
                            const hole = new THREE.Path();
                            hole.moveTo(fx - fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy + fh/2);
                            hole.lineTo(fx - fw/2, fy + fh/2);
                            hole.closePath();
                            shape.holes.push(hole);
                        });
                        swGeom = new THREE.ShapeGeometry(shape);
                        // Generate proper UVs for the shape geometry
                        const positions = swGeom.attributes.position.array;
                        const uvs = new Float32Array((positions.length / 3) * 2);
                        for (let i = 0; i < positions.length / 3; i++) {
                            const x = positions[i * 3];
                            const y = positions[i * 3 + 1];
                            uvs[i * 2] = (x + actualLength/2) / actualLength;
                            uvs[i * 2 + 1] = (y + ltH/2) / ltH;
                        }
                        swGeom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
                    } else {
                        swGeom = new THREE.PlaneGeometry(actualLength, ltH);
                    }
                    
                    const sw = new THREE.Mesh(swGeom, new THREE.MeshStandardMaterial({ map: swTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    sw.position.set(-W/2 - ltW - wallOffset, ltH/2, swCenterZ);
                    sw.rotation.y = Math.PI/2;
                    groups.leantoLeft.add(sw);
                    // Trim OUTSIDE the wall (further negative X)
                    const swTrimX = -W/2 - ltW - wallOffset - 0.06;
                    groups.leantoLeft.add(new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, actualLength + 0.1), trimMat.clone()).translateY(0.075).translateX(swTrimX).translateZ(swCenterZ));
                    // Top trim only when no eave overhang
                    if (ltEaveOH === 0) {
                        groups.leantoLeft.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, actualLength + 0.1), trimMat.clone()).translateY(ltH + 0.03).translateX(swTrimX).translateZ(swCenterZ));
                    }
                    // Corner trims - hide if wrapped at that corner
                    if (!wrapCorners.leftFront || !leanTos.front.enabled) {
                        groups.leantoLeft.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(swTrimX).translateZ(ltFrontZ + wallOffset + 0.04));
                    }
                    if (!wrapCorners.leftBack || !leanTos.back.enabled) {
                        groups.leantoLeft.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(swTrimX).translateZ(ltBackZ - wallOffset - 0.04));
                    }
                }
                
                // Endwalls
                if (leanTos.left.showEndwalls) {
                    const ewTex = createPanelTexture(colors.wall);
                    ewTex.repeat.set(ltW * 0.8, 1);
                    
                    // FRONT endwall (at ltFrontZ, the +Z end) - skip if wrapped with front
                    if (!wrapCorners.leftFront || !leanTos.front.enabled) {
                        const ewFrontGeom = new THREE.BufferGeometry();
                        const fVerts = new Float32Array([
                            -W/2 - ltW - wallOffset, 0, ltFrontZ + wallOffset,
                            -W/2 + wallOffset, 0, ltFrontZ + wallOffset,
                            -W/2 + wallOffset, highPoint, ltFrontZ + wallOffset,
                            -W/2 - ltW - wallOffset, 0, ltFrontZ + wallOffset,
                            -W/2 + wallOffset, highPoint, ltFrontZ + wallOffset,
                            -W/2 - ltW - wallOffset, ltH, ltFrontZ + wallOffset
                        ]);
                        const fUVs = new Float32Array([
                            0, 0,
                            1, 0,
                            1, 1,
                            0, 0,
                            1, 1,
                            0, 1
                        ]);
                        ewFrontGeom.setAttribute('position', new THREE.BufferAttribute(fVerts, 3));
                        ewFrontGeom.setAttribute('uv', new THREE.BufferAttribute(fUVs, 2));
                        ewFrontGeom.computeVertexNormals();
                        const ewFront = new THREE.Mesh(ewFrontGeom, new THREE.MeshStandardMaterial({ map: ewTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        groups.leantoLeft.add(ewFront);
                    }
                    
                    // BACK endwall (at ltBackZ, the -Z end) - skip if wrapped with back
                    if (!wrapCorners.leftBack || !leanTos.back.enabled) {
                        const ewBackGeom = new THREE.BufferGeometry();
                        const bVerts = new Float32Array([
                            -W/2 + wallOffset, 0, ltBackZ - wallOffset,
                            -W/2 - ltW - wallOffset, 0, ltBackZ - wallOffset,
                            -W/2 - ltW - wallOffset, ltH, ltBackZ - wallOffset,
                            -W/2 + wallOffset, 0, ltBackZ - wallOffset,
                            -W/2 - ltW - wallOffset, ltH, ltBackZ - wallOffset,
                            -W/2 + wallOffset, highPoint, ltBackZ - wallOffset
                        ]);
                        const bUVs = new Float32Array([
                            0, 0,
                            1, 0,
                            1, 1,
                            0, 0,
                            1, 1,
                            0, 1
                        ]);
                        ewBackGeom.setAttribute('position', new THREE.BufferAttribute(bVerts, 3));
                        ewBackGeom.setAttribute('uv', new THREE.BufferAttribute(bUVs, 2));
                        ewBackGeom.computeVertexNormals();
                        const ewBack = new THREE.Mesh(ewBackGeom, new THREE.MeshStandardMaterial({ map: ewTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        groups.leantoLeft.add(ewBack);
                    }
                    
                    // Trim OUTSIDE endwalls
                    const frontTrimZ = ltFrontZ + wallOffset + 0.06;
                    const backTrimZ = ltBackZ - wallOffset - 0.06;
                    
                    // Front endwall trim - skip if wrapped with front
                    if (!wrapCorners.leftFront || !leanTos.front.enabled) {
                        // Base trim on front endwall
                        groups.leantoLeft.add(new THREE.Mesh(new THREE.BoxGeometry(ltW + wallOffset*2 + 0.1, 0.15, 0.12), trimMat.clone()).translateY(0.075).translateX(-W/2 - ltW/2).translateZ(frontTrimZ));
                        
                        // Rake trim on front sloped edge - only when no gable overhang
                        if (ltGableOH === 0) {
                            const rakeLen = Math.sqrt(ltW * ltW + ltRise * ltRise) + 0.1;
                            const rakeAngle = Math.atan2(ltRise, ltW);
                            const rakeFront = new THREE.Mesh(new THREE.BoxGeometry(rakeLen, 0.12, 0.08), trimMat.clone());
                            rakeFront.position.set(-W/2 - ltW/2, ltH + ltRise/2, frontTrimZ);
                            rakeFront.rotation.z = rakeAngle;
                            groups.leantoLeft.add(rakeFront);
                        }
                        
                        // Corner trim at outer sidewall
                        groups.leantoLeft.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(-W/2 - ltW - wallOffset - 0.04).translateZ(frontTrimZ));
                        
                        // Corner trim at main building connection
                        groups.leantoLeft.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, highPoint, 0.08), trimMat.clone()).translateY(highPoint/2).translateX(-W/2 + wallOffset).translateZ(frontTrimZ));
                    }
                    
                    // Back endwall trim - skip if wrapped with back
                    if (!wrapCorners.leftBack || !leanTos.back.enabled) {
                        // Base trim on back endwall
                        groups.leantoLeft.add(new THREE.Mesh(new THREE.BoxGeometry(ltW + wallOffset*2 + 0.1, 0.15, 0.12), trimMat.clone()).translateY(0.075).translateX(-W/2 - ltW/2).translateZ(backTrimZ));
                        
                        // Rake trim on back sloped edge - only when no gable overhang
                        if (ltGableOH === 0) {
                            const rakeLen = Math.sqrt(ltW * ltW + ltRise * ltRise) + 0.1;
                            const rakeAngle = Math.atan2(ltRise, ltW);
                            const rakeBack = new THREE.Mesh(new THREE.BoxGeometry(rakeLen, 0.12, 0.08), trimMat.clone());
                            rakeBack.position.set(-W/2 - ltW/2, ltH + ltRise/2, backTrimZ);
                            rakeBack.rotation.z = rakeAngle;
                            groups.leantoLeft.add(rakeBack);
                        }
                        
                        // Corner trim at outer sidewall
                        groups.leantoLeft.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(-W/2 - ltW - wallOffset - 0.04).translateZ(backTrimZ));
                        
                        // Corner trim at main building connection
                        groups.leantoLeft.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, highPoint, 0.08), trimMat.clone()).translateY(highPoint/2).translateX(-W/2 + wallOffset).translateZ(backTrimZ));
                    }
                }
                
                // Framing INSIDE the structure (must not be visible when walls are on)
                if (params.showFraming) {
                    const ltFrameInset = 0.6;
                    const roofOffset = 0.3; // Closer to roof on side lean-tos
                    
                    // Framing boundaries - well inside all walls
                    const frameOuterX = -W/2 - ltW + ltFrameInset;  // Near outer sidewall (low side)
                    const frameInnerX = -W/2 - ltFrameInset;  // Near main building (high side)
                    const frameFrontZ = ltFrontZ - ltFrameInset;
                    const frameBackZ = ltBackZ + ltFrameInset;
                    const frameWidth = frameInnerX - frameOuterX;
                    const frameLength = frameFrontZ - frameBackZ;
                    
                    // Roof slopes: low at outer (-W/2-ltW), high at inner (-W/2)
                    // Height at any X: roofY = ltH + ltRise * (x - (-W/2 - ltW)) / ltW
                    const rafterAngle = Math.atan2(ltRise, ltW);
                    const rafterLen = Math.sqrt(frameWidth * frameWidth + (frameWidth * ltRise / ltW) * (frameWidth * ltRise / ltW));
                    
                    for (let i = 0; i <= numLtBays; i++) {
                        const z = frameBackZ + i * (frameLength / numLtBays);
                        
                        // Column at outer edge (low side)
                        const col = new THREE.Mesh(new THREE.BoxGeometry(0.25, ltH - roofOffset, 0.25), frameMat.clone());
                        col.position.set(frameOuterX, (ltH - roofOffset)/2, z);
                        groups.leantoLeft.add(col);
                        
                        // Rafter - below roof surface
                        const rafter = new THREE.Mesh(new THREE.BoxGeometry(rafterLen, 0.2, 0.15), frameMat.clone());
                        const rafterCenterX = (frameOuterX + frameInnerX) / 2;
                        const roofYAtCenter = ltH + ltRise * (rafterCenterX - (-W/2 - ltW)) / ltW;
                        rafter.position.set(rafterCenterX, roofYAtCenter - roofOffset, z);
                        rafter.rotation.z = rafterAngle;
                        groups.leantoLeft.add(rafter);
                    }
                    
                    // ENDWALL diagonal rafters (visible when looking at endwalls from front/back)
                    const ewRafterLen = Math.sqrt(ltW * ltW + ltRise * ltRise);
                    const ewRafterCenterX = -W/2 - ltW/2;
                    const ewRafterCenterY = ltH + ltRise/2 - roofOffset;
                    
                    // Front endwall rafter - skip if wrapped with front
                    if (!wrapCorners.leftFront || !leanTos.front.enabled) {
                        const frontEwRafter = new THREE.Mesh(new THREE.BoxGeometry(ewRafterLen, 0.2, 0.15), frameMat.clone());
                        frontEwRafter.position.set(ewRafterCenterX, ewRafterCenterY, frameFrontZ);
                        frontEwRafter.rotation.z = rafterAngle;
                        groups.leantoLeft.add(frontEwRafter);
                    }
                    
                    // Back endwall rafter - skip if wrapped with back
                    if (!wrapCorners.leftBack || !leanTos.back.enabled) {
                        const backEwRafter = new THREE.Mesh(new THREE.BoxGeometry(ewRafterLen, 0.2, 0.15), frameMat.clone());
                        backEwRafter.position.set(ewRafterCenterX, ewRafterCenterY, frameBackZ);
                        backEwRafter.rotation.z = rafterAngle;
                        groups.leantoLeft.add(backEwRafter);
                    }
                    
                    // Eave strut along outer wall
                    const frameCenterZ = (frameFrontZ + frameBackZ) / 2;
                    const eaveStrut = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, frameLength), purlinMat.clone());
                    eaveStrut.position.set(frameOuterX, ltH - roofOffset, frameCenterZ);
                    groups.leantoLeft.add(eaveStrut);
                    
                    // Purlins across the roof
                    const numPurlins = Math.ceil(frameWidth / 1.5);
                    for (let i = 1; i < numPurlins; i++) {
                        const t = i / numPurlins;
                        const px = frameOuterX + t * frameWidth;
                        const roofY = ltH + ltRise * (px - (-W/2 - ltW)) / ltW;
                        const purlin = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, frameLength), purlinMat.clone());
                        purlin.position.set(px, roofY - roofOffset, frameCenterZ);
                        groups.leantoLeft.add(purlin);
                    }
                    
                    // Girts on outer wall
                    const numGirts = Math.floor((ltH - roofOffset) / 1.5);
                    for (let i = 1; i <= numGirts; i++) {
                        const girt = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, frameLength), purlinMat.clone());
                        girt.position.set(frameOuterX + 0.15, i * ((ltH - roofOffset) / (numGirts + 1)), frameCenterZ);
                        groups.leantoLeft.add(girt);
                    }
                }
                
                scene.add(groups.leantoLeft);
            }
            
            // RIGHT LEAN-TO
            if (leanTos.right.enabled) {
                groups.leantoRight = new THREE.Group();
                const ltW = leanTos.right.width * S;
                let ltL = leanTos.right.length * S;  // Allow full length
                const ltOffset = leanTos.right.offset * S;
                const ltH = leanTos.right.height * S;
                const ltPitch = leanTos.right.pitch;
                const ltRise = ltW * (ltPitch / 12);
                const highPoint = ltH + ltRise;
                
                // Overhang for this lean-to
                const ltEaveOH = leanTos.right.showOverhang ? params.eaveOverhang * S : 0;
                const ltGableOH = leanTos.right.showOverhang ? params.gableOverhang * S : 0;
                const ltEaveOHdrop = ltEaveOH * (ltPitch / 12);
                
                // Position with offset (no extension - wrap corners handle the corner geometry)
                const maxOffset = (L - ltL) / 2;
                const clampedOffset = Math.max(-maxOffset, Math.min(maxOffset, ltOffset));
                const ltBackZ = -ltL/2 + clampedOffset;
                const ltFrontZ = ltL/2 + clampedOffset;
                const actualLength = ltFrontZ - ltBackZ;
                
                const numLtBays = Math.max(1, Math.floor(ltL / S / params.baySpacing));
                const ltBaySpacing = actualLength / numLtBays;
                
                // Gable overhang - don't extend into wrap corner areas
                const frontGableOH = (wrapCorners.rightFront && leanTos.front.enabled) ? 0 : ltGableOH;
                const backGableOH = (wrapCorners.rightBack && leanTos.back.enabled) ? 0 : ltGableOH;
                
                // Roof with overhang
                const ltRoofVerts = new Float32Array([
                    W/2 + ltW + ltEaveOH, ltH - ltEaveOHdrop, ltBackZ - backGableOH,
                    W/2 + ltW + ltEaveOH, ltH - ltEaveOHdrop, ltFrontZ + frontGableOH,
                    W/2, highPoint, ltBackZ - backGableOH,
                    W/2, highPoint, ltBackZ - backGableOH,
                    W/2 + ltW + ltEaveOH, ltH - ltEaveOHdrop, ltFrontZ + frontGableOH,
                    W/2, highPoint, ltFrontZ + frontGableOH
                ]);
                const ltRoofUVs = new Float32Array([0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1]);
                const ltRoofGeom = new THREE.BufferGeometry();
                ltRoofGeom.setAttribute('position', new THREE.BufferAttribute(ltRoofVerts, 3));
                ltRoofGeom.setAttribute('uv', new THREE.BufferAttribute(ltRoofUVs, 2));
                ltRoofGeom.computeVertexNormals();
                const ltRoofTex = createRoofTexture(colors.roof);
                ltRoofTex.repeat.set(1, (actualLength + frontGableOH + backGableOH) / 3);
                const ltRoof = new THREE.Mesh(ltRoofGeom, new THREE.MeshStandardMaterial({ map: ltRoofTex, roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide }));
                groups.leantoRight.add(ltRoof);
                
                // Eave trim at outer edge
                // Stop at wrap corner boundaries to avoid visible seams
                if (ltEaveOH > 0) {
                    let trimFrontZ = ltFrontZ;
                    let trimBackZ = ltBackZ;
                    if (wrapCorners.rightFront && leanTos.front.enabled) {
                        trimFrontZ = L/2;  // Stop at main building front edge
                    }
                    if (wrapCorners.rightBack && leanTos.back.enabled) {
                        trimBackZ = -L/2;  // Stop at main building back edge
                    }
                    const trimLength = trimFrontZ - trimBackZ;
                    const ltEaveTrim = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, trimLength), trimMat.clone());
                    ltEaveTrim.position.set(W/2 + ltW + ltEaveOH + 0.04, ltH - ltEaveOHdrop, (trimFrontZ + trimBackZ) / 2);
                    groups.leantoRight.add(ltEaveTrim);

                    // Soffit - only along the non-wrapped length (corner soffit handled by wrap corner)
                    let soffitFrontZ = ltFrontZ;
                    let soffitBackZ = ltBackZ;
                    if (wrapCorners.rightFront && leanTos.front.enabled) {
                        soffitFrontZ = L/2;
                    }
                    if (wrapCorners.rightBack && leanTos.back.enabled) {
                        soffitBackZ = -L/2;
                    }
                    const soffitLength = soffitFrontZ - soffitBackZ;
                    
                    if (soffitLength > 0.1) {
                        const soffitGeom = new THREE.PlaneGeometry(ltEaveOH, soffitLength);
                        const soffit = new THREE.Mesh(soffitGeom, new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide }));
                        soffit.position.set(W/2 + ltW + ltEaveOH/2, ltH - ltEaveOHdrop + 0.01, (soffitFrontZ + soffitBackZ) / 2);
                        soffit.rotation.x = Math.PI/2;
                        groups.leantoRight.add(soffit);
                    }
                }
                
                // Gable rake trim at overhang edge
                if (ltGableOH > 0) {
                    const rakeLen = Math.sqrt((ltW + ltEaveOH) * (ltW + ltEaveOH) + (ltRise + ltEaveOHdrop) * (ltRise + ltEaveOHdrop));
                    const rakeAngle = Math.atan2(ltRise + ltEaveOHdrop, ltW + ltEaveOH);
                    
                    // Front gable rake - skip if wrapped with front lean-to
                    if (!wrapCorners.rightFront || !leanTos.front.enabled) {
                        const rakeFrontOH = new THREE.Mesh(new THREE.BoxGeometry(rakeLen, 0.12, 0.08), trimMat.clone());
                        rakeFrontOH.position.set(W/2 + (ltW + ltEaveOH)/2, ltH + ltRise/2 - ltEaveOHdrop/2, ltFrontZ + ltGableOH + 0.04);
                        rakeFrontOH.rotation.z = Math.PI - rakeAngle;
                        groups.leantoRight.add(rakeFrontOH);
                    }
                    
                    // Back gable rake - skip if wrapped with back lean-to
                    if (!wrapCorners.rightBack || !leanTos.back.enabled) {
                        const rakeBackOH = new THREE.Mesh(new THREE.BoxGeometry(rakeLen, 0.12, 0.08), trimMat.clone());
                        rakeBackOH.position.set(W/2 + (ltW + ltEaveOH)/2, ltH + ltRise/2 - ltEaveOHdrop/2, ltBackZ - ltGableOH - 0.04);
                        rakeBackOH.rotation.z = Math.PI - rakeAngle;
                        groups.leantoRight.add(rakeBackOH);
                    }
                    
                    // Front and back gable soffits - angled to follow roof pitch
                    const gableSoffitMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide });
                    const soffitGap = 0.02; // Small gap to prevent z-fighting
                    
                    // Front gable soffit - skip if wrapped with front lean-to
                    if (!wrapCorners.rightFront || !leanTos.front.enabled) {
                        const frontSoffitVerts = new Float32Array([
                            // Triangle 1
                            W/2, ltH + ltRise - soffitGap, ltFrontZ,  // Inner top (at main wall)
                            W/2 + ltW + ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltFrontZ,  // Outer eave (inside)
                            W/2, ltH + ltRise - soffitGap, ltFrontZ + ltGableOH,  // Inner top (outside)
                            // Triangle 2
                            W/2, ltH + ltRise - soffitGap, ltFrontZ + ltGableOH,  // Inner top (outside)
                            W/2 + ltW + ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltFrontZ,  // Outer eave (inside)
                            W/2 + ltW + ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltFrontZ + ltGableOH  // Outer eave (outside)
                        ]);
                        const frontSoffitGeom = new THREE.BufferGeometry();
                        frontSoffitGeom.setAttribute('position', new THREE.BufferAttribute(frontSoffitVerts, 3));
                        frontSoffitGeom.computeVertexNormals();
                        groups.leantoRight.add(new THREE.Mesh(frontSoffitGeom, gableSoffitMat.clone()));
                        
                        // Front corner soffit
                        const frontCornerSoffitVerts = new Float32Array([
                            W/2 + ltW, ltH - ltEaveOHdrop - soffitGap, ltFrontZ,  // Inner corner
                            W/2 + ltW + ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltFrontZ + ltGableOH,  // Outer corner
                            W/2 + ltW + ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltFrontZ  // Eave edge
                        ]);
                        const frontCornerSoffitGeom = new THREE.BufferGeometry();
                        frontCornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(frontCornerSoffitVerts, 3));
                        frontCornerSoffitGeom.computeVertexNormals();
                        groups.leantoRight.add(new THREE.Mesh(frontCornerSoffitGeom, gableSoffitMat.clone()));
                    }
                    
                    // Back gable soffit - skip if wrapped with back lean-to
                    if (!wrapCorners.rightBack || !leanTos.back.enabled) {
                        const backSoffitVerts = new Float32Array([
                            // Triangle 1
                            W/2, ltH + ltRise - soffitGap, ltBackZ,  // Inner top (at main wall)
                            W/2, ltH + ltRise - soffitGap, ltBackZ - ltGableOH,  // Inner top (outside)
                            W/2 + ltW + ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltBackZ,  // Outer eave (inside)
                            // Triangle 2
                            W/2 + ltW + ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltBackZ,  // Outer eave (inside)
                            W/2, ltH + ltRise - soffitGap, ltBackZ - ltGableOH,  // Inner top (outside)
                            W/2 + ltW + ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltBackZ - ltGableOH  // Outer eave (outside)
                        ]);
                        const backSoffitGeom = new THREE.BufferGeometry();
                        backSoffitGeom.setAttribute('position', new THREE.BufferAttribute(backSoffitVerts, 3));
                        backSoffitGeom.computeVertexNormals();
                        groups.leantoRight.add(new THREE.Mesh(backSoffitGeom, gableSoffitMat.clone()));
                        
                        // Back corner soffit
                        const backCornerSoffitVerts = new Float32Array([
                            W/2 + ltW, ltH - ltEaveOHdrop - soffitGap, ltBackZ,  // Inner corner
                            W/2 + ltW + ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltBackZ,  // Eave edge
                            W/2 + ltW + ltEaveOH, ltH - ltEaveOHdrop - soffitGap, ltBackZ - ltGableOH  // Outer corner
                        ]);
                        const backCornerSoffitGeom = new THREE.BufferGeometry();
                        backCornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(backCornerSoffitVerts, 3));
                        backCornerSoffitGeom.computeVertexNormals();
                        groups.leantoRight.add(new THREE.Mesh(backCornerSoffitGeom, gableSoffitMat.clone()));
                    }
                }
                
                // Sidewall
                if (leanTos.right.showSidewall) {
                    const swTex = createPanelTexture(colors.wall);
                    swTex.repeat.set(actualLength * 0.8, 1);
                    const swCenterZ = (ltFrontZ + ltBackZ) / 2;
                    
                    // Check for frameouts on this wall
                    const swFrameouts = accessories.filter(a => a.wall === 'lt-right-side' && a.type === 'frameout');
                    let swGeom;
                    if (swFrameouts.length > 0) {
                        const shape = new THREE.Shape();
                        shape.moveTo(-actualLength/2, -ltH/2);
                        shape.lineTo(actualLength/2, -ltH/2);
                        shape.lineTo(actualLength/2, ltH/2);
                        shape.lineTo(-actualLength/2, ltH/2);
                        shape.closePath();
                        swFrameouts.forEach(acc => {
                            const fw = acc.width * S;
                            const fh = acc.height * S;
                            // Wall rotated by -PI/2: local +X → world -Z
                            // Accessory posX negative maps to world +Z offset from swCenterZ
                            // So negate fx to align
                            const fx = -(acc.posX || 0);
                            // Height: wall centered, so fy = fh/2 + posY - ltH/2
                            const fy = fh/2 + (acc.posY || 0) - ltH/2;
                            const hole = new THREE.Path();
                            hole.moveTo(fx - fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy + fh/2);
                            hole.lineTo(fx - fw/2, fy + fh/2);
                            hole.closePath();
                            shape.holes.push(hole);
                        });
                        swGeom = new THREE.ShapeGeometry(shape);
                        // Generate proper UVs
                        const positions = swGeom.attributes.position.array;
                        const uvs = new Float32Array((positions.length / 3) * 2);
                        for (let i = 0; i < positions.length / 3; i++) {
                            const x = positions[i * 3];
                            const y = positions[i * 3 + 1];
                            uvs[i * 2] = (x + actualLength/2) / actualLength;
                            uvs[i * 2 + 1] = (y + ltH/2) / ltH;
                        }
                        swGeom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
                    } else {
                        swGeom = new THREE.PlaneGeometry(actualLength, ltH);
                    }
                    
                    const sw = new THREE.Mesh(swGeom, new THREE.MeshStandardMaterial({ map: swTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    sw.position.set(W/2 + ltW + wallOffset, ltH/2, swCenterZ);
                    sw.rotation.y = -Math.PI/2;
                    groups.leantoRight.add(sw);
                    // Trim OUTSIDE the wall (further positive X)
                    const swTrimX = W/2 + ltW + wallOffset + 0.06;
                    groups.leantoRight.add(new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, actualLength + 0.1), trimMat.clone()).translateY(0.075).translateX(swTrimX).translateZ(swCenterZ));
                    // Top trim only when no eave overhang
                    if (ltEaveOH === 0) {
                        groups.leantoRight.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, actualLength + 0.1), trimMat.clone()).translateY(ltH + 0.03).translateX(swTrimX).translateZ(swCenterZ));
                    }
                    // Corner trims - hide if wrapped at that corner
                    if (!wrapCorners.rightFront || !leanTos.front.enabled) {
                        groups.leantoRight.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(swTrimX).translateZ(ltFrontZ + wallOffset + 0.04));
                    }
                    if (!wrapCorners.rightBack || !leanTos.back.enabled) {
                        groups.leantoRight.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(swTrimX).translateZ(ltBackZ - wallOffset - 0.04));
                    }
                }
                
                // Endwalls
                if (leanTos.right.showEndwalls) {
                    const ewTex = createPanelTexture(colors.wall);
                    ewTex.repeat.set(ltW * 0.8, 1);
                    
                    // FRONT endwall - skip if wrapped with front
                    if (!wrapCorners.rightFront || !leanTos.front.enabled) {
                        const ewFrontGeom = new THREE.BufferGeometry();
                        const fVerts = new Float32Array([
                            W/2 - wallOffset, 0, ltFrontZ + wallOffset,
                            W/2 + ltW + wallOffset, 0, ltFrontZ + wallOffset,
                            W/2 + ltW + wallOffset, ltH, ltFrontZ + wallOffset,
                            W/2 - wallOffset, 0, ltFrontZ + wallOffset,
                            W/2 + ltW + wallOffset, ltH, ltFrontZ + wallOffset,
                            W/2 - wallOffset, highPoint, ltFrontZ + wallOffset
                        ]);
                        const fUVs = new Float32Array([
                            0, 0,
                            1, 0,
                            1, 1,
                            0, 0,
                            1, 1,
                            0, 1
                        ]);
                        ewFrontGeom.setAttribute('position', new THREE.BufferAttribute(fVerts, 3));
                        ewFrontGeom.setAttribute('uv', new THREE.BufferAttribute(fUVs, 2));
                        ewFrontGeom.computeVertexNormals();
                        const ewFront = new THREE.Mesh(ewFrontGeom, new THREE.MeshStandardMaterial({ map: ewTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        groups.leantoRight.add(ewFront);
                    }
                    
                    // BACK endwall - skip if wrapped with back
                    if (!wrapCorners.rightBack || !leanTos.back.enabled) {
                        const ewBackGeom = new THREE.BufferGeometry();
                        const bVerts = new Float32Array([
                            W/2 + ltW + wallOffset, 0, ltBackZ - wallOffset,
                            W/2 - wallOffset, 0, ltBackZ - wallOffset,
                            W/2 - wallOffset, highPoint, ltBackZ - wallOffset,
                            W/2 + ltW + wallOffset, 0, ltBackZ - wallOffset,
                            W/2 - wallOffset, highPoint, ltBackZ - wallOffset,
                            W/2 + ltW + wallOffset, ltH, ltBackZ - wallOffset
                        ]);
                        const bUVs = new Float32Array([
                            0, 0,
                            1, 0,
                            1, 1,
                            0, 0,
                            1, 1,
                            0, 1
                        ]);
                        ewBackGeom.setAttribute('position', new THREE.BufferAttribute(bVerts, 3));
                        ewBackGeom.setAttribute('uv', new THREE.BufferAttribute(bUVs, 2));
                        ewBackGeom.computeVertexNormals();
                        const ewBack = new THREE.Mesh(ewBackGeom, new THREE.MeshStandardMaterial({ map: ewTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        groups.leantoRight.add(ewBack);
                    }
                    
                    // Trim OUTSIDE endwalls
                    const frontTrimZ = ltFrontZ + wallOffset + 0.06;
                    const backTrimZ = ltBackZ - wallOffset - 0.06;
                    
                    // Front endwall trim - skip if wrapped with front
                    if (!wrapCorners.rightFront || !leanTos.front.enabled) {
                        // Base trim
                        groups.leantoRight.add(new THREE.Mesh(new THREE.BoxGeometry(ltW + wallOffset*2 + 0.1, 0.15, 0.12), trimMat.clone()).translateY(0.075).translateX(W/2 + ltW/2).translateZ(frontTrimZ));
                        
                        // Rake trim - only when no gable overhang
                        if (ltGableOH === 0) {
                            const rakeLen = Math.sqrt(ltW * ltW + ltRise * ltRise) + 0.1;
                            const rakeAngle = Math.atan2(ltRise, ltW);
                            const rakeFront = new THREE.Mesh(new THREE.BoxGeometry(rakeLen, 0.12, 0.08), trimMat.clone());
                            rakeFront.position.set(W/2 + ltW/2, ltH + ltRise/2, frontTrimZ);
                            rakeFront.rotation.z = Math.PI - rakeAngle;
                            groups.leantoRight.add(rakeFront);
                        }
                        
                        // Corner trim at outer sidewall
                        groups.leantoRight.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(W/2 + ltW + wallOffset + 0.04).translateZ(frontTrimZ));
                        
                        // Corner trim at main building
                        groups.leantoRight.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, highPoint, 0.08), trimMat.clone()).translateY(highPoint/2).translateX(W/2 - wallOffset).translateZ(frontTrimZ));
                    }
                    
                    // Back endwall trim - skip if wrapped with back
                    if (!wrapCorners.rightBack || !leanTos.back.enabled) {
                        // Base trim
                        groups.leantoRight.add(new THREE.Mesh(new THREE.BoxGeometry(ltW + wallOffset*2 + 0.1, 0.15, 0.12), trimMat.clone()).translateY(0.075).translateX(W/2 + ltW/2).translateZ(backTrimZ));
                        
                        // Rake trim - only when no gable overhang
                        if (ltGableOH === 0) {
                            const rakeLen = Math.sqrt(ltW * ltW + ltRise * ltRise) + 0.1;
                            const rakeAngle = Math.atan2(ltRise, ltW);
                            const rakeBack = new THREE.Mesh(new THREE.BoxGeometry(rakeLen, 0.12, 0.08), trimMat.clone());
                            rakeBack.position.set(W/2 + ltW/2, ltH + ltRise/2, backTrimZ);
                            rakeBack.rotation.z = Math.PI - rakeAngle;
                            groups.leantoRight.add(rakeBack);
                        }
                        
                        // Corner trim at outer sidewall
                        groups.leantoRight.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(W/2 + ltW + wallOffset + 0.04).translateZ(backTrimZ));
                        
                        // Corner trim at main building
                        groups.leantoRight.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, highPoint, 0.08), trimMat.clone()).translateY(highPoint/2).translateX(W/2 - wallOffset).translateZ(backTrimZ));
                    }
                }
                
                // Framing INSIDE the structure (must not be visible when walls are on)
                if (params.showFraming) {
                    const ltFrameInset = 0.6;
                    const roofOffset = 0.3; // Closer to roof on side lean-tos
                    
                    // Framing boundaries - well inside all walls
                    const frameInnerX = W/2 + ltFrameInset;  // Near main building (high side)
                    const frameOuterX = W/2 + ltW - ltFrameInset;  // Near outer sidewall (low side)
                    const frameFrontZ = ltFrontZ - ltFrameInset;
                    const frameBackZ = ltBackZ + ltFrameInset;
                    const frameWidth = frameOuterX - frameInnerX;
                    const frameLength = frameFrontZ - frameBackZ;
                    
                    // Roof slopes: high at inner (W/2), low at outer (W/2+ltW)
                    // Height at any X: roofY = ltH + ltRise * ((W/2 + ltW) - x) / ltW
                    const rafterAngle = Math.atan2(ltRise, ltW);
                    const rafterLen = Math.sqrt(frameWidth * frameWidth + (frameWidth * ltRise / ltW) * (frameWidth * ltRise / ltW));
                    
                    for (let i = 0; i <= numLtBays; i++) {
                        const z = frameBackZ + i * (frameLength / numLtBays);
                        
                        // Column at outer edge (low side)
                        const col = new THREE.Mesh(new THREE.BoxGeometry(0.25, ltH - roofOffset, 0.25), frameMat.clone());
                        col.position.set(frameOuterX, (ltH - roofOffset)/2, z);
                        groups.leantoRight.add(col);
                        
                        // Rafter - below roof surface
                        const rafter = new THREE.Mesh(new THREE.BoxGeometry(rafterLen, 0.2, 0.15), frameMat.clone());
                        const rafterCenterX = (frameInnerX + frameOuterX) / 2;
                        const roofYAtCenter = ltH + ltRise * ((W/2 + ltW) - rafterCenterX) / ltW;
                        rafter.position.set(rafterCenterX, roofYAtCenter - roofOffset, z);
                        rafter.rotation.z = Math.PI - rafterAngle;
                        groups.leantoRight.add(rafter);
                    }
                    
                    // ENDWALL diagonal rafters (visible when looking at endwalls from front/back)
                    const ewRafterLen = Math.sqrt(ltW * ltW + ltRise * ltRise);
                    const ewRafterCenterX = W/2 + ltW/2;
                    const ewRafterCenterY = ltH + ltRise/2 - roofOffset;
                    
                    // Front endwall rafter - skip if wrapped with front
                    if (!wrapCorners.rightFront || !leanTos.front.enabled) {
                        const frontEwRafter = new THREE.Mesh(new THREE.BoxGeometry(ewRafterLen, 0.2, 0.15), frameMat.clone());
                        frontEwRafter.position.set(ewRafterCenterX, ewRafterCenterY, frameFrontZ);
                        frontEwRafter.rotation.z = Math.PI - rafterAngle;
                        groups.leantoRight.add(frontEwRafter);
                    }
                    
                    // Back endwall rafter - skip if wrapped with back
                    if (!wrapCorners.rightBack || !leanTos.back.enabled) {
                        const backEwRafter = new THREE.Mesh(new THREE.BoxGeometry(ewRafterLen, 0.2, 0.15), frameMat.clone());
                        backEwRafter.position.set(ewRafterCenterX, ewRafterCenterY, frameBackZ);
                        backEwRafter.rotation.z = Math.PI - rafterAngle;
                        groups.leantoRight.add(backEwRafter);
                    }
                    
                    // Eave strut along outer wall
                    const frameCenterZ = (frameFrontZ + frameBackZ) / 2;
                    const eaveStrut = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, frameLength), purlinMat.clone());
                    eaveStrut.position.set(frameOuterX, ltH - roofOffset, frameCenterZ);
                    groups.leantoRight.add(eaveStrut);
                    
                    // Purlins across the roof
                    const numPurlins = Math.ceil(frameWidth / 1.5);
                    for (let i = 1; i < numPurlins; i++) {
                        const t = i / numPurlins;
                        const px = frameOuterX - t * frameWidth;
                        const roofY = ltH + ltRise * ((W/2 + ltW) - px) / ltW;
                        const purlin = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, frameLength), purlinMat.clone());
                        purlin.position.set(px, roofY - roofOffset, frameCenterZ);
                        groups.leantoRight.add(purlin);
                    }
                    
                    // Girts on outer wall
                    const numGirts = Math.floor((ltH - roofOffset) / 1.5);
                    for (let i = 1; i <= numGirts; i++) {
                        const girt = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, frameLength), purlinMat.clone());
                        girt.position.set(frameOuterX - 0.15, i * ((ltH - roofOffset) / (numGirts + 1)), frameCenterZ);
                        groups.leantoRight.add(girt);
                    }
                }
                
                scene.add(groups.leantoRight);
            }
            
            // FRONT LEAN-TO
            if (leanTos.front.enabled) {
                groups.leantoFront = new THREE.Group();
                const ltD = leanTos.front.depth * S;
                const ltW = leanTos.front.width * S;  // Allow full width
                const ltOffset = leanTos.front.offset * S;
                const ltH = leanTos.front.height * S;
                const ltPitch = leanTos.front.pitch;
                const ltRise = ltD * (ltPitch / 12);
                const highPoint = ltH + ltRise;
                
                // Overhang for this lean-to
                const ltEaveOH = leanTos.front.showOverhang ? params.eaveOverhang * S : 0;
                const ltGableOH = leanTos.front.showOverhang ? params.gableOverhang * S : 0;
                const ltEaveOHdrop = ltEaveOH * (ltPitch / 12);
                
                // Position with offset (no extension - wrap corners handle the corner geometry)
                const maxOffset = (W - ltW) / 2;
                const clampedOffset = Math.max(-maxOffset, Math.min(maxOffset, ltOffset));
                const ltLeftX = -ltW/2 + clampedOffset;
                const ltRightX = ltW/2 + clampedOffset;
                const actualWidth = ltRightX - ltLeftX;
                
                const numFrontBays = Math.max(1, Math.floor(ltW / S / params.baySpacing));
                const frontBaySpacing = actualWidth / numFrontBays;
                
                // Gable overhang - don't extend into wrap corner areas
                const leftGableOH = (wrapCorners.leftFront && leanTos.left.enabled) ? 0 : ltGableOH;
                const rightGableOH = (wrapCorners.rightFront && leanTos.right.enabled) ? 0 : ltGableOH;
                
                // Roof with overhang - slopes from main building (high) to outer edge (low)
                const roofBackZ = L/2;
                const roofFrontZ = L/2 + ltD + ltEaveOH;
                const ltRoofVerts = new Float32Array([
                    ltLeftX - leftGableOH, highPoint, roofBackZ,
                    ltRightX + rightGableOH, highPoint, roofBackZ,
                    ltLeftX - leftGableOH, ltH - ltEaveOHdrop, roofFrontZ,
                    ltRightX + rightGableOH, highPoint, roofBackZ,
                    ltRightX + rightGableOH, ltH - ltEaveOHdrop, roofFrontZ,
                    ltLeftX - leftGableOH, ltH - ltEaveOHdrop, roofFrontZ
                ]);
                const ltRoofUVs = new Float32Array([0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1]);
                const ltRoofGeom = new THREE.BufferGeometry();
                ltRoofGeom.setAttribute('position', new THREE.BufferAttribute(ltRoofVerts, 3));
                ltRoofGeom.setAttribute('uv', new THREE.BufferAttribute(ltRoofUVs, 2));
                ltRoofGeom.computeVertexNormals();
                const ltRoofTex = createRoofTexture(colors.roof);
                ltRoofTex.repeat.set(1, (actualWidth + leftGableOH + rightGableOH) / 3);
                const ltRoof = new THREE.Mesh(ltRoofGeom, new THREE.MeshStandardMaterial({ map: ltRoofTex, roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide }));
                groups.leantoFront.add(ltRoof);
                
                // Eave trim at outer edge
                // Even when wrapped, this lean-to's eave trim extends through the corner area
                if (ltEaveOH > 0) {
                    // Get the side lean-to dimensions for extending trim into corners
                    const leftLtW = leanTos.left.enabled ? leanTos.left.width * S : 0;
                    const rightLtW = leanTos.right.enabled ? leanTos.right.width * S : 0;
                    const leftEaveOH = leanTos.left.showOverhang ? params.eaveOverhang * S : 0;
                    const rightEaveOH = leanTos.right.showOverhang ? params.eaveOverhang * S : 0;
                    
                    // Trim extends to include corner areas when wrapped
                    const trimLeftX = (wrapCorners.leftFront && leanTos.left.enabled) ? (-W/2 - leftLtW - leftEaveOH) : (ltLeftX - leftGableOH);
                    const trimRightX = (wrapCorners.rightFront && leanTos.right.enabled) ? (W/2 + rightLtW + rightEaveOH) : (ltRightX + rightGableOH);
                    
                    const trimWidth = trimRightX - trimLeftX;
                    if (trimWidth > 0.1) {
                        const ltEaveTrim = new THREE.Mesh(new THREE.BoxGeometry(trimWidth, 0.12, 0.08), trimMat.clone());
                        ltEaveTrim.position.set((trimLeftX + trimRightX) / 2, ltH - ltEaveOHdrop, roofFrontZ + 0.04);
                        groups.leantoFront.add(ltEaveTrim);
                    }
                    
                    // Soffit - only along the non-wrapped width (corner soffit handled by wrap corner)
                    const soffitLeftX = (wrapCorners.leftFront && leanTos.left.enabled) ? -W/2 : ltLeftX;
                    const soffitRightX = (wrapCorners.rightFront && leanTos.right.enabled) ? W/2 : ltRightX;
                    const soffitWidth = soffitRightX - soffitLeftX;
                    if (soffitWidth > 0.1) {
                        const soffitGeom = new THREE.PlaneGeometry(soffitWidth, ltEaveOH);
                        const soffit = new THREE.Mesh(soffitGeom, new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide }));
                        soffit.position.set((soffitLeftX + soffitRightX) / 2, ltH - ltEaveOHdrop + 0.01, L/2 + ltD + ltEaveOH/2);
                        soffit.rotation.x = Math.PI/2;
                        groups.leantoFront.add(soffit);
                    }
                }
                
                // Gable rake trim at overhang edge (left and right sides)
                if (ltGableOH > 0) {
                    const rakeLen = Math.sqrt((ltD + ltEaveOH) * (ltD + ltEaveOH) + (ltRise + ltEaveOHdrop) * (ltRise + ltEaveOHdrop));
                    const rakeAngle = Math.atan2(ltRise + ltEaveOHdrop, ltD + ltEaveOH);
                    
                    // Left gable rake - skip if wrapped with left lean-to
                    if (!wrapCorners.leftFront || !leanTos.left.enabled) {
                        const rakeLeftOH = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, rakeLen), trimMat.clone());
                        rakeLeftOH.position.set(ltLeftX - ltGableOH - 0.04, ltH + ltRise/2 - ltEaveOHdrop/2, L/2 + (ltD + ltEaveOH)/2);
                        rakeLeftOH.rotation.x = rakeAngle;
                        groups.leantoFront.add(rakeLeftOH);
                    }
                    
                    // Right gable rake - skip if wrapped with right lean-to
                    if (!wrapCorners.rightFront || !leanTos.right.enabled) {
                        const rakeRightOH = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, rakeLen), trimMat.clone());
                        rakeRightOH.position.set(ltRightX + ltGableOH + 0.04, ltH + ltRise/2 - ltEaveOHdrop/2, L/2 + (ltD + ltEaveOH)/2);
                        rakeRightOH.rotation.x = rakeAngle;
                        groups.leantoFront.add(rakeRightOH);
                    }
                    
                    // Left and right gable soffits - angled to follow roof pitch
                    // For front/back lean-tos, the roof slopes from high (at main building) to low (at outer eave)
                    const gableSoffitMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide });
                    const soffitGap = 0.02; // Small gap to prevent z-fighting
                    
                    // Left gable soffit - skip if wrapped with left lean-to
                    if (!wrapCorners.leftFront || !leanTos.left.enabled) {
                        const leftSoffitVerts = new Float32Array([
                            // Triangle 1
                            ltLeftX, ltH + ltRise - soffitGap, L/2,  // High point at main building (inside gable)
                            ltLeftX - ltGableOH, ltH + ltRise - soffitGap, L/2,  // High point (outside gable)
                            ltLeftX, ltH - soffitGap, L/2 + ltD,  // Low point at eave (inside gable)
                            // Triangle 2
                            ltLeftX - ltGableOH, ltH + ltRise - soffitGap, L/2,  // High point (outside gable)
                            ltLeftX - ltGableOH, ltH - soffitGap, L/2 + ltD,  // Low point at eave (outside gable)
                            ltLeftX, ltH - soffitGap, L/2 + ltD  // Low point at eave (inside gable)
                        ]);
                        const leftSoffitGeom = new THREE.BufferGeometry();
                        leftSoffitGeom.setAttribute('position', new THREE.BufferAttribute(leftSoffitVerts, 3));
                        leftSoffitGeom.computeVertexNormals();
                        groups.leantoFront.add(new THREE.Mesh(leftSoffitGeom, gableSoffitMat.clone()));
                    }
                    
                    // Right gable soffit - skip if wrapped with right lean-to
                    if (!wrapCorners.rightFront || !leanTos.right.enabled) {
                        const rightSoffitVerts = new Float32Array([
                            // Triangle 1
                            ltRightX, ltH + ltRise - soffitGap, L/2,  // High point at main building (inside gable)
                            ltRightX, ltH - soffitGap, L/2 + ltD,  // Low point at eave (inside gable)
                            ltRightX + ltGableOH, ltH + ltRise - soffitGap, L/2,  // High point (outside gable)
                            // Triangle 2
                            ltRightX + ltGableOH, ltH + ltRise - soffitGap, L/2,  // High point (outside gable)
                            ltRightX, ltH - soffitGap, L/2 + ltD,  // Low point at eave (inside gable)
                            ltRightX + ltGableOH, ltH - soffitGap, L/2 + ltD  // Low point at eave (outside gable)
                        ]);
                        const rightSoffitGeom = new THREE.BufferGeometry();
                        rightSoffitGeom.setAttribute('position', new THREE.BufferAttribute(rightSoffitVerts, 3));
                        rightSoffitGeom.computeVertexNormals();
                        groups.leantoFront.add(new THREE.Mesh(rightSoffitGeom, gableSoffitMat.clone()));
                    }
                    
                    // Corner soffits - only needed if there's also eave overhang
                    if (ltEaveOH > 0) {
                        // Left corner - skip if wrapped with left lean-to
                        if (!wrapCorners.leftFront || !leanTos.left.enabled) {
                            const leftCornerSoffitVerts = new Float32Array([
                                ltLeftX, ltH - soffitGap, L/2 + ltD,  // Inner corner at wall
                                ltLeftX - ltGableOH, ltH - soffitGap, L/2 + ltD,  // Gable edge at wall line
                                ltLeftX - ltGableOH, ltH - ltEaveOHdrop - soffitGap, L/2 + ltD + ltEaveOH  // Outer corner
                            ]);
                            const leftCornerSoffitGeom = new THREE.BufferGeometry();
                            leftCornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(leftCornerSoffitVerts, 3));
                            leftCornerSoffitGeom.computeVertexNormals();
                            groups.leantoFront.add(new THREE.Mesh(leftCornerSoffitGeom, gableSoffitMat.clone()));
                            
                            // Additional triangle to complete the corner
                            const leftCorner2Verts = new Float32Array([
                                ltLeftX, ltH - soffitGap, L/2 + ltD,  // Inner corner at wall
                                ltLeftX - ltGableOH, ltH - ltEaveOHdrop - soffitGap, L/2 + ltD + ltEaveOH,  // Outer corner
                                ltLeftX, ltH - ltEaveOHdrop - soffitGap, L/2 + ltD + ltEaveOH  // Eave edge
                            ]);
                            const leftCorner2Geom = new THREE.BufferGeometry();
                            leftCorner2Geom.setAttribute('position', new THREE.BufferAttribute(leftCorner2Verts, 3));
                            leftCorner2Geom.computeVertexNormals();
                            groups.leantoFront.add(new THREE.Mesh(leftCorner2Geom, gableSoffitMat.clone()));
                        }
                        
                        // Right corner - skip if wrapped with right lean-to
                        if (!wrapCorners.rightFront || !leanTos.right.enabled) {
                            const rightCornerSoffitVerts = new Float32Array([
                                ltRightX, ltH - soffitGap, L/2 + ltD,  // Inner corner at wall
                                ltRightX + ltGableOH, ltH - ltEaveOHdrop - soffitGap, L/2 + ltD + ltEaveOH,  // Outer corner
                                ltRightX + ltGableOH, ltH - soffitGap, L/2 + ltD  // Gable edge at wall line
                            ]);
                            const rightCornerSoffitGeom = new THREE.BufferGeometry();
                            rightCornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(rightCornerSoffitVerts, 3));
                            rightCornerSoffitGeom.computeVertexNormals();
                            groups.leantoFront.add(new THREE.Mesh(rightCornerSoffitGeom, gableSoffitMat.clone()));
                            
                            // Additional triangle to complete the corner
                            const rightCorner2Verts = new Float32Array([
                                ltRightX, ltH - soffitGap, L/2 + ltD,  // Inner corner at wall
                                ltRightX, ltH - ltEaveOHdrop - soffitGap, L/2 + ltD + ltEaveOH,  // Eave edge
                                ltRightX + ltGableOH, ltH - ltEaveOHdrop - soffitGap, L/2 + ltD + ltEaveOH  // Outer corner
                            ]);
                            const rightCorner2Geom = new THREE.BufferGeometry();
                            rightCorner2Geom.setAttribute('position', new THREE.BufferAttribute(rightCorner2Verts, 3));
                            rightCorner2Geom.computeVertexNormals();
                            groups.leantoFront.add(new THREE.Mesh(rightCorner2Geom, gableSoffitMat.clone()));
                        }
                    }
                }
                
                // Front wall (outer wall of lean-to)
                if (leanTos.front.showSidewall) {
                    const fwTex = createPanelTexture(colors.wall);
                    fwTex.repeat.set(actualWidth * 0.8, 1);
                    const fwCenterX = (ltLeftX + ltRightX) / 2;
                    
                    // Check for frameouts on this wall
                    const fwFrameouts = accessories.filter(a => a.wall === 'lt-front-front' && a.type === 'frameout');
                    let fwGeom;
                    if (fwFrameouts.length > 0) {
                        const shape = new THREE.Shape();
                        shape.moveTo(-actualWidth/2, -ltH/2);
                        shape.lineTo(actualWidth/2, -ltH/2);
                        shape.lineTo(actualWidth/2, ltH/2);
                        shape.lineTo(-actualWidth/2, ltH/2);
                        shape.closePath();
                        fwFrameouts.forEach(acc => {
                            const fw = acc.width * S;
                            const fh = acc.height * S;
                            // No rotation, local X = world X offset from fwCenterX
                            const fx = acc.posX || 0;
                            // Height: wall centered, so fy = fh/2 + posY - ltH/2
                            const fy = fh/2 + (acc.posY || 0) - ltH/2;
                            const hole = new THREE.Path();
                            hole.moveTo(fx - fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy + fh/2);
                            hole.lineTo(fx - fw/2, fy + fh/2);
                            hole.closePath();
                            shape.holes.push(hole);
                        });
                        fwGeom = new THREE.ShapeGeometry(shape);
                        // Generate proper UVs
                        const positions = fwGeom.attributes.position.array;
                        const uvs = new Float32Array((positions.length / 3) * 2);
                        for (let i = 0; i < positions.length / 3; i++) {
                            const x = positions[i * 3];
                            const y = positions[i * 3 + 1];
                            uvs[i * 2] = (x + actualWidth/2) / actualWidth;
                            uvs[i * 2 + 1] = (y + ltH/2) / ltH;
                        }
                        fwGeom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
                    } else {
                        fwGeom = new THREE.PlaneGeometry(actualWidth, ltH);
                    }
                    
                    const fw = new THREE.Mesh(fwGeom, new THREE.MeshStandardMaterial({ map: fwTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    fw.position.set(fwCenterX, ltH/2, L/2 + ltD);
                    groups.leantoFront.add(fw);
                    // Trim OUTSIDE the wall (+ direction for Z)
                    const trimZ = L/2 + ltD + 0.06;
                    groups.leantoFront.add(new THREE.Mesh(new THREE.BoxGeometry(actualWidth + wallOffset*2 + 0.1, 0.15, 0.12), trimMat.clone()).translateY(0.075).translateX(fwCenterX).translateZ(trimZ));
                    // Top trim only when no eave overhang
                    if (ltEaveOH === 0) {
                        groups.leantoFront.add(new THREE.Mesh(new THREE.BoxGeometry(actualWidth + wallOffset*2 + 0.1, 0.06, 0.08), trimMat.clone()).translateY(ltH + 0.03).translateX(fwCenterX).translateZ(trimZ));
                    }
                    // Corner trims - hide if wrapped at that corner
                    if (!wrapCorners.leftFront || !leanTos.left.enabled) {
                        groups.leantoFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(ltLeftX - wallOffset - 0.04).translateZ(trimZ));
                    }
                    if (!wrapCorners.rightFront || !leanTos.right.enabled) {
                        groups.leantoFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(ltRightX + wallOffset + 0.04).translateZ(trimZ));
                    }
                }
                
                // Endwalls (left and right sides of front lean-to)
                if (leanTos.front.showEndwalls) {
                    const ewTex = createPanelTexture(colors.wall);
                    ewTex.repeat.set(ltD * 0.8, 1);
                    
                    // Endwall positions - span from main building to front wall
                    const ewBackZ = L/2;      // At main building
                    const ewFrontZ = L/2 + ltD; // At front wall
                    
                    // LEFT endwall (at ltLeftX, perpendicular to X axis, facing -X) - skip if wrapped with left
                    if (!wrapCorners.leftFront || !leanTos.left.enabled) {
                        const ewLeftGeom = new THREE.BufferGeometry();
                        const lVerts = new Float32Array([
                            ltLeftX - wallOffset, 0, ewBackZ,
                            ltLeftX - wallOffset, 0, ewFrontZ,
                            ltLeftX - wallOffset, ltH, ewFrontZ,
                            ltLeftX - wallOffset, 0, ewBackZ,
                            ltLeftX - wallOffset, ltH, ewFrontZ,
                            ltLeftX - wallOffset, highPoint, ewBackZ
                        ]);
                        const lUVs = new Float32Array([
                            0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1
                        ]);
                        ewLeftGeom.setAttribute('position', new THREE.BufferAttribute(lVerts, 3));
                        ewLeftGeom.setAttribute('uv', new THREE.BufferAttribute(lUVs, 2));
                        ewLeftGeom.computeVertexNormals();
                        const ewLeft = new THREE.Mesh(ewLeftGeom, new THREE.MeshStandardMaterial({ map: ewTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        groups.leantoFront.add(ewLeft);
                    }
                    
                    // RIGHT endwall (at ltRightX, perpendicular to X axis, facing +X) - skip if wrapped with right
                    if (!wrapCorners.rightFront || !leanTos.right.enabled) {
                        const ewRightGeom = new THREE.BufferGeometry();
                        const rVerts = new Float32Array([
                            ltRightX + wallOffset, 0, ewFrontZ,
                            ltRightX + wallOffset, 0, ewBackZ,
                            ltRightX + wallOffset, highPoint, ewBackZ,
                            ltRightX + wallOffset, 0, ewFrontZ,
                            ltRightX + wallOffset, highPoint, ewBackZ,
                            ltRightX + wallOffset, ltH, ewFrontZ
                        ]);
                        const rUVs = new Float32Array([
                            0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1
                        ]);
                        ewRightGeom.setAttribute('position', new THREE.BufferAttribute(rVerts, 3));
                        ewRightGeom.setAttribute('uv', new THREE.BufferAttribute(rUVs, 2));
                        ewRightGeom.computeVertexNormals();
                        const ewRight = new THREE.Mesh(ewRightGeom, new THREE.MeshStandardMaterial({ map: ewTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        groups.leantoFront.add(ewRight);
                    }
                    
                    // Trim OUTSIDE endwalls
                    const leftTrimX = ltLeftX - wallOffset - 0.06;
                    const rightTrimX = ltRightX + wallOffset + 0.06;
                    
                    // Rake trim values
                    const rakeLen = Math.sqrt(ltD * ltD + ltRise * ltRise);
                    const rakeAngle = Math.atan2(ltRise, ltD);
                    const rakeCenterZ = L/2 + ltD/2;
                    const rakeCenterY = ltH + ltRise/2;
                    
                    // Left endwall trim - skip if wrapped with left
                    if (!wrapCorners.leftFront || !leanTos.left.enabled) {
                        // Base trim on left endwall
                        groups.leantoFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, ltD + 0.1), trimMat.clone()).translateY(0.075).translateX(leftTrimX).translateZ(L/2 + ltD/2));
                        
                        // Rake trim left - only when no gable overhang
                        if (ltGableOH === 0) {
                            const rakeLeft = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, rakeLen), trimMat.clone());
                            rakeLeft.position.set(leftTrimX, rakeCenterY, rakeCenterZ);
                            rakeLeft.rotation.x = rakeAngle;
                            groups.leantoFront.add(rakeLeft);
                        }
                        
                        // Corner trim at front edge (low side)
                        groups.leantoFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(leftTrimX).translateZ(L/2 + ltD + 0.04));
                        
                        // Corner trim at main building (high side)  
                        groups.leantoFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, highPoint, 0.08), trimMat.clone()).translateY(highPoint/2).translateX(leftTrimX).translateZ(L/2 - 0.04));
                    }
                    
                    // Right endwall trim - skip if wrapped with right
                    if (!wrapCorners.rightFront || !leanTos.right.enabled) {
                        // Base trim on right endwall
                        groups.leantoFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, ltD + 0.1), trimMat.clone()).translateY(0.075).translateX(rightTrimX).translateZ(L/2 + ltD/2));
                        
                        // Rake trim right - only when no gable overhang
                        if (ltGableOH === 0) {
                            const rakeRight = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, rakeLen), trimMat.clone());
                            rakeRight.position.set(rightTrimX, rakeCenterY, rakeCenterZ);
                            rakeRight.rotation.x = rakeAngle;
                            groups.leantoFront.add(rakeRight);
                        }
                        
                        // Corner trim at front edge (low side)
                        groups.leantoFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(rightTrimX).translateZ(L/2 + ltD + 0.04));
                        
                        // Corner trim at main building (high side)  
                        groups.leantoFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, highPoint, 0.08), trimMat.clone()).translateY(highPoint/2).translateX(rightTrimX).translateZ(L/2 - 0.04));
                    }
                }
                
                // Framing - INSIDE the structure (must not be visible when walls are on)
                if (params.showFraming) {
                    const ltFrameInset = 0.6;
                    const roofOffset = 0.3;
                    
                    // Framing boundaries - well inside all walls
                    const frameLeftX = ltLeftX + ltFrameInset;
                    const frameRightX = ltRightX - ltFrameInset;
                    const frameBackZ = L/2 + ltFrameInset;
                    const frameFrontZ = L/2 + ltD - ltFrameInset;
                    const frameWidth = frameRightX - frameLeftX;
                    const frameDepth = frameFrontZ - frameBackZ;
                    
                    // Roof slopes: high at back (Z=L/2, Y=ltH+ltRise), low at front (Z=L/2+ltD, Y=ltH)
                    const rafterAngle = Math.atan2(ltRise, ltD);
                    const riseOverFrameDepth = frameDepth * ltRise / ltD;
                    const rafterLen = Math.sqrt(frameDepth * frameDepth + riseOverFrameDepth * riseOverFrameDepth);
                    
                    // Interior rafters spanning back to front
                    for (let i = 0; i <= numFrontBays; i++) {
                        const x = frameLeftX + i * (frameWidth / numFrontBays);
                        
                        // Column at front (low) side
                        const col = new THREE.Mesh(new THREE.BoxGeometry(0.25, ltH - roofOffset, 0.25), frameMat.clone());
                        col.position.set(x, (ltH - roofOffset)/2, frameFrontZ);
                        groups.leantoFront.add(col);
                        
                        // Rafter along slope - slopes DOWN from back to front
                        const rafter = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, rafterLen), frameMat.clone());
                        const rafterCenterZ = (frameBackZ + frameFrontZ) / 2;
                        const tCenter = (rafterCenterZ - L/2) / ltD;
                        const roofYAtCenter = ltH + ltRise * (1 - tCenter);
                        rafter.position.set(x, roofYAtCenter - roofOffset, rafterCenterZ);
                        rafter.rotation.x = rafterAngle; // Positive - slopes down toward +Z
                        groups.leantoFront.add(rafter);
                    }
                    
                    // ENDWALL diagonal rafters (visible when looking at endwalls)
                    // These run along the endwall edges following the roof slope
                    const ewRafterLen = Math.sqrt(ltD * ltD + ltRise * ltRise);
                    const ewRafterCenterZ = L/2 + ltD/2;
                    const ewRafterCenterY = ltH + ltRise/2 - roofOffset;
                    
                    // Left endwall rafter - skip if wrapped with left
                    if (!wrapCorners.leftFront || !leanTos.left.enabled) {
                        const leftEwRafter = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, ewRafterLen), frameMat.clone());
                        leftEwRafter.position.set(frameLeftX, ewRafterCenterY, ewRafterCenterZ);
                        leftEwRafter.rotation.x = rafterAngle;
                        groups.leantoFront.add(leftEwRafter);
                    }
                    
                    // Right endwall rafter - skip if wrapped with right
                    if (!wrapCorners.rightFront || !leanTos.right.enabled) {
                        const rightEwRafter = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, ewRafterLen), frameMat.clone());
                        rightEwRafter.position.set(frameRightX, ewRafterCenterY, ewRafterCenterZ);
                        rightEwRafter.rotation.x = rafterAngle;
                        groups.leantoFront.add(rightEwRafter);
                    }
                    
                    // Eave strut along front wall
                    const frameCenterX = (frameLeftX + frameRightX) / 2;
                    const eaveStrut = new THREE.Mesh(new THREE.BoxGeometry(frameWidth, 0.15, 0.15), purlinMat.clone());
                    eaveStrut.position.set(frameCenterX, ltH - roofOffset, frameFrontZ);
                    groups.leantoFront.add(eaveStrut);
                    
                    // Purlins across the roof
                    const numPurlins = Math.ceil(frameDepth / 1.5);
                    for (let i = 1; i < numPurlins; i++) {
                        const t = i / numPurlins;
                        const pz = frameFrontZ + t * (frameBackZ - frameFrontZ);
                        const tPurlin = (pz - L/2) / ltD;
                        const roofY = ltH + ltRise * (1 - tPurlin);
                        const purlin = new THREE.Mesh(new THREE.BoxGeometry(frameWidth, 0.1, 0.1), purlinMat.clone());
                        purlin.position.set(frameCenterX, roofY - roofOffset, pz);
                        groups.leantoFront.add(purlin);
                    }
                    
                    // Girts on front wall
                    const numGirts = Math.floor((ltH - roofOffset) / 1.5);
                    for (let i = 1; i <= numGirts; i++) {
                        const girt = new THREE.Mesh(new THREE.BoxGeometry(frameWidth, 0.12, 0.08), purlinMat.clone());
                        girt.position.set(frameCenterX, i * ((ltH - roofOffset) / (numGirts + 1)), frameFrontZ - 0.15);
                        groups.leantoFront.add(girt);
                    }
                }
                
                scene.add(groups.leantoFront);
            }
            
            // BACK LEAN-TO
            if (leanTos.back.enabled) {
                groups.leantoBack = new THREE.Group();
                const ltD = leanTos.back.depth * S;
                const ltW = leanTos.back.width * S;  // Allow full width
                const ltOffset = leanTos.back.offset * S;
                const ltH = leanTos.back.height * S;
                const ltPitch = leanTos.back.pitch;
                const ltRise = ltD * (ltPitch / 12);
                const highPoint = ltH + ltRise;
                
                // Overhang for this lean-to
                const ltEaveOH = leanTos.back.showOverhang ? params.eaveOverhang * S : 0;
                const ltGableOH = leanTos.back.showOverhang ? params.gableOverhang * S : 0;
                const ltEaveOHdrop = ltEaveOH * (ltPitch / 12);
                
                // Position with offset (no extension - wrap corners handle the corner geometry)
                const maxOffset = (W - ltW) / 2;
                const clampedOffset = Math.max(-maxOffset, Math.min(maxOffset, ltOffset));
                const ltLeftX = -ltW/2 + clampedOffset;
                const ltRightX = ltW/2 + clampedOffset;
                const actualWidth = ltRightX - ltLeftX;
                
                const numBackBays = Math.max(1, Math.floor(ltW / S / params.baySpacing));
                
                // Roof with overhang - slopes from main building (high at Z=-L/2) to outer edge (low at Z=-L/2-ltD)
                const roofBackZ = -L/2;  // At main building (high side)
                const roofFrontZ = -L/2 - ltD - ltEaveOH;  // Outer edge (low side) with overhang
                const ltRoofVerts = new Float32Array([
                    ltLeftX - ltGableOH, highPoint, roofBackZ,
                    ltRightX + ltGableOH, highPoint, roofBackZ,
                    ltLeftX - ltGableOH, ltH - ltEaveOHdrop, roofFrontZ,
                    ltRightX + ltGableOH, highPoint, roofBackZ,
                    ltRightX + ltGableOH, ltH - ltEaveOHdrop, roofFrontZ,
                    ltLeftX - ltGableOH, ltH - ltEaveOHdrop, roofFrontZ
                ]);
                const ltRoofUVs = new Float32Array([0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1]);
                const ltRoofGeom = new THREE.BufferGeometry();
                ltRoofGeom.setAttribute('position', new THREE.BufferAttribute(ltRoofVerts, 3));
                ltRoofGeom.setAttribute('uv', new THREE.BufferAttribute(ltRoofUVs, 2));
                ltRoofGeom.computeVertexNormals();
                const ltRoofTex = createRoofTexture(colors.roof);
                ltRoofTex.repeat.set(1, (actualWidth + ltGableOH * 2) / 3);
                const ltRoof = new THREE.Mesh(ltRoofGeom, new THREE.MeshStandardMaterial({ map: ltRoofTex, roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide }));
                groups.leantoBack.add(ltRoof);
                
                // Eave trim at outer edge
                // Even when wrapped, this lean-to's eave trim extends through the corner area
                if (ltEaveOH > 0) {
                    // Get the side lean-to dimensions for extending trim into corners
                    const leftLtW = leanTos.left.enabled ? leanTos.left.width * S : 0;
                    const rightLtW = leanTos.right.enabled ? leanTos.right.width * S : 0;
                    const leftEaveOH = leanTos.left.showOverhang ? params.eaveOverhang * S : 0;
                    const rightEaveOH = leanTos.right.showOverhang ? params.eaveOverhang * S : 0;
                    
                    // Trim extends to include corner areas when wrapped
                    const trimLeftX = (wrapCorners.leftBack && leanTos.left.enabled) ? (-W/2 - leftLtW - leftEaveOH) : (ltLeftX - ltGableOH);
                    const trimRightX = (wrapCorners.rightBack && leanTos.right.enabled) ? (W/2 + rightLtW + rightEaveOH) : (ltRightX + ltGableOH);
                    
                    const trimWidth = trimRightX - trimLeftX;
                    if (trimWidth > 0.1) {
                        const ltEaveTrim = new THREE.Mesh(new THREE.BoxGeometry(trimWidth, 0.12, 0.08), trimMat.clone());
                        ltEaveTrim.position.set((trimLeftX + trimRightX) / 2, ltH - ltEaveOHdrop, roofFrontZ - 0.04);
                        groups.leantoBack.add(ltEaveTrim);
                    }
                    
                    // Soffit - only along the non-wrapped width (corner soffit handled by wrap corner)
                    const soffitLeftX = (wrapCorners.leftBack && leanTos.left.enabled) ? -W/2 : ltLeftX;
                    const soffitRightX = (wrapCorners.rightBack && leanTos.right.enabled) ? W/2 : ltRightX;
                    const soffitWidth = soffitRightX - soffitLeftX;
                    if (soffitWidth > 0.1) {
                        const soffitGeom = new THREE.PlaneGeometry(soffitWidth, ltEaveOH);
                        const soffit = new THREE.Mesh(soffitGeom, new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide }));
                        soffit.position.set((soffitLeftX + soffitRightX) / 2, ltH - ltEaveOHdrop + 0.01, -L/2 - ltD - ltEaveOH/2);
                        soffit.rotation.x = Math.PI/2;
                        groups.leantoBack.add(soffit);
                    }
                }
                
                // Gable rake trim at overhang edge (left and right sides)
                if (ltGableOH > 0) {
                    const rakeLen = Math.sqrt((ltD + ltEaveOH) * (ltD + ltEaveOH) + (ltRise + ltEaveOHdrop) * (ltRise + ltEaveOHdrop));
                    const rakeAngle = Math.atan2(ltRise + ltEaveOHdrop, ltD + ltEaveOH);
                    
                    // Left gable rake - skip if wrapped with left lean-to
                    if (!wrapCorners.leftBack || !leanTos.left.enabled) {
                        const rakeLeftOH = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, rakeLen), trimMat.clone());
                        rakeLeftOH.position.set(ltLeftX - ltGableOH - 0.04, ltH + ltRise/2 - ltEaveOHdrop/2, -L/2 - (ltD + ltEaveOH)/2);
                        rakeLeftOH.rotation.x = -rakeAngle;
                        groups.leantoBack.add(rakeLeftOH);
                    }
                    
                    // Right gable rake - skip if wrapped with right lean-to
                    if (!wrapCorners.rightBack || !leanTos.right.enabled) {
                        const rakeRightOH = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, rakeLen), trimMat.clone());
                        rakeRightOH.position.set(ltRightX + ltGableOH + 0.04, ltH + ltRise/2 - ltEaveOHdrop/2, -L/2 - (ltD + ltEaveOH)/2);
                        rakeRightOH.rotation.x = -rakeAngle;
                        groups.leantoBack.add(rakeRightOH);
                    }
                    
                    // Left and right gable soffits - angled to follow roof pitch
                    // For front/back lean-tos, the roof slopes from high (at main building) to low (at outer eave)
                    const gableSoffitMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide });
                    const soffitGap = 0.02; // Small gap to prevent z-fighting
                    
                    // Left gable soffit - skip if wrapped with left lean-to
                    if (!wrapCorners.leftBack || !leanTos.left.enabled) {
                        const leftSoffitVerts = new Float32Array([
                            // Triangle 1
                            ltLeftX, ltH + ltRise - soffitGap, -L/2,  // High point at main building (inside gable)
                            ltLeftX, ltH - soffitGap, -L/2 - ltD,  // Low point at eave (inside gable)
                            ltLeftX - ltGableOH, ltH + ltRise - soffitGap, -L/2,  // High point (outside gable)
                            // Triangle 2
                            ltLeftX - ltGableOH, ltH + ltRise - soffitGap, -L/2,  // High point (outside gable)
                            ltLeftX, ltH - soffitGap, -L/2 - ltD,  // Low point at eave (inside gable)
                            ltLeftX - ltGableOH, ltH - soffitGap, -L/2 - ltD  // Low point at eave (outside gable)
                        ]);
                        const leftSoffitGeom = new THREE.BufferGeometry();
                        leftSoffitGeom.setAttribute('position', new THREE.BufferAttribute(leftSoffitVerts, 3));
                        leftSoffitGeom.computeVertexNormals();
                        groups.leantoBack.add(new THREE.Mesh(leftSoffitGeom, gableSoffitMat.clone()));
                    }
                    
                    // Right gable soffit - skip if wrapped with right lean-to
                    if (!wrapCorners.rightBack || !leanTos.right.enabled) {
                        const rightSoffitVerts = new Float32Array([
                            // Triangle 1
                            ltRightX, ltH + ltRise - soffitGap, -L/2,  // High point at main building (inside gable)
                            ltRightX + ltGableOH, ltH + ltRise - soffitGap, -L/2,  // High point (outside gable)
                            ltRightX, ltH - soffitGap, -L/2 - ltD,  // Low point at eave (inside gable)
                            // Triangle 2
                            ltRightX + ltGableOH, ltH + ltRise - soffitGap, -L/2,  // High point (outside gable)
                            ltRightX + ltGableOH, ltH - soffitGap, -L/2 - ltD,  // Low point at eave (outside gable)
                            ltRightX, ltH - soffitGap, -L/2 - ltD  // Low point at eave (inside gable)
                        ]);
                        const rightSoffitGeom = new THREE.BufferGeometry();
                        rightSoffitGeom.setAttribute('position', new THREE.BufferAttribute(rightSoffitVerts, 3));
                        rightSoffitGeom.computeVertexNormals();
                        groups.leantoBack.add(new THREE.Mesh(rightSoffitGeom, gableSoffitMat.clone()));
                    }
                    
                    // Corner soffits - only needed if there's also eave overhang
                    if (ltEaveOH > 0) {
                        // Left corner - skip if wrapped with left lean-to
                        if (!wrapCorners.leftBack || !leanTos.left.enabled) {
                            const leftCornerSoffitVerts = new Float32Array([
                                ltLeftX, ltH - soffitGap, -L/2 - ltD,  // Inner corner at wall
                                ltLeftX - ltGableOH, ltH - soffitGap, -L/2 - ltD,  // Gable edge at wall line
                                ltLeftX - ltGableOH, ltH - ltEaveOHdrop - soffitGap, -L/2 - ltD - ltEaveOH  // Outer corner
                            ]);
                            const leftCornerSoffitGeom = new THREE.BufferGeometry();
                            leftCornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(leftCornerSoffitVerts, 3));
                            leftCornerSoffitGeom.computeVertexNormals();
                            groups.leantoBack.add(new THREE.Mesh(leftCornerSoffitGeom, gableSoffitMat.clone()));
                            
                            // Additional triangle to complete the corner
                            const leftCorner2Verts = new Float32Array([
                                ltLeftX, ltH - soffitGap, -L/2 - ltD,  // Inner corner at wall
                                ltLeftX - ltGableOH, ltH - ltEaveOHdrop - soffitGap, -L/2 - ltD - ltEaveOH,  // Outer corner
                                ltLeftX, ltH - ltEaveOHdrop - soffitGap, -L/2 - ltD - ltEaveOH  // Eave edge
                            ]);
                            const leftCorner2Geom = new THREE.BufferGeometry();
                            leftCorner2Geom.setAttribute('position', new THREE.BufferAttribute(leftCorner2Verts, 3));
                            leftCorner2Geom.computeVertexNormals();
                            groups.leantoBack.add(new THREE.Mesh(leftCorner2Geom, gableSoffitMat.clone()));
                        }
                        
                        // Right corner - skip if wrapped with right lean-to
                        if (!wrapCorners.rightBack || !leanTos.right.enabled) {
                            const rightCornerSoffitVerts = new Float32Array([
                                ltRightX, ltH - soffitGap, -L/2 - ltD,  // Inner corner at wall
                                ltRightX + ltGableOH, ltH - ltEaveOHdrop - soffitGap, -L/2 - ltD - ltEaveOH,  // Outer corner
                                ltRightX + ltGableOH, ltH - soffitGap, -L/2 - ltD  // Gable edge at wall line
                            ]);
                            const rightCornerSoffitGeom = new THREE.BufferGeometry();
                            rightCornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(rightCornerSoffitVerts, 3));
                            rightCornerSoffitGeom.computeVertexNormals();
                            groups.leantoBack.add(new THREE.Mesh(rightCornerSoffitGeom, gableSoffitMat.clone()));
                            
                            // Additional triangle to complete the corner
                            const rightCorner2Verts = new Float32Array([
                                ltRightX, ltH - soffitGap, -L/2 - ltD,  // Inner corner at wall
                                ltRightX, ltH - ltEaveOHdrop - soffitGap, -L/2 - ltD - ltEaveOH,  // Eave edge
                                ltRightX + ltGableOH, ltH - ltEaveOHdrop - soffitGap, -L/2 - ltD - ltEaveOH  // Outer corner
                            ]);
                            const rightCorner2Geom = new THREE.BufferGeometry();
                            rightCorner2Geom.setAttribute('position', new THREE.BufferAttribute(rightCorner2Verts, 3));
                            rightCorner2Geom.computeVertexNormals();
                            groups.leantoBack.add(new THREE.Mesh(rightCorner2Geom, gableSoffitMat.clone()));
                        }
                    }
                }
                
                // Back wall (outer wall of lean-to, at -L/2-ltD)
                if (leanTos.back.showSidewall) {
                    const bwTex = createPanelTexture(colors.wall);
                    bwTex.repeat.set(actualWidth * 0.8, 1);
                    const bwCenterX = (ltLeftX + ltRightX) / 2;
                    
                    // Check for frameouts on this wall
                    const bwFrameouts = accessories.filter(a => a.wall === 'lt-back-back' && a.type === 'frameout');
                    let bwGeom;
                    if (bwFrameouts.length > 0) {
                        const shape = new THREE.Shape();
                        shape.moveTo(-actualWidth/2, -ltH/2);
                        shape.lineTo(actualWidth/2, -ltH/2);
                        shape.lineTo(actualWidth/2, ltH/2);
                        shape.lineTo(-actualWidth/2, ltH/2);
                        shape.closePath();
                        bwFrameouts.forEach(acc => {
                            const fw = acc.width * S;
                            const fh = acc.height * S;
                            // No rotation, but accessory posX is negated in positioning
                            // Accessory at X = bwCenterX - posX, so negate for hole
                            const fx = -(acc.posX || 0);
                            // Height: wall centered, so fy = fh/2 + posY - ltH/2
                            const fy = fh/2 + (acc.posY || 0) - ltH/2;
                            const hole = new THREE.Path();
                            hole.moveTo(fx - fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy + fh/2);
                            hole.lineTo(fx - fw/2, fy + fh/2);
                            hole.closePath();
                            shape.holes.push(hole);
                        });
                        bwGeom = new THREE.ShapeGeometry(shape);
                        // Generate proper UVs
                        const positions = bwGeom.attributes.position.array;
                        const uvs = new Float32Array((positions.length / 3) * 2);
                        for (let i = 0; i < positions.length / 3; i++) {
                            const x = positions[i * 3];
                            const y = positions[i * 3 + 1];
                            uvs[i * 2] = (x + actualWidth/2) / actualWidth;
                            uvs[i * 2 + 1] = (y + ltH/2) / ltH;
                        }
                        bwGeom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
                    } else {
                        bwGeom = new THREE.PlaneGeometry(actualWidth, ltH);
                    }
                    
                    const bw = new THREE.Mesh(bwGeom, new THREE.MeshStandardMaterial({ map: bwTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    bw.position.set(bwCenterX, ltH/2, -L/2 - ltD);
                    groups.leantoBack.add(bw);
                    // Trim OUTSIDE the wall (- direction for Z)
                    const trimZ = -L/2 - ltD - 0.06;
                    groups.leantoBack.add(new THREE.Mesh(new THREE.BoxGeometry(actualWidth + wallOffset*2 + 0.1, 0.15, 0.12), trimMat.clone()).translateY(0.075).translateX(bwCenterX).translateZ(trimZ));
                    // Top trim only when no eave overhang
                    if (ltEaveOH === 0) {
                        groups.leantoBack.add(new THREE.Mesh(new THREE.BoxGeometry(actualWidth + wallOffset*2 + 0.1, 0.06, 0.08), trimMat.clone()).translateY(ltH + 0.03).translateX(bwCenterX).translateZ(trimZ));
                    }
                    // Corner trims - hide if wrapped at that corner
                    if (!wrapCorners.leftBack || !leanTos.left.enabled) {
                        groups.leantoBack.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(ltLeftX - wallOffset - 0.04).translateZ(trimZ));
                    }
                    if (!wrapCorners.rightBack || !leanTos.right.enabled) {
                        groups.leantoBack.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(ltRightX + wallOffset + 0.04).translateZ(trimZ));
                    }
                }
                
                // Endwalls (left and right sides of back lean-to)
                if (leanTos.back.showEndwalls) {
                    const ewTex = createPanelTexture(colors.wall);
                    ewTex.repeat.set(ltD * 0.8, 1);
                    
                    // Endwall positions - span from main building to back wall
                    const ewBackZ = -L/2;      // At main building (high side)
                    const ewFrontZ = -L/2 - ltD; // At back wall (low side)
                    
                    // LEFT endwall (perpendicular to X axis, facing -X) - skip if wrapped with left
                    if (!wrapCorners.leftBack || !leanTos.left.enabled) {
                        const ewLeftGeom = new THREE.BufferGeometry();
                        const lVerts = new Float32Array([
                            ltLeftX - wallOffset, 0, ewBackZ,
                            ltLeftX - wallOffset, 0, ewFrontZ,
                            ltLeftX - wallOffset, ltH, ewFrontZ,
                            ltLeftX - wallOffset, 0, ewBackZ,
                            ltLeftX - wallOffset, ltH, ewFrontZ,
                            ltLeftX - wallOffset, highPoint, ewBackZ
                        ]);
                        const lUVs = new Float32Array([
                            0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1
                        ]);
                        ewLeftGeom.setAttribute('position', new THREE.BufferAttribute(lVerts, 3));
                        ewLeftGeom.setAttribute('uv', new THREE.BufferAttribute(lUVs, 2));
                        ewLeftGeom.computeVertexNormals();
                        const ewLeft = new THREE.Mesh(ewLeftGeom, new THREE.MeshStandardMaterial({ map: ewTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        groups.leantoBack.add(ewLeft);
                    }
                    
                    // RIGHT endwall (perpendicular to X axis, facing +X) - skip if wrapped with right
                    if (!wrapCorners.rightBack || !leanTos.right.enabled) {
                        const ewRightGeom = new THREE.BufferGeometry();
                        const rVerts = new Float32Array([
                            ltRightX + wallOffset, 0, ewFrontZ,
                            ltRightX + wallOffset, 0, ewBackZ,
                            ltRightX + wallOffset, highPoint, ewBackZ,
                            ltRightX + wallOffset, 0, ewFrontZ,
                            ltRightX + wallOffset, highPoint, ewBackZ,
                            ltRightX + wallOffset, ltH, ewFrontZ
                        ]);
                        const rUVs = new Float32Array([
                            0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1
                        ]);
                        ewRightGeom.setAttribute('position', new THREE.BufferAttribute(rVerts, 3));
                        ewRightGeom.setAttribute('uv', new THREE.BufferAttribute(rUVs, 2));
                        ewRightGeom.computeVertexNormals();
                        const ewRight = new THREE.Mesh(ewRightGeom, new THREE.MeshStandardMaterial({ map: ewTex.clone(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                        groups.leantoBack.add(ewRight);
                    }
                    
                    // Trim OUTSIDE endwalls
                    const leftTrimX = ltLeftX - wallOffset - 0.06;
                    const rightTrimX = ltRightX + wallOffset + 0.06;
                    
                    // Rake trim values
                    const rakeLen = Math.sqrt(ltD * ltD + ltRise * ltRise);
                    const rakeAngle = Math.atan2(ltRise, ltD);
                    const rakeCenterZ = -L/2 - ltD/2;
                    const rakeCenterY = ltH + ltRise/2;
                    
                    // Left endwall trim - skip if wrapped with left
                    if (!wrapCorners.leftBack || !leanTos.left.enabled) {
                        // Base trim on left endwall
                        groups.leantoBack.add(new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, ltD + 0.1), trimMat.clone()).translateY(0.075).translateX(leftTrimX).translateZ(-L/2 - ltD/2));
                        
                        // Rake trim left - only when no gable overhang
                        if (ltGableOH === 0) {
                            const rakeLeft = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, rakeLen), trimMat.clone());
                            rakeLeft.position.set(leftTrimX, rakeCenterY, rakeCenterZ);
                            rakeLeft.rotation.x = -rakeAngle;
                            groups.leantoBack.add(rakeLeft);
                        }
                        
                        // Corner trim at outer edge (low side)
                        groups.leantoBack.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(leftTrimX).translateZ(-L/2 - ltD - 0.04));
                        
                        // Corner trim at main building (high side)  
                        groups.leantoBack.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, highPoint, 0.08), trimMat.clone()).translateY(highPoint/2).translateX(leftTrimX).translateZ(-L/2 + 0.04));
                    }
                    
                    // Right endwall trim - skip if wrapped with right
                    if (!wrapCorners.rightBack || !leanTos.right.enabled) {
                        // Base trim on right endwall
                        groups.leantoBack.add(new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, ltD + 0.1), trimMat.clone()).translateY(0.075).translateX(rightTrimX).translateZ(-L/2 - ltD/2));
                        
                        // Rake trim right - only when no gable overhang
                        if (ltGableOH === 0) {
                            const rakeRight = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, rakeLen), trimMat.clone());
                            rakeRight.position.set(rightTrimX, rakeCenterY, rakeCenterZ);
                            rakeRight.rotation.x = -rakeAngle;
                            groups.leantoBack.add(rakeRight);
                        }
                        
                        // Corner trim at outer edge (low side)
                        groups.leantoBack.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(rightTrimX).translateZ(-L/2 - ltD - 0.04));
                        
                        // Corner trim at main building (high side)  
                        groups.leantoBack.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, highPoint, 0.08), trimMat.clone()).translateY(highPoint/2).translateX(rightTrimX).translateZ(-L/2 + 0.04));
                    }
                }
                
                // Framing - INSIDE the structure (must not be visible when walls are on)
                if (params.showFraming) {
                    const ltFrameInset = 0.6;
                    const roofOffset = 0.3;
                    
                    // Framing boundaries - well inside all walls
                    const frameLeftX = ltLeftX + ltFrameInset;
                    const frameRightX = ltRightX - ltFrameInset;
                    const frameBackZ = -L/2 - ltFrameInset;  // Near main building (high side)
                    const frameFrontZ = -L/2 - ltD + ltFrameInset;  // Near back wall (low side)
                    const frameWidth = frameRightX - frameLeftX;
                    const frameDepth = frameBackZ - frameFrontZ;
                    
                    // Roof slopes: high at main building (Z=-L/2, Y=ltH+ltRise), low at back (Z=-L/2-ltD, Y=ltH)
                    const rafterAngle = Math.atan2(ltRise, ltD);
                    const riseOverFrameDepth = frameDepth * ltRise / ltD;
                    const rafterLen = Math.sqrt(frameDepth * frameDepth + riseOverFrameDepth * riseOverFrameDepth);
                    
                    for (let i = 0; i <= numBackBays; i++) {
                        const x = frameLeftX + i * (frameWidth / numBackBays);
                        
                        // Column at back wall (low side)
                        const col = new THREE.Mesh(new THREE.BoxGeometry(0.25, ltH - roofOffset, 0.25), frameMat.clone());
                        col.position.set(x, (ltH - roofOffset)/2, frameFrontZ);
                        groups.leantoBack.add(col);
                        
                        // Rafter - slopes DOWN from main building toward back wall
                        const rafter = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, rafterLen), frameMat.clone());
                        const rafterCenterZ = (frameBackZ + frameFrontZ) / 2;
                        // Calculate roof height at center: high at -L/2, low at -L/2-ltD
                        const tCenter = (-L/2 - rafterCenterZ) / ltD; // 0 at main building, 1 at back wall
                        const roofYAtCenter = ltH + ltRise * (1 - tCenter);
                        rafter.position.set(x, roofYAtCenter - roofOffset, rafterCenterZ);
                        rafter.rotation.x = -rafterAngle; // Negative - slopes down toward -Z
                        groups.leantoBack.add(rafter);
                    }
                    
                    // ENDWALL diagonal rafters (visible when looking at endwalls)
                    const ewRafterLen = Math.sqrt(ltD * ltD + ltRise * ltRise);
                    const ewRafterCenterZ = -L/2 - ltD/2;
                    const ewRafterCenterY = ltH + ltRise/2 - roofOffset;
                    
                    // Left endwall rafter - skip if wrapped with left
                    if (!wrapCorners.leftBack || !leanTos.left.enabled) {
                        const leftEwRafter = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, ewRafterLen), frameMat.clone());
                        leftEwRafter.position.set(frameLeftX, ewRafterCenterY, ewRafterCenterZ);
                        leftEwRafter.rotation.x = -rafterAngle;
                        groups.leantoBack.add(leftEwRafter);
                    }
                    
                    // Right endwall rafter - skip if wrapped with right
                    if (!wrapCorners.rightBack || !leanTos.right.enabled) {
                        const rightEwRafter = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, ewRafterLen), frameMat.clone());
                        rightEwRafter.position.set(frameRightX, ewRafterCenterY, ewRafterCenterZ);
                        rightEwRafter.rotation.x = -rafterAngle;
                        groups.leantoBack.add(rightEwRafter);
                    }
                    
                    // Eave strut along back wall
                    const frameCenterX = (frameLeftX + frameRightX) / 2;
                    const eaveStrut = new THREE.Mesh(new THREE.BoxGeometry(frameWidth, 0.15, 0.15), purlinMat.clone());
                    eaveStrut.position.set(frameCenterX, ltH - roofOffset, frameFrontZ);
                    groups.leantoBack.add(eaveStrut);
                    
                    // Purlins across the roof
                    const numPurlins = Math.ceil(frameDepth / 1.5);
                    for (let i = 1; i < numPurlins; i++) {
                        const t = i / numPurlins;
                        const pz = frameFrontZ + t * (frameBackZ - frameFrontZ);
                        const tPurlin = (-L/2 - pz) / ltD;
                        const roofY = ltH + ltRise * (1 - tPurlin);
                        const purlin = new THREE.Mesh(new THREE.BoxGeometry(frameWidth, 0.1, 0.1), purlinMat.clone());
                        purlin.position.set(frameCenterX, roofY - roofOffset, pz);
                        groups.leantoBack.add(purlin);
                    }
                    
                    // Girts on back wall
                    const numGirts = Math.floor((ltH - roofOffset) / 1.5);
                    for (let i = 1; i <= numGirts; i++) {
                        const girt = new THREE.Mesh(new THREE.BoxGeometry(frameWidth, 0.12, 0.08), purlinMat.clone());
                        girt.position.set(frameCenterX, i * ((ltH - roofOffset) / (numGirts + 1)), frameFrontZ + 0.15);
                        groups.leantoBack.add(girt);
                    }
                }
                
                scene.add(groups.leantoBack);
            }
            
            // ========== WRAP CORNERS ==========
            // Connect adjacent lean-tos at corners with hip-style roof
            // Two triangular roof panels meeting at diagonal hip line from inner to outer corner
            // Both triangles must share EXACT same points at inner and outer corners
            const roofOffset = 0.3;
            
            // Left + Front corner - TWO extension pieces at 90 degrees
            if (wrapCorners.leftFront && leanTos.left.enabled && leanTos.front.enabled) {
                groups.wrapLeftFront = new THREE.Group();
                
                // Get dimensions
                const ltLeftW = leanTos.left.width * S;
                const ltFrontD = leanTos.front.depth * S;
                const ltH = leanTos.left.height * S;
                const ltPitchLeft = leanTos.left.pitch;
                const ltPitchFront = leanTos.front.pitch;
                const ltRiseLeft = ltLeftW * (ltPitchLeft / 12);
                const ltRiseFront = ltFrontD * (ltPitchFront / 12);
                
                // Overhang from each lean-to
                const eaveOH_L = leanTos.left.showOverhang ? params.eaveOverhang * S : 0;
                const eaveOH_F = leanTos.front.showOverhang ? params.eaveOverhang * S : 0;
                const eaveOHdrop_L = eaveOH_L * (ltPitchLeft / 12);
                const eaveOHdrop_F = eaveOH_F * (ltPitchFront / 12);
                
                const bothWallsClosed = wrapCorners.leftFrontSidewall && wrapCorners.leftFrontFrontwall;
                
                // Key coordinates
                const wallCornerX = -W/2 - ltLeftW;  // Left lean-to wall edge
                const wallCornerZ = L/2 + ltFrontD;   // Front lean-to wall edge
                const outerX = wallCornerX - eaveOH_L; // Left with overhang
                const outerZ = wallCornerZ + eaveOH_F; // Front with overhang
                
                // Heights at various points
                const highAtMain = ltH + Math.max(ltRiseLeft, ltRiseFront);
                const lowAtLeftEave = ltH - eaveOHdrop_L;
                const lowAtFrontEave = ltH - eaveOHdrop_F;
                
                const roofTex = createRoofTexture(colors.roof);
                roofTex.repeat.set(1, Math.max(ltLeftW, ltFrontD) / 3);

                // Small overlap to prevent seam visibility at lean-to junction
                const seamOverlap = 0.15;

                // ============ BASE WRAP CORNER ROOF (no overhang) ============
                // This fills the corner from main building to wall corner
                // Extended INTO lean-to areas to overlap and hide seams
                const baseRoofVerts = new Float32Array([
                    // Triangle 1
                    -W/2 - seamOverlap, highAtMain, L/2 + seamOverlap,
                    wallCornerX, ltH, L/2 + seamOverlap,
                    wallCornerX, ltH, wallCornerZ,
                    // Triangle 2
                    -W/2 - seamOverlap, highAtMain, L/2 + seamOverlap,
                    wallCornerX, ltH, wallCornerZ,
                    -W/2 - seamOverlap, ltH, wallCornerZ
                ]);
                const baseRoofUVs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1]);
                const baseRoofGeom = new THREE.BufferGeometry();
                baseRoofGeom.setAttribute('position', new THREE.BufferAttribute(baseRoofVerts, 3));
                baseRoofGeom.setAttribute('uv', new THREE.BufferAttribute(baseRoofUVs, 2));
                baseRoofGeom.computeVertexNormals();
                groups.wrapLeftFront.add(new THREE.Mesh(baseRoofGeom, new THREE.MeshStandardMaterial({ map: roofTex.clone(), roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide })));
                
                // ============ EXTENSION PIECES (only if overhang enabled) ============
                if (eaveOH_L > 0 || eaveOH_F > 0) {
                    
                    // PIECE 1: LEFT EXTENSION - extends left lean-to's eave overhang into corner area
                    // Goes from X=wallCornerX to X=outerX, Z=L/2+seamOverlap to Z=outerZ
                    // Slopes like left lean-to (high at wallCornerX, low at outerX)
                    if (eaveOH_L > 0) {
                        const leftExtVerts = new Float32Array([
                            // Triangle 1
                            wallCornerX, ltH, L/2 + seamOverlap,
                            outerX, lowAtLeftEave, L/2 + seamOverlap,
                            outerX, lowAtLeftEave, outerZ,
                            // Triangle 2
                            wallCornerX, ltH, L/2 + seamOverlap,
                            outerX, lowAtLeftEave, outerZ,
                            wallCornerX, ltH, outerZ
                        ]);
                        const leftExtUVs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1]);
                        const leftExtGeom = new THREE.BufferGeometry();
                        leftExtGeom.setAttribute('position', new THREE.BufferAttribute(leftExtVerts, 3));
                        leftExtGeom.setAttribute('uv', new THREE.BufferAttribute(leftExtUVs, 2));
                        leftExtGeom.computeVertexNormals();
                        groups.wrapLeftFront.add(new THREE.Mesh(leftExtGeom, new THREE.MeshStandardMaterial({ map: roofTex.clone(), roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide })));
                    }

                    // PIECE 2: FRONT EXTENSION - extends front lean-to's eave overhang into corner area
                    // Goes from Z=wallCornerZ to Z=outerZ, X=-W/2-seamOverlap to X=outerX
                    // Slopes like front lean-to (high at wallCornerZ, low at outerZ)
                    if (eaveOH_F > 0) {
                        const frontExtVerts = new Float32Array([
                            // Triangle 1
                            -W/2 - seamOverlap, ltH, wallCornerZ,
                            wallCornerX, ltH, wallCornerZ,
                            outerX, lowAtFrontEave, outerZ,
                            // Triangle 2
                            -W/2 - seamOverlap, ltH, wallCornerZ,
                            outerX, lowAtFrontEave, outerZ,
                            -W/2 - seamOverlap, lowAtFrontEave, outerZ
                        ]);
                        const frontExtUVs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1]);
                        const frontExtGeom = new THREE.BufferGeometry();
                        frontExtGeom.setAttribute('position', new THREE.BufferAttribute(frontExtVerts, 3));
                        frontExtGeom.setAttribute('uv', new THREE.BufferAttribute(frontExtUVs, 2));
                        frontExtGeom.computeVertexNormals();
                        groups.wrapLeftFront.add(new THREE.Mesh(frontExtGeom, new THREE.MeshStandardMaterial({ map: roofTex.clone(), roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide })));
                    }
                    
                    // Note: The L-shaped edge trim is handled by extending the individual lean-to's eave trim
                    // The wrap corner only handles the soffit and corner transition pieces
                    
                    // SOFFIT under overhang extension - must follow roof slopes
                    const soffitGap = 0.02;
                    const soffitMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide });
                    
                    // Left extension soffit - slopes down from wallCornerX to outerX (left lean-to pitch)
                    // High edge at wallCornerX (ltH), low edge at outerX (lowAtLeftEave)
                    if (eaveOH_L > 0) {
                        const leftSoffitVerts = new Float32Array([
                            // Rectangle from wallCornerX to outerX, L/2+seamOverlap to outerZ
                            // Top edge at wall (high)
                            wallCornerX, ltH - soffitGap, L/2 + seamOverlap,
                            outerX, lowAtLeftEave - soffitGap, L/2 + seamOverlap,
                            outerX, lowAtLeftEave - soffitGap, outerZ,
                            wallCornerX, ltH - soffitGap, L/2 + seamOverlap,
                            outerX, lowAtLeftEave - soffitGap, outerZ,
                            wallCornerX, ltH - soffitGap, outerZ
                        ]);
                        const leftSoffitGeom = new THREE.BufferGeometry();
                        leftSoffitGeom.setAttribute('position', new THREE.BufferAttribute(leftSoffitVerts, 3));
                        leftSoffitGeom.computeVertexNormals();
                        groups.wrapLeftFront.add(new THREE.Mesh(leftSoffitGeom, soffitMat.clone()));
                    }

                    // Front extension soffit - slopes down from wallCornerZ to outerZ (front lean-to pitch)
                    // High edge at wallCornerZ (ltH), low edge at outerZ (lowAtFrontEave)
                    if (eaveOH_F > 0) {
                        const frontSoffitVerts = new Float32Array([
                            // Rectangle from -W/2-seamOverlap to wallCornerX, wallCornerZ to outerZ
                            -W/2 - seamOverlap, ltH - soffitGap, wallCornerZ,
                            wallCornerX, ltH - soffitGap, wallCornerZ,
                            wallCornerX, lowAtFrontEave - soffitGap, outerZ,
                            -W/2 - seamOverlap, ltH - soffitGap, wallCornerZ,
                            wallCornerX, lowAtFrontEave - soffitGap, outerZ,
                            -W/2 - seamOverlap, lowAtFrontEave - soffitGap, outerZ
                        ]);
                        const frontSoffitGeom = new THREE.BufferGeometry();
                        frontSoffitGeom.setAttribute('position', new THREE.BufferAttribute(frontSoffitVerts, 3));
                        frontSoffitGeom.computeVertexNormals();
                        groups.wrapLeftFront.add(new THREE.Mesh(frontSoffitGeom, soffitMat.clone()));
                    }
                    
                    // Corner transition piece - fills the L-shaped corner gap
                    // This triangular piece connects where the two soffits meet
                    if (eaveOH_L > 0 && eaveOH_F > 0) {
                        const cornerSoffitVerts = new Float32Array([
                            // Triangle at the corner intersection
                            wallCornerX, ltH - soffitGap, wallCornerZ,
                            wallCornerX, ltH - soffitGap, outerZ,
                            wallCornerX, lowAtFrontEave - soffitGap, outerZ
                        ]);
                        const cornerSoffitGeom = new THREE.BufferGeometry();
                        cornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(cornerSoffitVerts, 3));
                        cornerSoffitGeom.computeVertexNormals();
                        groups.wrapLeftFront.add(new THREE.Mesh(cornerSoffitGeom, soffitMat.clone()));
                        
                        // Outer corner triangle
                        const outerCornerVerts = new Float32Array([
                            outerX, lowAtLeftEave - soffitGap, outerZ,
                            wallCornerX, ltH - soffitGap, outerZ,
                            wallCornerX, lowAtFrontEave - soffitGap, outerZ
                        ]);
                        const outerCornerGeom = new THREE.BufferGeometry();
                        outerCornerGeom.setAttribute('position', new THREE.BufferAttribute(outerCornerVerts, 3));
                        outerCornerGeom.computeVertexNormals();
                        groups.wrapLeftFront.add(new THREE.Mesh(outerCornerGeom, soffitMat.clone()));
                    }
                    
                } else {
                    // No overhang - add trim at wall corner edges
                    const leftTrimLen = wallCornerZ - L/2;
                    const leftTrim = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, leftTrimLen), trimMat.clone());
                    leftTrim.position.set(wallCornerX - 0.04, ltH, L/2 + leftTrimLen/2);
                    groups.wrapLeftFront.add(leftTrim);
                    
                    const frontTrimLen = -W/2 - wallCornerX;
                    const frontTrim = new THREE.Mesh(new THREE.BoxGeometry(frontTrimLen, 0.12, 0.08), trimMat.clone());
                    frontTrim.position.set(wallCornerX + frontTrimLen/2, ltH, wallCornerZ + 0.04);
                    groups.wrapLeftFront.add(frontTrim);
                }
                
                // Framing
                if (!bothWallsClosed) {
                    groups.wrapLeftFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.25, ltH, 0.25), frameMat.clone()).translateX(wallCornerX).translateY(ltH/2).translateZ(wallCornerZ));
                    groups.wrapLeftFront.add(new THREE.Mesh(new THREE.BoxGeometry(ltLeftW, 0.2, 0.15), frameMat.clone()).translateX(-W/2 - ltLeftW/2).translateY(ltH).translateZ(wallCornerZ));
                    groups.wrapLeftFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, ltFrontD), frameMat.clone()).translateX(wallCornerX).translateY(ltH).translateZ(L/2 + ltFrontD/2));
                }
                
                // Walls
                if (wrapCorners.leftFrontSidewall) {
                    const swTex = createPanelTexture(colors.wall);
                    swTex.repeat.set(ltFrontD * 0.8, 1);
                    const swFrameouts = accessories.filter(a => a.wall === 'wrap-lf-side' && a.type === 'frameout');
                    let swGeom;
                    if (swFrameouts.length > 0) {
                        const shape = new THREE.Shape();
                        shape.moveTo(-ltFrontD/2, -ltH/2);
                        shape.lineTo(ltFrontD/2, -ltH/2);
                        shape.lineTo(ltFrontD/2, ltH/2);
                        shape.lineTo(-ltFrontD/2, ltH/2);
                        shape.closePath();
                        swFrameouts.forEach(acc => {
                            const fw = acc.width * S;
                            const fh = acc.height * S;
                            const fx = acc.posX || 0;
                            const fy = fh/2 + (acc.posY || 0) - ltH/2;
                            const hole = new THREE.Path();
                            hole.moveTo(fx - fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy + fh/2);
                            hole.lineTo(fx - fw/2, fy + fh/2);
                            hole.closePath();
                            shape.holes.push(hole);
                        });
                        swGeom = new THREE.ShapeGeometry(shape);
                        const positions = swGeom.attributes.position.array;
                        const uvs = new Float32Array((positions.length / 3) * 2);
                        for (let i = 0; i < positions.length / 3; i++) {
                            uvs[i * 2] = (positions[i * 3] + ltFrontD/2) / ltFrontD;
                            uvs[i * 2 + 1] = (positions[i * 3 + 1] + ltH/2) / ltH;
                        }
                        swGeom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
                    } else {
                        swGeom = new THREE.PlaneGeometry(ltFrontD, ltH);
                    }
                    const sw = new THREE.Mesh(swGeom, new THREE.MeshStandardMaterial({ map: swTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    sw.position.set(-W/2 - ltLeftW - wallOffset, ltH/2, L/2 + ltFrontD/2);
                    sw.rotation.y = Math.PI/2;
                    groups.wrapLeftFront.add(sw);
                    const swTrimX = -W/2 - ltLeftW - wallOffset - 0.06;
                    groups.wrapLeftFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, ltFrontD + 0.1), trimMat.clone()).translateY(0.075).translateX(swTrimX).translateZ(L/2 + ltFrontD/2));
                    groups.wrapLeftFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, ltFrontD + 0.1), trimMat.clone()).translateY(ltH + 0.03).translateX(swTrimX).translateZ(L/2 + ltFrontD/2));
                }
                
                if (wrapCorners.leftFrontFrontwall) {
                    const fwTex = createPanelTexture(colors.wall);
                    fwTex.repeat.set(ltLeftW * 0.8, 1);
                    const fwFrameouts = accessories.filter(a => a.wall === 'wrap-lf-front' && a.type === 'frameout');
                    let fwGeom;
                    if (fwFrameouts.length > 0) {
                        const shape = new THREE.Shape();
                        shape.moveTo(-ltLeftW/2, -ltH/2);
                        shape.lineTo(ltLeftW/2, -ltH/2);
                        shape.lineTo(ltLeftW/2, ltH/2);
                        shape.lineTo(-ltLeftW/2, ltH/2);
                        shape.closePath();
                        fwFrameouts.forEach(acc => {
                            const fw = acc.width * S;
                            const fh = acc.height * S;
                            const fx = acc.posX || 0;
                            const fy = fh/2 + (acc.posY || 0) - ltH/2;
                            const hole = new THREE.Path();
                            hole.moveTo(fx - fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy + fh/2);
                            hole.lineTo(fx - fw/2, fy + fh/2);
                            hole.closePath();
                            shape.holes.push(hole);
                        });
                        fwGeom = new THREE.ShapeGeometry(shape);
                        addWallUVs(fwGeom, ltLeftW, ltH);
                    } else {
                        fwGeom = new THREE.PlaneGeometry(ltLeftW, ltH);
                    }
                    const fw = new THREE.Mesh(fwGeom, new THREE.MeshStandardMaterial({ map: fwTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    fw.position.set(-W/2 - ltLeftW/2, ltH/2, L/2 + ltFrontD + wallOffset);
                    groups.wrapLeftFront.add(fw);
                    const fwTrimZ = L/2 + ltFrontD + wallOffset + 0.06;
                    groups.wrapLeftFront.add(new THREE.Mesh(new THREE.BoxGeometry(ltLeftW + 0.1, 0.15, 0.12), trimMat.clone()).translateY(0.075).translateX(-W/2 - ltLeftW/2).translateZ(fwTrimZ));
                    groups.wrapLeftFront.add(new THREE.Mesh(new THREE.BoxGeometry(ltLeftW + 0.1, 0.06, 0.08), trimMat.clone()).translateY(ltH + 0.03).translateX(-W/2 - ltLeftW/2).translateZ(fwTrimZ));
                }
                
                // Corner trim
                if (bothWallsClosed) {
                    groups.wrapLeftFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(-W/2 - ltLeftW - wallOffset - 0.04).translateZ(L/2 + ltFrontD + wallOffset + 0.04));
                }
                
                scene.add(groups.wrapLeftFront);
            }
            
            // Right + Front corner - TWO extension pieces at 90 degrees
            if (wrapCorners.rightFront && leanTos.right.enabled && leanTos.front.enabled) {
                groups.wrapRightFront = new THREE.Group();
                
                // Get dimensions
                const ltRightW = leanTos.right.width * S;
                const ltFrontD = leanTos.front.depth * S;
                const ltH = leanTos.right.height * S;
                const ltPitchRight = leanTos.right.pitch;
                const ltPitchFront = leanTos.front.pitch;
                const ltRiseRight = ltRightW * (ltPitchRight / 12);
                const ltRiseFront = ltFrontD * (ltPitchFront / 12);
                
                // Overhang
                const eaveOH_R = leanTos.right.showOverhang ? params.eaveOverhang * S : 0;
                const eaveOH_F = leanTos.front.showOverhang ? params.eaveOverhang * S : 0;
                const eaveOHdrop_R = eaveOH_R * (ltPitchRight / 12);
                const eaveOHdrop_F = eaveOH_F * (ltPitchFront / 12);
                
                const bothWallsClosed = wrapCorners.rightFrontSidewall && wrapCorners.rightFrontFrontwall;
                
                // Key coordinates
                const wallCornerX = W/2 + ltRightW;
                const wallCornerZ = L/2 + ltFrontD;
                const outerX = wallCornerX + eaveOH_R;
                const outerZ = wallCornerZ + eaveOH_F;
                
                // Heights
                const highAtMain = ltH + Math.max(ltRiseRight, ltRiseFront);
                const lowAtRightEave = ltH - eaveOHdrop_R;
                const lowAtFrontEave = ltH - eaveOHdrop_F;
                
                const roofTex = createRoofTexture(colors.roof);
                roofTex.repeat.set(1, Math.max(ltRightW, ltFrontD) / 3);

                // Small overlap to prevent seam visibility at lean-to junction
                const seamOverlap = 0.15;

                // ============ BASE WRAP CORNER ROOF ============
                // Extend INTO lean-to areas to overlap and hide seams
                const baseRoofVerts = new Float32Array([
                    W/2 + seamOverlap, highAtMain, L/2 + seamOverlap,
                    wallCornerX, ltH, wallCornerZ,
                    wallCornerX, ltH, L/2 + seamOverlap,
                    W/2 + seamOverlap, highAtMain, L/2 + seamOverlap,
                    W/2 + seamOverlap, ltH, wallCornerZ,
                    wallCornerX, ltH, wallCornerZ
                ]);
                const baseRoofUVs = new Float32Array([0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1]);
                const baseRoofGeom = new THREE.BufferGeometry();
                baseRoofGeom.setAttribute('position', new THREE.BufferAttribute(baseRoofVerts, 3));
                baseRoofGeom.setAttribute('uv', new THREE.BufferAttribute(baseRoofUVs, 2));
                baseRoofGeom.computeVertexNormals();
                groups.wrapRightFront.add(new THREE.Mesh(baseRoofGeom, new THREE.MeshStandardMaterial({ map: roofTex.clone(), roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide })));

                // ============ EXTENSION PIECES ============
                if (eaveOH_R > 0 || eaveOH_F > 0) {

                    // PIECE 1: RIGHT EXTENSION
                    if (eaveOH_R > 0) {
                        const rightExtVerts = new Float32Array([
                            wallCornerX, ltH, L/2 + seamOverlap,
                            outerX, lowAtRightEave, outerZ,
                            outerX, lowAtRightEave, L/2 + seamOverlap,
                            wallCornerX, ltH, L/2 + seamOverlap,
                            wallCornerX, ltH, outerZ,
                            outerX, lowAtRightEave, outerZ
                        ]);
                        const rightExtUVs = new Float32Array([0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1]);
                        const rightExtGeom = new THREE.BufferGeometry();
                        rightExtGeom.setAttribute('position', new THREE.BufferAttribute(rightExtVerts, 3));
                        rightExtGeom.setAttribute('uv', new THREE.BufferAttribute(rightExtUVs, 2));
                        rightExtGeom.computeVertexNormals();
                        groups.wrapRightFront.add(new THREE.Mesh(rightExtGeom, new THREE.MeshStandardMaterial({ map: roofTex.clone(), roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide })));
                    }

                    // PIECE 2: FRONT EXTENSION
                    if (eaveOH_F > 0) {
                        const frontExtVerts = new Float32Array([
                            W/2 + seamOverlap, ltH, wallCornerZ,
                            outerX, lowAtFrontEave, outerZ,
                            wallCornerX, ltH, wallCornerZ,
                            W/2 + seamOverlap, ltH, wallCornerZ,
                            W/2 + seamOverlap, lowAtFrontEave, outerZ,
                            outerX, lowAtFrontEave, outerZ
                        ]);
                        const frontExtUVs = new Float32Array([0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1]);
                        const frontExtGeom = new THREE.BufferGeometry();
                        frontExtGeom.setAttribute('position', new THREE.BufferAttribute(frontExtVerts, 3));
                        frontExtGeom.setAttribute('uv', new THREE.BufferAttribute(frontExtUVs, 2));
                        frontExtGeom.computeVertexNormals();
                        groups.wrapRightFront.add(new THREE.Mesh(frontExtGeom, new THREE.MeshStandardMaterial({ map: roofTex.clone(), roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide })));
                    }
                    
                    // Note: The L-shaped edge trim is handled by extending the individual lean-to's eave trim
                    // The wrap corner only handles the soffit and corner transition pieces
                    
                    // SOFFIT - must follow roof slopes
                    const soffitGap = 0.02;
                    const soffitMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide });
                    
                    // Right extension soffit - slopes down from wallCornerX to outerX (right lean-to pitch)
                    // High edge at wallCornerX (ltH), low edge at outerX (lowAtRightEave)
                    if (eaveOH_R > 0) {
                        const rightSoffitVerts = new Float32Array([
                            // Rectangle from wallCornerX to outerX, L/2+seamOverlap to outerZ
                            wallCornerX, ltH - soffitGap, L/2 + seamOverlap,
                            outerX, lowAtRightEave - soffitGap, outerZ,
                            outerX, lowAtRightEave - soffitGap, L/2 + seamOverlap,
                            wallCornerX, ltH - soffitGap, L/2 + seamOverlap,
                            wallCornerX, ltH - soffitGap, outerZ,
                            outerX, lowAtRightEave - soffitGap, outerZ
                        ]);
                        const rightSoffitGeom = new THREE.BufferGeometry();
                        rightSoffitGeom.setAttribute('position', new THREE.BufferAttribute(rightSoffitVerts, 3));
                        rightSoffitGeom.computeVertexNormals();
                        groups.wrapRightFront.add(new THREE.Mesh(rightSoffitGeom, soffitMat.clone()));
                    }

                    // Front extension soffit - slopes down from wallCornerZ to outerZ (front lean-to pitch)
                    // High edge at wallCornerZ (ltH), low edge at outerZ (lowAtFrontEave)
                    if (eaveOH_F > 0) {
                        const frontSoffitVerts = new Float32Array([
                            // Rectangle from W/2+seamOverlap to wallCornerX, wallCornerZ to outerZ
                            W/2 + seamOverlap, ltH - soffitGap, wallCornerZ,
                            wallCornerX, lowAtFrontEave - soffitGap, outerZ,
                            wallCornerX, ltH - soffitGap, wallCornerZ,
                            W/2 + seamOverlap, ltH - soffitGap, wallCornerZ,
                            W/2 + seamOverlap, lowAtFrontEave - soffitGap, outerZ,
                            wallCornerX, lowAtFrontEave - soffitGap, outerZ
                        ]);
                        const frontSoffitGeom = new THREE.BufferGeometry();
                        frontSoffitGeom.setAttribute('position', new THREE.BufferAttribute(frontSoffitVerts, 3));
                        frontSoffitGeom.computeVertexNormals();
                        groups.wrapRightFront.add(new THREE.Mesh(frontSoffitGeom, soffitMat.clone()));
                    }
                    
                    // Corner transition pieces - fills the corner gap
                    if (eaveOH_R > 0 && eaveOH_F > 0) {
                        const cornerSoffitVerts = new Float32Array([
                            // Triangle at the corner intersection
                            wallCornerX, ltH - soffitGap, wallCornerZ,
                            wallCornerX, lowAtFrontEave - soffitGap, outerZ,
                            wallCornerX, ltH - soffitGap, outerZ
                        ]);
                        const cornerSoffitGeom = new THREE.BufferGeometry();
                        cornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(cornerSoffitVerts, 3));
                        cornerSoffitGeom.computeVertexNormals();
                        groups.wrapRightFront.add(new THREE.Mesh(cornerSoffitGeom, soffitMat.clone()));
                        
                        // Outer corner triangle
                        const outerCornerVerts = new Float32Array([
                            outerX, lowAtRightEave - soffitGap, outerZ,
                            wallCornerX, lowAtFrontEave - soffitGap, outerZ,
                            wallCornerX, ltH - soffitGap, outerZ
                        ]);
                        const outerCornerGeom = new THREE.BufferGeometry();
                        outerCornerGeom.setAttribute('position', new THREE.BufferAttribute(outerCornerVerts, 3));
                        outerCornerGeom.computeVertexNormals();
                        groups.wrapRightFront.add(new THREE.Mesh(outerCornerGeom, soffitMat.clone()));
                    }
                    
                } else {
                    // No overhang - trim at wall edges
                    const rightTrimLen = wallCornerZ - L/2;
                    const rightTrim = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, rightTrimLen), trimMat.clone());
                    rightTrim.position.set(wallCornerX + 0.04, ltH, L/2 + rightTrimLen/2);
                    groups.wrapRightFront.add(rightTrim);
                    
                    const frontTrimLen = wallCornerX - W/2;
                    const frontTrim = new THREE.Mesh(new THREE.BoxGeometry(frontTrimLen, 0.12, 0.08), trimMat.clone());
                    frontTrim.position.set(W/2 + frontTrimLen/2, ltH, wallCornerZ + 0.04);
                    groups.wrapRightFront.add(frontTrim);
                }
                
                // Wall positions
                const wallCornerX2 = W/2 + ltRightW;
                const wallCornerZ2 = L/2 + ltFrontD;
                
                // Framing
                if (!bothWallsClosed) {
                    const cornerCol = new THREE.Mesh(new THREE.BoxGeometry(0.25, ltH, 0.25), frameMat.clone());
                    cornerCol.position.set(wallCornerX, ltH/2, wallCornerZ);
                    groups.wrapRightFront.add(cornerCol);
                    
                    const headerX = new THREE.Mesh(new THREE.BoxGeometry(ltRightW, 0.2, 0.15), frameMat.clone());
                    headerX.position.set(W/2 + ltRightW/2, ltH, wallCornerZ);
                    groups.wrapRightFront.add(headerX);
                    
                    const headerZ = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, ltFrontD), frameMat.clone());
                    headerZ.position.set(wallCornerX, ltH, L/2 + ltFrontD/2);
                    groups.wrapRightFront.add(headerZ);
                }
                
                // Walls
                if (wrapCorners.rightFrontSidewall) {
                    const swTex = createPanelTexture(colors.wall);
                    swTex.repeat.set(ltFrontD * 0.8, 1);
                    const swFrameouts = accessories.filter(a => a.wall === 'wrap-rf-side' && a.type === 'frameout');
                    let swGeom;
                    if (swFrameouts.length > 0) {
                        const shape = new THREE.Shape();
                        shape.moveTo(-ltFrontD/2, -ltH/2);
                        shape.lineTo(ltFrontD/2, -ltH/2);
                        shape.lineTo(ltFrontD/2, ltH/2);
                        shape.lineTo(-ltFrontD/2, ltH/2);
                        shape.closePath();
                        swFrameouts.forEach(acc => {
                            const fw = acc.width * S;
                            const fh = acc.height * S;
                            const fx = acc.posX || 0;
                            const fy = fh/2 + (acc.posY || 0) - ltH/2;
                            const hole = new THREE.Path();
                            hole.moveTo(fx - fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy + fh/2);
                            hole.lineTo(fx - fw/2, fy + fh/2);
                            hole.closePath();
                            shape.holes.push(hole);
                        });
                        swGeom = new THREE.ShapeGeometry(shape);
                        addWallUVs(swGeom, ltFrontD, ltH);
                    } else {
                        swGeom = new THREE.PlaneGeometry(ltFrontD, ltH);
                    }
                    const sw = new THREE.Mesh(swGeom, new THREE.MeshStandardMaterial({ map: swTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    sw.position.set(W/2 + ltRightW + wallOffset, ltH/2, L/2 + ltFrontD/2);
                    sw.rotation.y = -Math.PI/2;
                    groups.wrapRightFront.add(sw);
                    const swTrimX = W/2 + ltRightW + wallOffset + 0.06;
                    groups.wrapRightFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, ltFrontD + 0.1), trimMat.clone()).translateY(0.075).translateX(swTrimX).translateZ(L/2 + ltFrontD/2));
                    groups.wrapRightFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, ltFrontD + 0.1), trimMat.clone()).translateY(ltH + 0.03).translateX(swTrimX).translateZ(L/2 + ltFrontD/2));
                }
                
                if (wrapCorners.rightFrontFrontwall) {
                    const fwTex = createPanelTexture(colors.wall);
                    fwTex.repeat.set(ltRightW * 0.8, 1);
                    const fwFrameouts = accessories.filter(a => a.wall === 'wrap-rf-front' && a.type === 'frameout');
                    let fwGeom;
                    if (fwFrameouts.length > 0) {
                        const shape = new THREE.Shape();
                        shape.moveTo(-ltRightW/2, -ltH/2);
                        shape.lineTo(ltRightW/2, -ltH/2);
                        shape.lineTo(ltRightW/2, ltH/2);
                        shape.lineTo(-ltRightW/2, ltH/2);
                        shape.closePath();
                        fwFrameouts.forEach(acc => {
                            const fw = acc.width * S;
                            const fh = acc.height * S;
                            const fx = -(acc.posX || 0);
                            const fy = fh/2 + (acc.posY || 0) - ltH/2;
                            const hole = new THREE.Path();
                            hole.moveTo(fx - fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy + fh/2);
                            hole.lineTo(fx - fw/2, fy + fh/2);
                            hole.closePath();
                            shape.holes.push(hole);
                        });
                        fwGeom = new THREE.ShapeGeometry(shape);
                    } else {
                        fwGeom = new THREE.PlaneGeometry(ltRightW, ltH);
                    }
                    const fw = new THREE.Mesh(fwGeom, new THREE.MeshStandardMaterial({ map: fwTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    fw.position.set(W/2 + ltRightW/2, ltH/2, L/2 + ltFrontD + wallOffset);
                    groups.wrapRightFront.add(fw);
                    const fwTrimZ = L/2 + ltFrontD + wallOffset + 0.06;
                    groups.wrapRightFront.add(new THREE.Mesh(new THREE.BoxGeometry(ltRightW + 0.1, 0.15, 0.12), trimMat.clone()).translateY(0.075).translateX(W/2 + ltRightW/2).translateZ(fwTrimZ));
                    groups.wrapRightFront.add(new THREE.Mesh(new THREE.BoxGeometry(ltRightW + 0.1, 0.06, 0.08), trimMat.clone()).translateY(ltH + 0.03).translateX(W/2 + ltRightW/2).translateZ(fwTrimZ));
                }
                
                // Corner trim
                if (bothWallsClosed) {
                    groups.wrapRightFront.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(W/2 + ltRightW + wallOffset + 0.04).translateZ(L/2 + ltFrontD + wallOffset + 0.04));
                }
                
                scene.add(groups.wrapRightFront);
            }
            
            // Left + Back corner
            if (wrapCorners.leftBack && leanTos.left.enabled && leanTos.back.enabled) {
                groups.wrapLeftBack = new THREE.Group();
                const ltLeftW = leanTos.left.width * S;
                const ltBackD = leanTos.back.depth * S;
                const ltH = leanTos.left.height * S;
                const ltPitch = leanTos.left.pitch;
                const ltRiseSide = ltLeftW * (ltPitch / 12);
                const ltRiseBack = ltBackD * (ltPitch / 12);
                const innerCornerHeight = ltH + Math.max(ltRiseSide, ltRiseBack);
                
                // Check if walls are closed
                const bothWallsClosed = wrapCorners.leftBackSidewall && wrapCorners.leftBackBackwall;
                
                // Small overlap to prevent seam visibility at lean-to junction
                const seamOverlap = 0.15;

                // Triangle 1: Side slope - with proper texture
                // Extend INTO lean-to areas to overlap and hide seams
                const roofTex1 = createRoofTexture(colors.roof);
                roofTex1.repeat.set(1, ltBackD / 3);
                const tri1Verts = new Float32Array([
                    -W/2 - seamOverlap, innerCornerHeight, -L/2 - seamOverlap,
                    -W/2 - ltLeftW, ltH, -L/2 - ltBackD,
                    -W/2 - ltLeftW, ltH, -L/2 - seamOverlap
                ]);
                const tri1UVs = new Float32Array([0, 1, 1, 0, 0, 0]);
                const tri1Geom = new THREE.BufferGeometry();
                tri1Geom.setAttribute('position', new THREE.BufferAttribute(tri1Verts, 3));
                tri1Geom.setAttribute('uv', new THREE.BufferAttribute(tri1UVs, 2));
                tri1Geom.computeVertexNormals();
                groups.wrapLeftBack.add(new THREE.Mesh(tri1Geom, new THREE.MeshStandardMaterial({ map: roofTex1, roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide })));

                // Triangle 2: Back slope - with proper texture
                const roofTex2 = createRoofTexture(colors.roof);
                roofTex2.repeat.set(1, ltLeftW / 3);
                const tri2Verts = new Float32Array([
                    -W/2 - seamOverlap, innerCornerHeight, -L/2 - seamOverlap,
                    -W/2 - seamOverlap, ltH, -L/2 - ltBackD,
                    -W/2 - ltLeftW, ltH, -L/2 - ltBackD
                ]);
                const tri2UVs = new Float32Array([1, 1, 1, 0, 0, 0]);
                const tri2Geom = new THREE.BufferGeometry();
                tri2Geom.setAttribute('position', new THREE.BufferAttribute(tri2Verts, 3));
                tri2Geom.setAttribute('uv', new THREE.BufferAttribute(tri2UVs, 2));
                tri2Geom.computeVertexNormals();
                groups.wrapLeftBack.add(new THREE.Mesh(tri2Geom, new THREE.MeshStandardMaterial({ map: roofTex2, roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide })));
                
                // Hip rafter and corner column - only show when walls are open (it's framing)
                if (!bothWallsClosed) {
                    // Hip rafter - diagonal from inner corner to outer corner
                    const innerX = -W/2;
                    const innerY = innerCornerHeight;
                    const innerZ = -L/2;
                    const outerX = -W/2 - ltLeftW;
                    const outerY = ltH;
                    const outerZ = -L/2 - ltBackD;
                    
                    const hipDx = outerX - innerX;
                    const hipDz = outerZ - innerZ;
                    const hipDy = outerY - innerY;
                    const hip3DLen = Math.sqrt(hipDx*hipDx + hipDz*hipDz + hipDy*hipDy);
                    const hipHorizLen = Math.sqrt(hipDx*hipDx + hipDz*hipDz);
                    
                    const hipRafter = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, hip3DLen), frameMat.clone());
                    hipRafter.position.set((innerX + outerX)/2, (innerY + outerY)/2, (innerZ + outerZ)/2);
                    hipRafter.rotation.order = 'YXZ';
                    hipRafter.rotation.y = Math.atan2(hipDx, hipDz);
                    hipRafter.rotation.x = Math.atan2(hipDy, hipHorizLen);
                    groups.wrapLeftBack.add(hipRafter);
                    
                    // Corner column at outer corner
                    const cornerCol = new THREE.Mesh(new THREE.BoxGeometry(0.25, ltH, 0.25), frameMat.clone());
                    cornerCol.position.set(outerX, ltH/2, outerZ);
                    groups.wrapLeftBack.add(cornerCol);
                    
                    // Horizontal header beams
                    const headerX = new THREE.Mesh(new THREE.BoxGeometry(ltLeftW, 0.2, 0.15), frameMat.clone());
                    headerX.position.set(-W/2 - ltLeftW/2, ltH, -L/2 - ltBackD);
                    groups.wrapLeftBack.add(headerX);
                    
                    const headerZ = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, ltBackD), frameMat.clone());
                    headerZ.position.set(-W/2 - ltLeftW, ltH, -L/2 - ltBackD/2);
                    groups.wrapLeftBack.add(headerZ);
                }
                
                // Walls - using corner wall visibility
                if (wrapCorners.leftBackSidewall) {
                    const swTex = createPanelTexture(colors.wall);
                    swTex.repeat.set(ltBackD * 0.8, 1);
                    // Check for frameouts on this wall
                    const swFrameouts = accessories.filter(a => a.wall === 'wrap-lb-side' && a.type === 'frameout');
                    let swGeom;
                    if (swFrameouts.length > 0) {
                        const shape = new THREE.Shape();
                        shape.moveTo(-ltBackD/2, -ltH/2);
                        shape.lineTo(ltBackD/2, -ltH/2);
                        shape.lineTo(ltBackD/2, ltH/2);
                        shape.lineTo(-ltBackD/2, ltH/2);
                        shape.closePath();
                        swFrameouts.forEach(acc => {
                            const fw = acc.width * S;
                            const fh = acc.height * S;
                            // Wall rotated by PI/2: local +X → world +Z
                            // Accessory posX positive = world -Z (more negative), so negate
                            const fx = -(acc.posX || 0);
                            const fy = fh/2 + (acc.posY || 0) - ltH/2;
                            const hole = new THREE.Path();
                            hole.moveTo(fx - fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy + fh/2);
                            hole.lineTo(fx - fw/2, fy + fh/2);
                            hole.closePath();
                            shape.holes.push(hole);
                        });
                        swGeom = new THREE.ShapeGeometry(shape);
                    } else {
                        swGeom = new THREE.PlaneGeometry(ltBackD, ltH);
                    }
                    const sw = new THREE.Mesh(swGeom, new THREE.MeshStandardMaterial({ map: swTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    sw.position.set(-W/2 - ltLeftW - wallOffset, ltH/2, -L/2 - ltBackD/2);
                    sw.rotation.y = Math.PI/2;
                    groups.wrapLeftBack.add(sw);
                    const swTrimX = -W/2 - ltLeftW - wallOffset - 0.06;
                    groups.wrapLeftBack.add(new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, ltBackD + 0.1), trimMat.clone()).translateY(0.075).translateX(swTrimX).translateZ(-L/2 - ltBackD/2));
                    groups.wrapLeftBack.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, ltBackD + 0.1), trimMat.clone()).translateY(ltH + 0.03).translateX(swTrimX).translateZ(-L/2 - ltBackD/2));
                }
                if (wrapCorners.leftBackBackwall) {
                    const bwTex = createPanelTexture(colors.wall);
                    bwTex.repeat.set(ltLeftW * 0.8, 1);
                    // Check for frameouts on this wall
                    const bwFrameouts = accessories.filter(a => a.wall === 'wrap-lb-back' && a.type === 'frameout');
                    let bwGeom;
                    if (bwFrameouts.length > 0) {
                        const shape = new THREE.Shape();
                        shape.moveTo(-ltLeftW/2, -ltH/2);
                        shape.lineTo(ltLeftW/2, -ltH/2);
                        shape.lineTo(ltLeftW/2, ltH/2);
                        shape.lineTo(-ltLeftW/2, ltH/2);
                        shape.closePath();
                        bwFrameouts.forEach(acc => {
                            const fw = acc.width * S;
                            const fh = acc.height * S;
                            // Accessory posX positive = world -X, negate for hole
                            const fx = -(acc.posX || 0);
                            const fy = fh/2 + (acc.posY || 0) - ltH/2;
                            const hole = new THREE.Path();
                            hole.moveTo(fx - fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy + fh/2);
                            hole.lineTo(fx - fw/2, fy + fh/2);
                            hole.closePath();
                            shape.holes.push(hole);
                        });
                        bwGeom = new THREE.ShapeGeometry(shape);
                    } else {
                        bwGeom = new THREE.PlaneGeometry(ltLeftW, ltH);
                    }
                    const bw = new THREE.Mesh(bwGeom, new THREE.MeshStandardMaterial({ map: bwTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    bw.position.set(-W/2 - ltLeftW/2, ltH/2, -L/2 - ltBackD - wallOffset);
                    groups.wrapLeftBack.add(bw);
                    const bwTrimZ = -L/2 - ltBackD - wallOffset - 0.06;
                    groups.wrapLeftBack.add(new THREE.Mesh(new THREE.BoxGeometry(ltLeftW + 0.1, 0.15, 0.12), trimMat.clone()).translateY(0.075).translateX(-W/2 - ltLeftW/2).translateZ(bwTrimZ));
                    groups.wrapLeftBack.add(new THREE.Mesh(new THREE.BoxGeometry(ltLeftW + 0.1, 0.06, 0.08), trimMat.clone()).translateY(ltH + 0.03).translateX(-W/2 - ltLeftW/2).translateZ(bwTrimZ));
                }
                
                // Corner trim only if both walls closed
                if (bothWallsClosed) {
                    groups.wrapLeftBack.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(-W/2 - ltLeftW - wallOffset - 0.04).translateZ(-L/2 - ltBackD - wallOffset - 0.04));
                }
                
                // Soffit under the hip corner roof - only when walls are closed
                if (bothWallsClosed) {
                    const soffitGap = 0.02;
                    const cornerSoffitMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide });
                    
                    // Horizontal triangular soffit at eave height under the corner roof
                    const cornerSoffitVerts = new Float32Array([
                        -W/2, ltH - soffitGap, -L/2,  // Inner corner at main building
                        -W/2 - ltLeftW, ltH - soffitGap, -L/2,  // Left edge
                        -W/2 - ltLeftW, ltH - soffitGap, -L/2 - ltBackD,  // Outer corner
                        -W/2, ltH - soffitGap, -L/2,  // Inner corner at main building
                        -W/2 - ltLeftW, ltH - soffitGap, -L/2 - ltBackD,  // Outer corner
                        -W/2, ltH - soffitGap, -L/2 - ltBackD  // Back edge
                    ]);
                    const cornerSoffitGeom = new THREE.BufferGeometry();
                    cornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(cornerSoffitVerts, 3));
                    cornerSoffitGeom.computeVertexNormals();
                    groups.wrapLeftBack.add(new THREE.Mesh(cornerSoffitGeom, cornerSoffitMat.clone()));
                }
                
                scene.add(groups.wrapLeftBack);
            }
            
            // Right + Back corner
            if (wrapCorners.rightBack && leanTos.right.enabled && leanTos.back.enabled) {
                groups.wrapRightBack = new THREE.Group();
                const ltRightW = leanTos.right.width * S;
                const ltBackD = leanTos.back.depth * S;
                const ltH = leanTos.right.height * S;
                const ltPitch = leanTos.right.pitch;
                const ltRiseSide = ltRightW * (ltPitch / 12);
                const ltRiseBack = ltBackD * (ltPitch / 12);
                const innerCornerHeight = ltH + Math.max(ltRiseSide, ltRiseBack);
                
                // Check if walls are closed
                const bothWallsClosed = wrapCorners.rightBackSidewall && wrapCorners.rightBackBackwall;
                
                // Small overlap to prevent seam visibility at lean-to junction
                const seamOverlap = 0.15;

                // Triangle 1: Side slope - with proper texture
                // Extend INTO lean-to areas to overlap and hide seams
                const roofTex1 = createRoofTexture(colors.roof);
                roofTex1.repeat.set(1, ltBackD / 3);
                const tri1Verts = new Float32Array([
                    W/2 + seamOverlap, innerCornerHeight, -L/2 - seamOverlap,
                    W/2 + ltRightW, ltH, -L/2 - seamOverlap,
                    W/2 + ltRightW, ltH, -L/2 - ltBackD
                ]);
                const tri1UVs = new Float32Array([0, 1, 0, 0, 1, 0]);
                const tri1Geom = new THREE.BufferGeometry();
                tri1Geom.setAttribute('position', new THREE.BufferAttribute(tri1Verts, 3));
                tri1Geom.setAttribute('uv', new THREE.BufferAttribute(tri1UVs, 2));
                tri1Geom.computeVertexNormals();
                groups.wrapRightBack.add(new THREE.Mesh(tri1Geom, new THREE.MeshStandardMaterial({ map: roofTex1, roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide })));

                // Triangle 2: Back slope - with proper texture
                const roofTex2 = createRoofTexture(colors.roof);
                roofTex2.repeat.set(1, ltRightW / 3);
                const tri2Verts = new Float32Array([
                    W/2 + seamOverlap, innerCornerHeight, -L/2 - seamOverlap,
                    W/2 + ltRightW, ltH, -L/2 - ltBackD,
                    W/2 + seamOverlap, ltH, -L/2 - ltBackD
                ]);
                const tri2UVs = new Float32Array([0, 1, 1, 0, 0, 0]);
                const tri2Geom = new THREE.BufferGeometry();
                tri2Geom.setAttribute('position', new THREE.BufferAttribute(tri2Verts, 3));
                tri2Geom.setAttribute('uv', new THREE.BufferAttribute(tri2UVs, 2));
                tri2Geom.computeVertexNormals();
                groups.wrapRightBack.add(new THREE.Mesh(tri2Geom, new THREE.MeshStandardMaterial({ map: roofTex2, roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide })));
                
                // Hip rafter and corner column - only show when walls are open (it's framing)
                if (!bothWallsClosed) {
                    // Hip rafter - diagonal from inner corner to outer corner
                    const innerX = W/2;
                    const innerY = innerCornerHeight;
                    const innerZ = -L/2;
                    const outerX = W/2 + ltRightW;
                    const outerY = ltH;
                    const outerZ = -L/2 - ltBackD;
                    
                    const hipDx = outerX - innerX;
                    const hipDz = outerZ - innerZ;
                    const hipDy = outerY - innerY;
                    const hip3DLen = Math.sqrt(hipDx*hipDx + hipDz*hipDz + hipDy*hipDy);
                    const hipHorizLen = Math.sqrt(hipDx*hipDx + hipDz*hipDz);
                    
                    const hipRafter = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, hip3DLen), frameMat.clone());
                    hipRafter.position.set((innerX + outerX)/2, (innerY + outerY)/2, (innerZ + outerZ)/2);
                    hipRafter.rotation.order = 'YXZ';
                    hipRafter.rotation.y = Math.atan2(hipDx, hipDz);
                    hipRafter.rotation.x = Math.atan2(hipDy, hipHorizLen);
                    groups.wrapRightBack.add(hipRafter);
                    
                    // Corner column at outer corner
                    const cornerCol = new THREE.Mesh(new THREE.BoxGeometry(0.25, ltH, 0.25), frameMat.clone());
                    cornerCol.position.set(outerX, ltH/2, outerZ);
                    groups.wrapRightBack.add(cornerCol);
                    
                    // Horizontal header beams
                    const headerX = new THREE.Mesh(new THREE.BoxGeometry(ltRightW, 0.2, 0.15), frameMat.clone());
                    headerX.position.set(W/2 + ltRightW/2, ltH, -L/2 - ltBackD);
                    groups.wrapRightBack.add(headerX);
                    
                    const headerZ = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, ltBackD), frameMat.clone());
                    headerZ.position.set(W/2 + ltRightW, ltH, -L/2 - ltBackD/2);
                    groups.wrapRightBack.add(headerZ);
                }
                
                // Walls - using corner wall visibility
                if (wrapCorners.rightBackSidewall) {
                    const swTex = createPanelTexture(colors.wall);
                    swTex.repeat.set(ltBackD * 0.8, 1);
                    // Check for frameouts on this wall
                    const swFrameouts = accessories.filter(a => a.wall === 'wrap-rb-side' && a.type === 'frameout');
                    let swGeom;
                    if (swFrameouts.length > 0) {
                        const shape = new THREE.Shape();
                        shape.moveTo(-ltBackD/2, -ltH/2);
                        shape.lineTo(ltBackD/2, -ltH/2);
                        shape.lineTo(ltBackD/2, ltH/2);
                        shape.lineTo(-ltBackD/2, ltH/2);
                        shape.closePath();
                        swFrameouts.forEach(acc => {
                            const fw = acc.width * S;
                            const fh = acc.height * S;
                            // Wall rotated by -PI/2: local +X → world -Z
                            // Accessory posX positive = world +Z (less negative), so negate
                            const fx = -(acc.posX || 0);
                            const fy = fh/2 + (acc.posY || 0) - ltH/2;
                            const hole = new THREE.Path();
                            hole.moveTo(fx - fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy + fh/2);
                            hole.lineTo(fx - fw/2, fy + fh/2);
                            hole.closePath();
                            shape.holes.push(hole);
                        });
                        swGeom = new THREE.ShapeGeometry(shape);
                    } else {
                        swGeom = new THREE.PlaneGeometry(ltBackD, ltH);
                    }
                    const sw = new THREE.Mesh(swGeom, new THREE.MeshStandardMaterial({ map: swTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    sw.position.set(W/2 + ltRightW + wallOffset, ltH/2, -L/2 - ltBackD/2);
                    sw.rotation.y = -Math.PI/2;
                    groups.wrapRightBack.add(sw);
                    const swTrimX = W/2 + ltRightW + wallOffset + 0.06;
                    groups.wrapRightBack.add(new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, ltBackD + 0.1), trimMat.clone()).translateY(0.075).translateX(swTrimX).translateZ(-L/2 - ltBackD/2));
                    groups.wrapRightBack.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, ltBackD + 0.1), trimMat.clone()).translateY(ltH + 0.03).translateX(swTrimX).translateZ(-L/2 - ltBackD/2));
                }
                if (wrapCorners.rightBackBackwall) {
                    const bwTex = createPanelTexture(colors.wall);
                    bwTex.repeat.set(ltRightW * 0.8, 1);
                    // Check for frameouts on this wall
                    const bwFrameouts = accessories.filter(a => a.wall === 'wrap-rb-back' && a.type === 'frameout');
                    let bwGeom;
                    if (bwFrameouts.length > 0) {
                        const shape = new THREE.Shape();
                        shape.moveTo(-ltRightW/2, -ltH/2);
                        shape.lineTo(ltRightW/2, -ltH/2);
                        shape.lineTo(ltRightW/2, ltH/2);
                        shape.lineTo(-ltRightW/2, ltH/2);
                        shape.closePath();
                        bwFrameouts.forEach(acc => {
                            const fw = acc.width * S;
                            const fh = acc.height * S;
                            const fx = acc.posX || 0;
                            const fy = fh/2 + (acc.posY || 0) - ltH/2;
                            const hole = new THREE.Path();
                            hole.moveTo(fx - fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy - fh/2);
                            hole.lineTo(fx + fw/2, fy + fh/2);
                            hole.lineTo(fx - fw/2, fy + fh/2);
                            hole.closePath();
                            shape.holes.push(hole);
                        });
                        bwGeom = new THREE.ShapeGeometry(shape);
                    } else {
                        bwGeom = new THREE.PlaneGeometry(ltRightW, ltH);
                    }
                    const bw = new THREE.Mesh(bwGeom, new THREE.MeshStandardMaterial({ map: bwTex, roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
                    bw.position.set(W/2 + ltRightW/2, ltH/2, -L/2 - ltBackD - wallOffset);
                    groups.wrapRightBack.add(bw);
                    const bwTrimZ = -L/2 - ltBackD - wallOffset - 0.06;
                    groups.wrapRightBack.add(new THREE.Mesh(new THREE.BoxGeometry(ltRightW + 0.1, 0.15, 0.12), trimMat.clone()).translateY(0.075).translateX(W/2 + ltRightW/2).translateZ(bwTrimZ));
                    groups.wrapRightBack.add(new THREE.Mesh(new THREE.BoxGeometry(ltRightW + 0.1, 0.06, 0.08), trimMat.clone()).translateY(ltH + 0.03).translateX(W/2 + ltRightW/2).translateZ(bwTrimZ));
                }
                
                // Corner trim only if both walls closed
                if (bothWallsClosed) {
                    groups.wrapRightBack.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, ltH, 0.08), trimMat.clone()).translateY(ltH/2).translateX(W/2 + ltRightW + wallOffset + 0.04).translateZ(-L/2 - ltBackD - wallOffset - 0.04));
                }
                
                // Soffit under the hip corner roof - only when walls are closed
                if (bothWallsClosed) {
                    const soffitGap = 0.02;
                    const cornerSoffitMat = new THREE.MeshStandardMaterial({ color: colors.trim, roughness: 0.5, side: THREE.DoubleSide });
                    
                    // Horizontal triangular soffit at eave height under the corner roof
                    const cornerSoffitVerts = new Float32Array([
                        W/2, ltH - soffitGap, -L/2,  // Inner corner at main building
                        W/2 + ltRightW, ltH - soffitGap, -L/2,  // Right edge
                        W/2 + ltRightW, ltH - soffitGap, -L/2 - ltBackD,  // Outer corner
                        W/2, ltH - soffitGap, -L/2,  // Inner corner at main building
                        W/2 + ltRightW, ltH - soffitGap, -L/2 - ltBackD,  // Outer corner
                        W/2, ltH - soffitGap, -L/2 - ltBackD  // Back edge
                    ]);
                    const cornerSoffitGeom = new THREE.BufferGeometry();
                    cornerSoffitGeom.setAttribute('position', new THREE.BufferAttribute(cornerSoffitVerts, 3));
                    cornerSoffitGeom.computeVertexNormals();
                    groups.wrapRightBack.add(new THREE.Mesh(cornerSoffitGeom, cornerSoffitMat.clone()));
                }
                
                scene.add(groups.wrapRightBack);
            }
        }
        
        function rebuildAccessories() {
            accessoryMeshes.forEach(mesh => { scene.remove(mesh); });
            accessoryMeshes = [];
            
            const S = 1/3;
            const W = params.width * S;
            const L = params.length * S;
            const H = params.height * S;
            const wallOffset = 0.05;
            
            accessories.forEach((acc) => {
                const w = acc.width * S;
                const h = acc.height * S;
                const group = new THREE.Group();
                group.userData.accessoryId = acc.id;
                
                const isSelected = selectedAccessoryId === acc.id;
                const hasCollision = checkFramingCollision(acc) !== null;
                
                // Red color if collision, yellow if selected, white otherwise
                const baseColor = hasCollision ? 0xff4444 : (isSelected ? 0xffdd88 : 0xeeeeee);
                const frameColor = hasCollision ? 0xcc0000 : (isSelected ? 0xffb432 : colors.trim);
                
                const whiteMat = new THREE.MeshStandardMaterial({ color: baseColor, roughness: 0.5 });
                const frameMat = new THREE.MeshStandardMaterial({ color: frameColor, roughness: 0.4 });
                const frameT = 0.05;
                
                if (acc.type === 'door') {
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.08), whiteMat));
                    const top = new THREE.Mesh(new THREE.BoxGeometry(w + frameT*2, frameT, 0.1), frameMat);
                    top.position.y = h/2 + frameT/2;
                    group.add(top);
                    const left = new THREE.Mesh(new THREE.BoxGeometry(frameT, h, 0.1), frameMat);
                    left.position.x = -w/2 - frameT/2;
                    group.add(left);
                    const right = new THREE.Mesh(new THREE.BoxGeometry(frameT, h, 0.1), frameMat);
                    right.position.x = w/2 + frameT/2;
                    group.add(right);
                } else if (acc.type === 'glassdoor') {
                    // Double glass door
                    const glassColor = hasCollision ? 0xff6666 : (isSelected ? 0xaaddff : 0x87CEEB);
                    const glassMat = new THREE.MeshStandardMaterial({ color: glassColor, roughness: 0.1, metalness: 0.8, transparent: true, opacity: 0.6 });
                    const doorWidth = w / 2 - 0.03;
                    // Left door panel
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(doorWidth, h - 0.1, 0.06), glassMat).translateX(-w/4));
                    // Right door panel
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(doorWidth, h - 0.1, 0.06), glassMat).translateX(w/4));
                    // Frame
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w + frameT*2, frameT, 0.1), frameMat).translateY(h/2 + frameT/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(frameT, h, 0.1), frameMat).translateX(-w/2 - frameT/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(frameT, h, 0.1), frameMat).translateX(w/2 + frameT/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(frameT*0.7, h, 0.1), frameMat)); // Center divider
                    // Door handles
                    const handleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 });
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.25, 0.04), handleMat).translateX(-0.15).translateY(-0.1).translateZ(0.05));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.25, 0.04), handleMat).translateX(0.15).translateY(-0.1).translateZ(0.05));
                } else if (acc.type === 'window') {
                    const glassColor = hasCollision ? 0xff6666 : (isSelected ? 0xaaddff : 0x87CEEB);
                    const glassMat = new THREE.MeshStandardMaterial({ color: glassColor, roughness: 0.1, metalness: 0.8, transparent: true, opacity: 0.7 });
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.05), glassMat));
                    const ft = 0.04;
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w + ft*2, ft, 0.08), frameMat).translateY(h/2 + ft/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w + ft*2, ft, 0.08), frameMat).translateY(-h/2 - ft/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(ft, h + ft*2, 0.08), frameMat).translateX(-w/2 - ft/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(ft, h + ft*2, 0.08), frameMat).translateX(w/2 + ft/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(0.02, h, 0.06), frameMat));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w, 0.02, 0.06), frameMat));
                } else if (acc.type === 'frameout') {
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w + frameT*2, frameT, 0.1), frameMat).translateY(h/2 + frameT/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w + frameT*2, frameT, 0.1), frameMat).translateY(-h/2 - frameT/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(frameT, h + frameT*2, 0.1), frameMat).translateX(-w/2 - frameT/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(frameT, h + frameT*2, 0.1), frameMat).translateX(w/2 + frameT/2));
                } else if (acc.type === 'rollup') {
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.08), whiteMat));
                    const lines = Math.floor(h / 0.15);
                    const lineMat = new THREE.MeshStandardMaterial({ color: hasCollision ? 0xaa0000 : 0xcccccc });
                    for (let i = 1; i < lines; i++) {
                        const line = new THREE.Mesh(new THREE.BoxGeometry(w, 0.02, 0.09), lineMat);
                        line.position.y = -h/2 + i * (h / lines);
                        group.add(line);
                    }
                    const ft = 0.06;
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w + ft*2, ft*1.5, 0.12), frameMat).translateY(h/2 + ft));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(ft, h + ft, 0.12), frameMat).translateX(-w/2 - ft/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(ft, h + ft, 0.12), frameMat).translateX(w/2 + ft/2));
                } else if (acc.type === 'overhead') {
                    // Sectional overhead door (like garage door)
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.08), whiteMat));
                    const sections = Math.floor(h / 0.4);
                    const lineMat = new THREE.MeshStandardMaterial({ color: hasCollision ? 0xaa0000 : 0xaaaaaa });
                    for (let i = 1; i < sections; i++) {
                        const line = new THREE.Mesh(new THREE.BoxGeometry(w - 0.02, 0.025, 0.09), lineMat);
                        line.position.y = -h/2 + i * (h / sections);
                        group.add(line);
                    }
                    // Embossed panel look - vertical lines per section
                    const panelMat = new THREE.MeshStandardMaterial({ color: hasCollision ? 0xcc4444 : 0xd0d0d0 });
                    const panelsPerRow = Math.max(2, Math.floor(w / 0.8));
                    for (let i = 1; i < panelsPerRow; i++) {
                        const vline = new THREE.Mesh(new THREE.BoxGeometry(0.015, h - 0.02, 0.085), panelMat);
                        vline.position.x = -w/2 + i * (w / panelsPerRow);
                        group.add(vline);
                    }
                    const ft = 0.06;
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w + ft*2, ft*2, 0.14), frameMat).translateY(h/2 + ft));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(ft, h + ft, 0.12), frameMat).translateX(-w/2 - ft/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(ft, h + ft, 0.12), frameMat).translateX(w/2 + ft/2));
                } else if (acc.type === 'overheadglass') {
                    // Glass sectional overhead door
                    const glassColor = hasCollision ? 0xff6666 : (isSelected ? 0xaaddff : 0x87CEEB);
                    const glassMat = new THREE.MeshStandardMaterial({ color: glassColor, roughness: 0.1, metalness: 0.7, transparent: true, opacity: 0.5 });
                    const aluminumMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.3 });
                    
                    const rows = Math.max(2, Math.floor(h / 0.6));
                    const cols = Math.max(2, Math.floor(w / 0.8));
                    const paneW = (w - 0.04 * (cols + 1)) / cols;
                    const paneH = (h - 0.04 * (rows + 1)) / rows;
                    
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            const px = -w/2 + 0.04 + paneW/2 + c * (paneW + 0.04);
                            const py = -h/2 + 0.04 + paneH/2 + r * (paneH + 0.04);
                            group.add(new THREE.Mesh(new THREE.BoxGeometry(paneW, paneH, 0.04), glassMat).translateX(px).translateY(py));
                        }
                    }
                    // Aluminum frame grid
                    for (let r = 0; r <= rows; r++) {
                        const y = -h/2 + r * (h / rows);
                        group.add(new THREE.Mesh(new THREE.BoxGeometry(w, 0.04, 0.06), aluminumMat).translateY(y));
                    }
                    for (let c = 0; c <= cols; c++) {
                        const x = -w/2 + c * (w / cols);
                        group.add(new THREE.Mesh(new THREE.BoxGeometry(0.04, h, 0.06), aluminumMat).translateX(x));
                    }
                    const ft = 0.06;
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w + ft*2, ft*2, 0.14), frameMat).translateY(h/2 + ft));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(ft, h + ft, 0.12), frameMat).translateX(-w/2 - ft/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(ft, h + ft, 0.12), frameMat).translateX(w/2 + ft/2));
                } else if (acc.type === 'barndoor') {
                    // Sliding barn door - two panels with X bracing
                    const doorColor = hasCollision ? 0xcc4444 : 0x8B4513;
                    const woodMat = new THREE.MeshStandardMaterial({ color: doorColor, roughness: 0.8 });
                    const metalMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.7 });
                    
                    const panelW = w / 2 - 0.03;
                    // Left panel
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(panelW, h, 0.1), woodMat).translateX(-w/4));
                    // Right panel  
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(panelW, h, 0.1), woodMat).translateX(w/4));
                    
                    // X bracing on each panel
                    const braceLen = Math.sqrt(panelW * panelW + h * h) * 0.95;
                    const braceAngle = Math.atan2(h, panelW);
                    const braceMat = new THREE.MeshStandardMaterial({ color: hasCollision ? 0xaa3333 : 0x654321 });
                    // Left panel X
                    const lb1 = new THREE.Mesh(new THREE.BoxGeometry(braceLen, 0.08, 0.12), braceMat);
                    lb1.rotation.z = braceAngle;
                    lb1.position.set(-w/4, 0, 0.02);
                    group.add(lb1);
                    const lb2 = new THREE.Mesh(new THREE.BoxGeometry(braceLen, 0.08, 0.12), braceMat);
                    lb2.rotation.z = -braceAngle;
                    lb2.position.set(-w/4, 0, 0.02);
                    group.add(lb2);
                    // Right panel X
                    const rb1 = new THREE.Mesh(new THREE.BoxGeometry(braceLen, 0.08, 0.12), braceMat);
                    rb1.rotation.z = braceAngle;
                    rb1.position.set(w/4, 0, 0.02);
                    group.add(rb1);
                    const rb2 = new THREE.Mesh(new THREE.BoxGeometry(braceLen, 0.08, 0.12), braceMat);
                    rb2.rotation.z = -braceAngle;
                    rb2.position.set(w/4, 0, 0.02);
                    group.add(rb2);
                    
                    // Top rail/track
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w + 0.3, 0.1, 0.15), metalMat).translateY(h/2 + 0.1));
                    // Frame
                    const ft = 0.06;
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(ft, h + ft, 0.12), frameMat).translateX(-w/2 - ft/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(ft, h + ft, 0.12), frameMat).translateX(w/2 + ft/2));
                } else if (acc.type === 'hangar') {
                    // Bi-fold hangar door
                    const panelColor = hasCollision ? 0xcc4444 : 0xdddddd;
                    const panelMat = new THREE.MeshStandardMaterial({ color: panelColor, roughness: 0.6 });
                    const metalMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.7 });
                    
                    const numPanels = Math.max(3, Math.floor(w / 3));
                    const panelW = w / numPanels;
                    
                    for (let i = 0; i < numPanels; i++) {
                        const px = -w/2 + panelW/2 + i * panelW;
                        group.add(new THREE.Mesh(new THREE.BoxGeometry(panelW - 0.05, h, 0.1), panelMat).translateX(px));
                        // Vertical stiffener on each panel
                        group.add(new THREE.Mesh(new THREE.BoxGeometry(0.08, h, 0.12), metalMat).translateX(px));
                    }
                    // Horizontal stiffeners
                    const numHoriz = Math.max(2, Math.floor(h / 1.5));
                    for (let i = 1; i < numHoriz; i++) {
                        const py = -h/2 + i * (h / numHoriz);
                        group.add(new THREE.Mesh(new THREE.BoxGeometry(w, 0.1, 0.12), metalMat).translateY(py));
                    }
                    // Top arch suggestion
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(w + 0.2, 0.15, 0.2), metalMat).translateY(h/2 + 0.1));
                    // Side frames
                    const ft = 0.1;
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(ft, h + ft, 0.15), frameMat).translateX(-w/2 - ft/2));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(ft, h + ft, 0.15), frameMat).translateX(w/2 + ft/2));
                }
                
                // Add warning icon if collision
                if (hasCollision) {
                    // Create warning triangle
                    const warnShape = new THREE.Shape();
                    const ws = 0.3;
                    warnShape.moveTo(0, ws);
                    warnShape.lineTo(-ws * 0.866, -ws * 0.5);
                    warnShape.lineTo(ws * 0.866, -ws * 0.5);
                    warnShape.closePath();
                    const warnGeom = new THREE.ShapeGeometry(warnShape);
                    const warnMat = new THREE.MeshBasicMaterial({ color: 0xffcc00, side: THREE.DoubleSide });
                    const warnMesh = new THREE.Mesh(warnGeom, warnMat);
                    warnMesh.position.set(0, h/2 + 0.4, 0.15);
                    group.add(warnMesh);
                    
                    // Exclamation mark
                    const exGeom = new THREE.BoxGeometry(0.06, 0.15, 0.02);
                    const exMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    const exMesh = new THREE.Mesh(exGeom, exMat);
                    exMesh.position.set(0, h/2 + 0.42, 0.16);
                    group.add(exMesh);
                    const dotGeom = new THREE.BoxGeometry(0.06, 0.06, 0.02);
                    const dotMesh = new THREE.Mesh(dotGeom, exMat);
                    dotMesh.position.set(0, h/2 + 0.28, 0.16);
                    group.add(dotMesh);
                }
                
                // Only windows and frameouts can have height offset, doors stay on ground
                const groundTypes = ['door', 'glassdoor', 'rollup', 'overhead', 'overheadglass', 'barndoor', 'hangar'];
                const canAdjustHeight = !groundTypes.includes(acc.type);
                const heightOffset = canAdjustHeight ? (acc.posY || 0) : 0;
                const baseY = h/2 + heightOffset;
                
                if (acc.wall === 'front') {
                    group.position.set(acc.posX || 0, baseY, L/2 + wallOffset + 0.06);
                } else if (acc.wall === 'back') {
                    group.position.set(-(acc.posX || 0), baseY, -L/2 - wallOffset - 0.06);
                    group.rotation.y = Math.PI;
                } else if (acc.wall === 'left') {
                    group.position.set(-W/2 - wallOffset - 0.06, baseY, -(acc.posX || 0));
                    group.rotation.y = -Math.PI/2;
                } else if (acc.wall === 'right') {
                    group.position.set(W/2 + wallOffset + 0.06, baseY, acc.posX || 0);
                    group.rotation.y = Math.PI/2;
                }
                // Lean-to Left walls
                else if (acc.wall === 'lt-left-side' && leanTos.left.enabled) {
                    const ltW = leanTos.left.width * S;
                    const ltL = leanTos.left.length * S;
                    const ltOffset = leanTos.left.offset * S;
                    const maxOff = (L - ltL) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    // Sidewall at X = -W/2 - ltW - wallOffset, Z centered at clampedOff
                    group.position.set(-W/2 - ltW - wallOffset - 0.06, baseY, (acc.posX || 0) + clampedOff);
                    group.rotation.y = -Math.PI/2;
                } else if (acc.wall === 'lt-left-front' && leanTos.left.enabled) {
                    const ltW = leanTos.left.width * S;
                    const ltL = leanTos.left.length * S;
                    const ltOffset = leanTos.left.offset * S;
                    const maxOff = (L - ltL) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    const ltFrontZ = ltL/2 + clampedOff;
                    // Front endwall at Z = ltFrontZ + wallOffset, X centered at -W/2 - ltW/2
                    group.position.set(-W/2 - ltW/2 + (acc.posX || 0), baseY, ltFrontZ + wallOffset + 0.06);
                } else if (acc.wall === 'lt-left-back' && leanTos.left.enabled) {
                    const ltW = leanTos.left.width * S;
                    const ltL = leanTos.left.length * S;
                    const ltOffset = leanTos.left.offset * S;
                    const maxOff = (L - ltL) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    const ltBackZ = -ltL/2 + clampedOff;
                    // Back endwall at Z = ltBackZ - wallOffset, X centered at -W/2 - ltW/2
                    group.position.set(-W/2 - ltW/2 - (acc.posX || 0), baseY, ltBackZ - wallOffset - 0.06);
                    group.rotation.y = Math.PI;
                }
                // Lean-to Right walls
                else if (acc.wall === 'lt-right-side' && leanTos.right.enabled) {
                    const ltW = leanTos.right.width * S;
                    const ltL = leanTos.right.length * S;
                    const ltOffset = leanTos.right.offset * S;
                    const maxOff = (L - ltL) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    // Sidewall at X = W/2 + ltW + wallOffset, Z centered at clampedOff
                    group.position.set(W/2 + ltW + wallOffset + 0.06, baseY, -(acc.posX || 0) + clampedOff);
                    group.rotation.y = Math.PI/2;
                } else if (acc.wall === 'lt-right-front' && leanTos.right.enabled) {
                    const ltW = leanTos.right.width * S;
                    const ltL = leanTos.right.length * S;
                    const ltOffset = leanTos.right.offset * S;
                    const maxOff = (L - ltL) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    const ltFrontZ = ltL/2 + clampedOff;
                    // Front endwall at Z = ltFrontZ + wallOffset, X centered at W/2 + ltW/2
                    group.position.set(W/2 + ltW/2 - (acc.posX || 0), baseY, ltFrontZ + wallOffset + 0.06);
                } else if (acc.wall === 'lt-right-back' && leanTos.right.enabled) {
                    const ltW = leanTos.right.width * S;
                    const ltL = leanTos.right.length * S;
                    const ltOffset = leanTos.right.offset * S;
                    const maxOff = (L - ltL) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    const ltBackZ = -ltL/2 + clampedOff;
                    // Back endwall at Z = ltBackZ - wallOffset, X centered at W/2 + ltW/2
                    group.position.set(W/2 + ltW/2 + (acc.posX || 0), baseY, ltBackZ - wallOffset - 0.06);
                    group.rotation.y = Math.PI;
                }
                // Lean-to Front walls
                else if (acc.wall === 'lt-front-front' && leanTos.front.enabled) {
                    const ltD = leanTos.front.depth * S;
                    const ltW = leanTos.front.width * S;
                    const ltOffset = leanTos.front.offset * S;
                    const maxOff = (W - ltW) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    // Front sidewall at Z = L/2 + ltD (no wallOffset in building code)
                    group.position.set((acc.posX || 0) + clampedOff, baseY, L/2 + ltD + 0.06);
                } else if (acc.wall === 'lt-front-left' && leanTos.front.enabled) {
                    const ltD = leanTos.front.depth * S;
                    const ltW = leanTos.front.width * S;
                    const ltOffset = leanTos.front.offset * S;
                    const maxOff = (W - ltW) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    const ltLeftX = clampedOff - ltW/2;
                    // Left endwall at X = ltLeftX - wallOffset
                    group.position.set(ltLeftX - wallOffset - 0.06, baseY, L/2 + ltD/2 - (acc.posX || 0));
                    group.rotation.y = -Math.PI/2;
                } else if (acc.wall === 'lt-front-right' && leanTos.front.enabled) {
                    const ltD = leanTos.front.depth * S;
                    const ltW = leanTos.front.width * S;
                    const ltOffset = leanTos.front.offset * S;
                    const maxOff = (W - ltW) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    const ltRightX = clampedOff + ltW/2;
                    // Right endwall at X = ltRightX + wallOffset
                    group.position.set(ltRightX + wallOffset + 0.06, baseY, L/2 + ltD/2 + (acc.posX || 0));
                    group.rotation.y = Math.PI/2;
                }
                // Lean-to Back walls
                else if (acc.wall === 'lt-back-back' && leanTos.back.enabled) {
                    const ltD = leanTos.back.depth * S;
                    const ltW = leanTos.back.width * S;
                    const ltOffset = leanTos.back.offset * S;
                    const maxOff = (W - ltW) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    // Back sidewall at Z = -L/2 - ltD (no wallOffset in building code)
                    group.position.set(-(acc.posX || 0) + clampedOff, baseY, -L/2 - ltD - 0.06);
                    group.rotation.y = Math.PI;
                } else if (acc.wall === 'lt-back-left' && leanTos.back.enabled) {
                    const ltD = leanTos.back.depth * S;
                    const ltW = leanTos.back.width * S;
                    const ltOffset = leanTos.back.offset * S;
                    const maxOff = (W - ltW) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    const ltLeftX = clampedOff - ltW/2;
                    // Left endwall at X = ltLeftX - wallOffset
                    group.position.set(ltLeftX - wallOffset - 0.06, baseY, -L/2 - ltD/2 + (acc.posX || 0));
                    group.rotation.y = -Math.PI/2;
                } else if (acc.wall === 'lt-back-right' && leanTos.back.enabled) {
                    const ltD = leanTos.back.depth * S;
                    const ltW = leanTos.back.width * S;
                    const ltOffset = leanTos.back.offset * S;
                    const maxOff = (W - ltW) / 2;
                    const clampedOff = Math.max(-maxOff, Math.min(maxOff, ltOffset));
                    const ltRightX = clampedOff + ltW/2;
                    // Right endwall at X = ltRightX + wallOffset
                    group.position.set(ltRightX + wallOffset + 0.06, baseY, -L/2 - ltD/2 - (acc.posX || 0));
                    group.rotation.y = Math.PI/2;
                }
                // Wrap corner walls - Left+Front
                else if (acc.wall === 'wrap-lf-side' && wrapCorners.leftFront) {
                    const ltLeftW = leanTos.left.width * S;
                    const ltFrontD = leanTos.front.depth * S;
                    // Sidewall at X = -W/2 - ltLeftW - wallOffset, Z from L/2 to L/2 + ltFrontD
                    // Wall rotated by PI/2, so accessory also rotated by PI/2
                    group.position.set(-W/2 - ltLeftW - wallOffset - 0.06, baseY, L/2 + ltFrontD/2 + (acc.posX || 0));
                    group.rotation.y = Math.PI/2;
                } else if (acc.wall === 'wrap-lf-front' && wrapCorners.leftFront) {
                    const ltLeftW = leanTos.left.width * S;
                    const ltFrontD = leanTos.front.depth * S;
                    // Front wall at Z = L/2 + ltFrontD + wallOffset, X from -W/2 to -W/2 - ltLeftW
                    group.position.set(-W/2 - ltLeftW/2 + (acc.posX || 0), baseY, L/2 + ltFrontD + wallOffset + 0.06);
                }
                // Wrap corner walls - Right+Front
                else if (acc.wall === 'wrap-rf-side' && wrapCorners.rightFront) {
                    const ltRightW = leanTos.right.width * S;
                    const ltFrontD = leanTos.front.depth * S;
                    // Sidewall at X = W/2 + ltRightW + wallOffset, Z from L/2 to L/2 + ltFrontD
                    // Wall rotated by -PI/2, so accessory also rotated by -PI/2
                    group.position.set(W/2 + ltRightW + wallOffset + 0.06, baseY, L/2 + ltFrontD/2 - (acc.posX || 0));
                    group.rotation.y = -Math.PI/2;
                } else if (acc.wall === 'wrap-rf-front' && wrapCorners.rightFront) {
                    const ltRightW = leanTos.right.width * S;
                    const ltFrontD = leanTos.front.depth * S;
                    // Front wall at Z = L/2 + ltFrontD + wallOffset, X from W/2 to W/2 + ltRightW
                    group.position.set(W/2 + ltRightW/2 - (acc.posX || 0), baseY, L/2 + ltFrontD + wallOffset + 0.06);
                }
                // Wrap corner walls - Left+Back
                else if (acc.wall === 'wrap-lb-side' && wrapCorners.leftBack) {
                    const ltLeftW = leanTos.left.width * S;
                    const ltBackD = leanTos.back.depth * S;
                    // Sidewall at X = -W/2 - ltLeftW - wallOffset, Z from -L/2 to -L/2 - ltBackD
                    // Wall rotated by PI/2, so accessory also rotated by PI/2
                    group.position.set(-W/2 - ltLeftW - wallOffset - 0.06, baseY, -L/2 - ltBackD/2 - (acc.posX || 0));
                    group.rotation.y = Math.PI/2;
                } else if (acc.wall === 'wrap-lb-back' && wrapCorners.leftBack) {
                    const ltLeftW = leanTos.left.width * S;
                    const ltBackD = leanTos.back.depth * S;
                    // Back wall at Z = -L/2 - ltBackD - wallOffset, X from -W/2 to -W/2 - ltLeftW
                    group.position.set(-W/2 - ltLeftW/2 - (acc.posX || 0), baseY, -L/2 - ltBackD - wallOffset - 0.06);
                    group.rotation.y = Math.PI;
                }
                // Wrap corner walls - Right+Back
                else if (acc.wall === 'wrap-rb-side' && wrapCorners.rightBack) {
                    const ltRightW = leanTos.right.width * S;
                    const ltBackD = leanTos.back.depth * S;
                    // Sidewall at X = W/2 + ltRightW + wallOffset, Z from -L/2 to -L/2 - ltBackD
                    // Wall rotated by -PI/2, so accessory also rotated by -PI/2
                    group.position.set(W/2 + ltRightW + wallOffset + 0.06, baseY, -L/2 - ltBackD/2 + (acc.posX || 0));
                    group.rotation.y = -Math.PI/2;
                } else if (acc.wall === 'wrap-rb-back' && wrapCorners.rightBack) {
                    const ltRightW = leanTos.right.width * S;
                    const ltBackD = leanTos.back.depth * S;
                    // Back wall at Z = -L/2 - ltBackD - wallOffset, X from W/2 to W/2 + ltRightW
                    group.position.set(W/2 + ltRightW/2 + (acc.posX || 0), baseY, -L/2 - ltBackD - wallOffset - 0.06);
                    group.rotation.y = Math.PI;
                }
                
                scene.add(group);
                accessoryMeshes.push(group);
            });
            
            // Update overlay position if accessory is selected
            updateAccessoryOverlay();
        }
        
        // Calculate distances for an accessory to walls and other accessories
        function calculateAccessoryDistances(acc) {
            const S = 1/3;
            const wallData = getWallDimensions(acc.wall);
            if (!wallData) return null;
            
            const accWidth = acc.width;
            const accPosX = acc.posXft || 0;
            const halfWidth = accWidth / 2;
            
            // Distance to left and right wall edges
            const leftEdge = -wallData.halfRange;
            const rightEdge = wallData.halfRange;
            const distToLeftWall = (accPosX - halfWidth) - leftEdge;
            const distToRightWall = rightEdge - (accPosX + halfWidth);
            
            // Find nearest accessory on same wall
            let nearestDist = null;
            let nearestLabel = null;
            
            accessories.forEach(other => {
                if (other.id === acc.id || other.wall !== acc.wall) return;
                
                const otherPosX = other.posXft || 0;
                const otherHalfWidth = other.width / 2;
                
                // Calculate edge-to-edge distance
                const accLeft = accPosX - halfWidth;
                const accRight = accPosX + halfWidth;
                const otherLeft = otherPosX - otherHalfWidth;
                const otherRight = otherPosX + otherHalfWidth;
                
                let dist;
                if (accRight < otherLeft) {
                    dist = otherLeft - accRight;
                } else if (otherRight < accLeft) {
                    dist = accLeft - otherRight;
                } else {
                    dist = 0; // Overlapping
                }
                
                if (nearestDist === null || dist < nearestDist) {
                    nearestDist = dist;
                    nearestLabel = other.label || other.type;
                }
            });
            
            return {
                leftWall: distToLeftWall,
                rightWall: distToRightWall,
                nearestItem: nearestDist,
                nearestLabel: nearestLabel
            };
        }
        
        // Get wall dimensions for distance calculations
        function getWallDimensions(wallName) {
            const S = 1/3;
            let wallLength;
            
            if (wallName === 'front' || wallName === 'back') {
                wallLength = params.width;
            } else if (wallName === 'left' || wallName === 'right') {
                wallLength = params.length;
            } else if (wallName.startsWith('lt-left-') || wallName.startsWith('lt-right-')) {
                if (wallName.includes('-side')) {
                    wallLength = wallName.includes('left') ? leanTos.left.length : leanTos.right.length;
                } else {
                    wallLength = wallName.includes('left') ? leanTos.left.width : leanTos.right.width;
                }
            } else if (wallName.startsWith('lt-front-') || wallName.startsWith('lt-back-')) {
                if (wallName.includes('-front') || wallName.includes('-back')) {
                    wallLength = wallName.includes('front') ? leanTos.front.width : leanTos.back.width;
                } else {
                    wallLength = wallName.includes('front') ? leanTos.front.depth : leanTos.back.depth;
                }
            } else if (wallName.startsWith('wrap-')) {
                // Wrap corners
                if (wallName === 'wrap-lf-side') wallLength = leanTos.front.depth;
                else if (wallName === 'wrap-lf-front') wallLength = leanTos.left.width;
                else if (wallName === 'wrap-rf-side') wallLength = leanTos.front.depth;
                else if (wallName === 'wrap-rf-front') wallLength = leanTos.right.width;
                else if (wallName === 'wrap-lb-side') wallLength = leanTos.back.depth;
                else if (wallName === 'wrap-lb-back') wallLength = leanTos.left.width;
                else if (wallName === 'wrap-rb-side') wallLength = leanTos.back.depth;
                else if (wallName === 'wrap-rb-back') wallLength = leanTos.right.width;
                else return null;
            } else {
                return null;
            }
            
            return { halfRange: wallLength / 2 };
        }
        
        // Update accessory overlay position and content
        function updateAccessoryOverlay() {
            const overlay = document.getElementById('accessory-overlay');
            
            if (selectedAccessoryId === null) {
                overlay.classList.remove('visible');
                return;
            }
            
            const acc = accessories.find(a => a.id === selectedAccessoryId);
            if (!acc) {
                overlay.classList.remove('visible');
                return;
            }
            
            // Find the 3D mesh for this accessory
            const mesh = accessoryMeshes.find(m => m.userData.accessoryId === selectedAccessoryId);
            if (!mesh) {
                overlay.classList.remove('visible');
                return;
            }
            
            // Project 3D position to screen
            const vector = new THREE.Vector3();
            mesh.getWorldPosition(vector);
            vector.y += 0.5; // Offset above the accessory
            vector.project(camera);
            
            const rect = renderer.domElement.getBoundingClientRect();
            const x = (vector.x * 0.5 + 0.5) * rect.width + rect.left;
            const y = (-vector.y * 0.5 + 0.5) * rect.height + rect.top;
            
            // Position overlay
            overlay.style.left = (x - 90) + 'px';
            overlay.style.top = (y - 150) + 'px';
            
            // Update content
            document.getElementById('overlay-title').textContent = acc.label || acc.type;
            document.getElementById('overlay-position').textContent = (acc.posXft || 0).toFixed(1) + ' ft';
            
            // Calculate distances
            const distances = calculateAccessoryDistances(acc);
            if (distances) {
                document.getElementById('overlay-left-dist').textContent = distances.leftWall.toFixed(1) + ' ft';
                document.getElementById('overlay-right-dist').textContent = distances.rightWall.toFixed(1) + ' ft';
                
                if (distances.nearestItem !== null) {
                    const nearestEl = document.getElementById('overlay-nearest');
                    nearestEl.textContent = distances.nearestItem.toFixed(1) + ' ft';
                    nearestEl.className = distances.nearestItem < 0.5 ? 'value warning' : 'value';
                } else {
                    document.getElementById('overlay-nearest').textContent = '--';
                }
            }
            
            overlay.classList.add('visible');
        }
        
        // Hide overlay when deselecting
        function hideAccessoryOverlay() {
            document.getElementById('accessory-overlay').classList.remove('visible');
        }
        
        function updateLeantoWallSelector() {
            const selector = document.getElementById('leanto-wall-selector');
            selector.innerHTML = '';
            
            const leantoWalls = [];
            if (leanTos.left.enabled) {
                leantoWalls.push({ wall: 'lt-left-side', label: 'LT Left Side' });
                leantoWalls.push({ wall: 'lt-left-front', label: 'LT Left Front' });
                leantoWalls.push({ wall: 'lt-left-back', label: 'LT Left Back' });
            }
            if (leanTos.right.enabled) {
                leantoWalls.push({ wall: 'lt-right-side', label: 'LT Right Side' });
                leantoWalls.push({ wall: 'lt-right-front', label: 'LT Right Front' });
                leantoWalls.push({ wall: 'lt-right-back', label: 'LT Right Back' });
            }
            if (leanTos.front.enabled) {
                leantoWalls.push({ wall: 'lt-front-front', label: 'LT Front Side' });
                leantoWalls.push({ wall: 'lt-front-left', label: 'LT Front Left' });
                leantoWalls.push({ wall: 'lt-front-right', label: 'LT Front Right' });
            }
            if (leanTos.back.enabled) {
                leantoWalls.push({ wall: 'lt-back-back', label: 'LT Back Side' });
                leantoWalls.push({ wall: 'lt-back-left', label: 'LT Back Left' });
                leantoWalls.push({ wall: 'lt-back-right', label: 'LT Back Right' });
            }
            
            // Add wrap corner walls
            if (wrapCorners.leftFront && leanTos.left.enabled && leanTos.front.enabled) {
                leantoWalls.push({ wall: 'wrap-lf-side', label: 'Wrap LF Side' });
                leantoWalls.push({ wall: 'wrap-lf-front', label: 'Wrap LF Front' });
            }
            if (wrapCorners.rightFront && leanTos.right.enabled && leanTos.front.enabled) {
                leantoWalls.push({ wall: 'wrap-rf-side', label: 'Wrap RF Side' });
                leantoWalls.push({ wall: 'wrap-rf-front', label: 'Wrap RF Front' });
            }
            if (wrapCorners.leftBack && leanTos.left.enabled && leanTos.back.enabled) {
                leantoWalls.push({ wall: 'wrap-lb-side', label: 'Wrap LB Side' });
                leantoWalls.push({ wall: 'wrap-lb-back', label: 'Wrap LB Back' });
            }
            if (wrapCorners.rightBack && leanTos.right.enabled && leanTos.back.enabled) {
                leantoWalls.push({ wall: 'wrap-rb-side', label: 'Wrap RB Side' });
                leantoWalls.push({ wall: 'wrap-rb-back', label: 'Wrap RB Back' });
            }
            
            if (leantoWalls.length > 0) {
                selector.style.display = 'grid';
                leantoWalls.forEach(lw => {
                    const btn = document.createElement('div');
                    btn.className = 'wall-btn';
                    btn.dataset.wall = lw.wall;
                    btn.textContent = lw.label;
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.wall-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        selectedWall = btn.dataset.wall;
                        // Rotate camera to face selected wall
                        rotateCameraToWall(selectedWall);
                        // Update accessories list to highlight items on this wall
                        updateAccessoriesList();
                    });
                    selector.appendChild(btn);
                });
            } else {
                selector.style.display = 'none';
            }
        }
        
        function updateWrapCornersUI() {
            const section = document.getElementById('wrap-corners-section');
            const grid = document.getElementById('wrap-corners-grid');
            grid.innerHTML = '';
            
            // Define corner combinations
            const corners = [
                { id: 'leftFront', label: 'Left + Front', side1: 'left', side2: 'front', sw: 'leftFrontSidewall', fw: 'leftFrontFrontwall' },
                { id: 'rightFront', label: 'Right + Front', side1: 'right', side2: 'front', sw: 'rightFrontSidewall', fw: 'rightFrontFrontwall' },
                { id: 'leftBack', label: 'Left + Back', side1: 'left', side2: 'back', sw: 'leftBackSidewall', fw: 'leftBackBackwall' },
                { id: 'rightBack', label: 'Right + Back', side1: 'right', side2: 'back', sw: 'rightBackSidewall', fw: 'rightBackBackwall' }
            ];
            
            let hasAnyCorner = false;
            
            corners.forEach(corner => {
                const lt1 = leanTos[corner.side1];
                const lt2 = leanTos[corner.side2];
                
                // Check if both lean-tos are enabled
                if (!lt1.enabled || !lt2.enabled) return;
                
                hasAnyCorner = true;
                
                // Check if pitch and height match
                const canWrap = lt1.pitch === lt2.pitch && lt1.height === lt2.height;
                const isWrapped = wrapCorners[corner.id];
                
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.flexDirection = 'column';
                container.style.gap = '4px';
                
                const btn = document.createElement('div');
                btn.className = 'wrap-corner-btn' + (isWrapped ? ' active' : '') + (!canWrap ? ' disabled' : '');
                btn.innerHTML = `${corner.label}<span class="corner-status">${canWrap ? (isWrapped ? 'Connected' : 'Click to connect') : 'Pitch/Height mismatch'}</span>`;
                
                if (canWrap) {
                    btn.addEventListener('click', () => {
                        wrapCorners[corner.id] = !wrapCorners[corner.id];
                        updateWrapCornersUI();
                        createBuilding();
                    });
                }
                
                container.appendChild(btn);
                
                // Add wall visibility toggles when corner is wrapped
                if (isWrapped) {
                    const wallControls = document.createElement('div');
                    wallControls.style.cssText = 'display:flex;gap:4px;font-size:9px;';
                    
                    const swBtn = document.createElement('button');
                    swBtn.style.cssText = 'flex:1;padding:3px;background:' + (wrapCorners[corner.sw] ? '#333' : '#111') + ';border:1px solid ' + (wrapCorners[corner.sw] ? '#ffb432' : '#444') + ';color:' + (wrapCorners[corner.sw] ? '#ffb432' : '#888') + ';border-radius:3px;cursor:pointer;';
                    swBtn.textContent = 'Side Wall';
                    swBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        wrapCorners[corner.sw] = !wrapCorners[corner.sw];
                        updateWrapCornersUI();
                        createBuilding();
                    });
                    
                    const fwBtn = document.createElement('button');
                    const fwLabel = corner.side2 === 'front' ? 'Front Wall' : 'Back Wall';
                    fwBtn.style.cssText = 'flex:1;padding:3px;background:' + (wrapCorners[corner.fw] ? '#333' : '#111') + ';border:1px solid ' + (wrapCorners[corner.fw] ? '#ffb432' : '#444') + ';color:' + (wrapCorners[corner.fw] ? '#ffb432' : '#888') + ';border-radius:3px;cursor:pointer;';
                    fwBtn.textContent = fwLabel;
                    fwBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        wrapCorners[corner.fw] = !wrapCorners[corner.fw];
                        updateWrapCornersUI();
                        createBuilding();
                    });
                    
                    wallControls.appendChild(swBtn);
                    wallControls.appendChild(fwBtn);
                    container.appendChild(wallControls);
                }
                
                grid.appendChild(container);
            });
            
            section.style.display = hasAnyCorner ? 'block' : 'none';
        }
        
        function setupAccessoryControls() {
            document.querySelectorAll('#wall-selector .wall-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.wall-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    selectedWall = btn.dataset.wall;
                    // Rotate camera to face selected wall
                    rotateCameraToWall(selectedWall);
                    // Update accessories list to highlight items on this wall
                    updateAccessoriesList();
                });
            });
            
            document.querySelectorAll('.accessory-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.accessory-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    selectedAccessory = btn.dataset.type;
                    
                    document.getElementById('size-selector').style.display = 'block';
                    const select = document.getElementById('accessory-size');
                    select.innerHTML = '';
                    accessorySizes[selectedAccessory].forEach((size, i) => {
                        const opt = document.createElement('option');
                        opt.value = i;
                        opt.textContent = size.label;
                        select.appendChild(opt);
                    });
                    // Hide custom inputs initially
                    document.getElementById('custom-size-inputs').classList.remove('visible');
                    document.getElementById('add-accessory-btn').disabled = false;
                });
            });
            
            // Handle size selection change for custom option
            document.getElementById('accessory-size').addEventListener('change', (e) => {
                const size = accessorySizes[selectedAccessory][e.target.value];
                const customInputs = document.getElementById('custom-size-inputs');
                if (size && size.custom) {
                    customInputs.classList.add('visible');
                } else {
                    customInputs.classList.remove('visible');
                }
            });
            
            document.getElementById('add-accessory-btn').addEventListener('click', () => {
                if (!selectedAccessory) return;
                const size = accessorySizes[selectedAccessory][document.getElementById('accessory-size').value];
                
                let width, height, label;
                if (size.custom) {
                    width = parseFloat(document.getElementById('custom-width').value) || 4;
                    height = parseFloat(document.getElementById('custom-height').value) || 4;
                    label = `${width}' x ${height}' Frameout`;
                } else {
                    width = size.width;
                    height = size.height;
                    label = size.label;
                }
                
                accessories.push({ 
                    id: accessoryIdCounter++, 
                    type: selectedAccessory, 
                    wall: selectedWall, 
                    width: width, 
                    height: height, 
                    label: label, 
                    posX: 0,
                    posY: 0,
                    posXft: 0,
                    posYft: 0
                });
                updateAccessoriesList();
                if (selectedAccessory === 'frameout') {
                    createBuilding();
                } else {
                    rebuildAccessories();
                }
            });
        }
        
        function checkFramingCollision(acc) {
            const S = 1/3;
            const W = params.width * S;
            const L = params.length * S;
            const frameInset = 0.15;
            const colW = 0.35; // Column width
            const accW = acc.width * S;
            
            // Check sidewalls (left/right and wrap corner sidewalls) for side bay column collisions
            const isMainSidewall = acc.wall === 'left' || acc.wall === 'right';
            const isWrapSidewall = acc.wall === 'wrap-lf-side' || acc.wall === 'wrap-rf-side' || 
                                   acc.wall === 'wrap-lb-side' || acc.wall === 'wrap-rb-side';
            
            if (isMainSidewall || isWrapSidewall) {
                const numBays = Math.max(1, Math.floor(params.length / params.baySpacing));
                
                // Check each column position
                for (let i = 0; i <= numBays; i++) {
                    const colZ = -L/2 + frameInset + i * (L - frameInset * 2) / numBays;
                    const colLeft = colZ - colW/2;
                    const colRight = colZ + colW/2;
                    
                    // For left/right walls, accessory posX corresponds to Z position (but may be negated)
                    const accPos = acc.wall === 'left' ? -(acc.posX || 0) : (acc.posX || 0);
                    const accL = accPos - accW/2;
                    const accR = accPos + accW/2;
                    
                    if (accR > colLeft && accL < colRight) {
                        const colPosFt = ((colZ + L/2) / S).toFixed(0);
                        return `Conflicts with column at ${colPosFt}' from back`;
                    }
                }
                return null;
            }
            
            // Check front/back walls for front/back bay column collisions
            const isMainEndwall = acc.wall === 'front' || acc.wall === 'back';
            const isWrapEndwall = acc.wall === 'wrap-lf-front' || acc.wall === 'wrap-rf-front' || 
                                  acc.wall === 'wrap-lb-back' || acc.wall === 'wrap-rb-back';
            
            if ((isMainEndwall || isWrapEndwall) && params.showFrontBackBays) {
                const numFrontBackBays = Math.max(1, Math.floor(params.width / params.frontBackBaySpacing));
                const frontBackBayWidth = W / numFrontBackBays;
                
                // Check each column position (columns are at bay divisions, not at edges)
                for (let i = 1; i < numFrontBackBays; i++) {
                    const colX = -W/2 + i * frontBackBayWidth;
                    const colLeft = colX - colW/2;
                    const colRight = colX + colW/2;
                    
                    // For front/back walls, accessory posX corresponds to X position (may be negated for back)
                    const accPos = acc.wall === 'back' ? -(acc.posX || 0) : (acc.posX || 0);
                    const accL = accPos - accW/2;
                    const accR = accPos + accW/2;
                    
                    if (accR > colLeft && accL < colRight) {
                        const colPosFt = ((colX + W/2) / S).toFixed(0);
                        return `Conflicts with column at ${colPosFt}' from left`;
                    }
                }
                return null;
            }
            
            return null;
        }
        
        function updateAccessoriesList() {
            const list = document.getElementById('accessories-list');
            list.innerHTML = '';
            const S = 1/3;
            
            // Helper to get wall display name
            function getWallDisplayName(wall) {
                const names = {
                    'front': 'Front', 'back': 'Back', 'left': 'Left', 'right': 'Right',
                    'lt-left-side': 'LT Left Side', 'lt-left-front': 'LT Left Front', 'lt-left-back': 'LT Left Back',
                    'lt-right-side': 'LT Right Side', 'lt-right-front': 'LT Right Front', 'lt-right-back': 'LT Right Back',
                    'lt-front-front': 'LT Front Side', 'lt-front-left': 'LT Front Left', 'lt-front-right': 'LT Front Right',
                    'lt-back-back': 'LT Back Side', 'lt-back-left': 'LT Back Left', 'lt-back-right': 'LT Back Right',
                    'wrap-lf-side': 'Wrap LF Side', 'wrap-lf-front': 'Wrap LF Front',
                    'wrap-rf-side': 'Wrap RF Side', 'wrap-rf-front': 'Wrap RF Front',
                    'wrap-lb-side': 'Wrap LB Side', 'wrap-lb-back': 'Wrap LB Back',
                    'wrap-rb-side': 'Wrap RB Side', 'wrap-rb-back': 'Wrap RB Back'
                };
                return names[wall] || wall;
            }
            
            // Helper to get wall dimensions
            function getWallDimensions(wall) {
                if (wall === 'front' || wall === 'back') return { width: params.width, height: params.height };
                if (wall === 'left' || wall === 'right') return { width: params.length, height: params.height };
                if (wall === 'lt-left-side') return { width: leanTos.left.length, height: leanTos.left.height };
                if (wall === 'lt-left-front' || wall === 'lt-left-back') return { width: leanTos.left.width, height: leanTos.left.height };
                if (wall === 'lt-right-side') return { width: leanTos.right.length, height: leanTos.right.height };
                if (wall === 'lt-right-front' || wall === 'lt-right-back') return { width: leanTos.right.width, height: leanTos.right.height };
                if (wall === 'lt-front-front') return { width: leanTos.front.width, height: leanTos.front.height };
                if (wall === 'lt-front-left' || wall === 'lt-front-right') return { width: leanTos.front.depth, height: leanTos.front.height };
                if (wall === 'lt-back-back') return { width: leanTos.back.width, height: leanTos.back.height };
                if (wall === 'lt-back-left' || wall === 'lt-back-right') return { width: leanTos.back.depth, height: leanTos.back.height };
                // Wrap corner walls
                if (wall === 'wrap-lf-side') return { width: leanTos.front.depth, height: leanTos.left.height };
                if (wall === 'wrap-lf-front') return { width: leanTos.left.width, height: leanTos.left.height };
                if (wall === 'wrap-rf-side') return { width: leanTos.front.depth, height: leanTos.right.height };
                if (wall === 'wrap-rf-front') return { width: leanTos.right.width, height: leanTos.right.height };
                if (wall === 'wrap-lb-side') return { width: leanTos.back.depth, height: leanTos.left.height };
                if (wall === 'wrap-lb-back') return { width: leanTos.left.width, height: leanTos.left.height };
                if (wall === 'wrap-rb-side') return { width: leanTos.back.depth, height: leanTos.right.height };
                if (wall === 'wrap-rb-back') return { width: leanTos.right.width, height: leanTos.right.height };
                return { width: params.width, height: params.height };
            }
            
            // Filter accessories by selected wall first, then show others
            const wallAccessories = accessories.filter(a => a.wall === selectedWall);
            const otherAccessories = accessories.filter(a => a.wall !== selectedWall);
            
            // Show/hide center button based on accessories count on selected wall
            const centerBtn = document.getElementById('center-all-btn');
            if (centerBtn) {
                centerBtn.style.display = wallAccessories.length >= 2 ? 'block' : 'none';
            }
            
            // Show current wall section if there are accessories
            if (wallAccessories.length > 0) {
                const header = document.createElement('div');
                header.style.cssText = 'font-family: Oswald; font-size: 11px; color: #ffb432; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,180,50,0.3);';
                header.textContent = `${getWallDisplayName(selectedWall)} Wall (${wallAccessories.length})`;
                list.appendChild(header);
            }
            
            // Render accessories on selected wall first
            [...wallAccessories, ...otherAccessories].forEach((acc, index) => {
                // Add separator before other walls
                if (index === wallAccessories.length && otherAccessories.length > 0) {
                    const separator = document.createElement('div');
                    separator.style.cssText = 'font-family: Oswald; font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 1px; margin: 12px 0 8px 0; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.1);';
                    separator.textContent = 'Other Walls';
                    list.appendChild(separator);
                }
                
                const dims = getWallDimensions(acc.wall);
                const wallWidth = dims.width;
                const maxH = dims.height - acc.height;
                const accW = acc.width;
                const halfRange = (wallWidth - accW) / 2;
                const isSelected = selectedAccessoryId === acc.id;
                const isOnSelectedWall = acc.wall === selectedWall;
                
                // Windows and frameouts can adjust height
                const showHeight = acc.type === 'window' || acc.type === 'frameout';
                
                // Check for framing collision
                const collision = checkFramingCollision(acc);
                
                const item = document.createElement('div');
                item.className = 'accessory-item' + (isSelected ? ' selected' : '');
                // Dim items not on selected wall
                if (!isOnSelectedWall) {
                    item.style.opacity = '0.6';
                }
                item.innerHTML = `
                    <div class="accessory-header">
                        <span>${isOnSelectedWall ? '' : getWallDisplayName(acc.wall) + ': '}${acc.label}</span>
                        <div class="accessory-buttons">
                            <button class="duplicate-btn" data-id="${acc.id}" title="Duplicate">⧉</button>
                            <button class="remove-btn" data-id="${acc.id}" title="Remove">×</button>
                        </div>
                    </div>
                    <div class="position-controls">
                        <div class="position-control" style="${showHeight ? '' : 'grid-column: span 2;'}">
                            <label>Position <input type="number" class="position-input" id="pos-input-${acc.id}" value="${(acc.posXft || 0).toFixed(1)}" step="0.5" min="${-halfRange}" max="${halfRange}"> ft</label>
                            <input type="range" id="pos-x-${acc.id}" min="${-halfRange}" max="${halfRange}" step="0.5" value="${acc.posXft || 0}">
                        </div>
                        ${showHeight ? `
                        <div class="position-control">
                            <label>Height <input type="number" class="position-input" id="height-input-${acc.id}" value="${(acc.posYft || 0).toFixed(1)}" step="0.5" min="0" max="${maxH}"> ft</label>
                            <input type="range" id="pos-y-${acc.id}" min="0" max="${maxH}" step="0.5" value="${acc.posYft || 0}">
                        </div>
                        ` : ''}
                    </div>
                    ${collision ? `<div class="accessory-warning">${collision}</div>` : ''}
                `;
                list.appendChild(item);
                
                // Click to select
                item.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('remove-btn') && !e.target.classList.contains('duplicate-btn') && e.target.tagName !== 'INPUT') {
                        selectedAccessoryId = acc.id;
                        
                        // Update selected wall (but don't rotate camera)
                        selectedWall = acc.wall;
                        document.querySelectorAll('.wall-btn').forEach(b => {
                            b.classList.toggle('active', b.dataset.wall === acc.wall);
                        });
                        
                        updateAccessoriesList();
                        if (acc.type === 'frameout') {
                            createBuilding();
                        } else {
                            rebuildAccessories();
                        }
                    }
                });
                
                // Position X slider
                document.getElementById(`pos-x-${acc.id}`).addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    acc.posXft = val;
                    acc.posX = val * S;
                    document.getElementById(`pos-input-${acc.id}`).value = val.toFixed(1);
                    if (acc.type === 'frameout') {
                        createBuilding();
                    } else {
                        rebuildAccessories();
                    }
                });
                
                // Position X input field
                document.getElementById(`pos-input-${acc.id}`).addEventListener('change', (e) => {
                    let val = parseFloat(e.target.value) || 0;
                    val = Math.max(-halfRange, Math.min(halfRange, val)); // Clamp to range
                    acc.posXft = val;
                    acc.posX = val * S;
                    e.target.value = val.toFixed(1);
                    document.getElementById(`pos-x-${acc.id}`).value = val;
                    if (acc.type === 'frameout') {
                        createBuilding();
                    } else {
                        rebuildAccessories();
                    }
                });
                
                // Prevent click from propagating to item selection
                document.getElementById(`pos-input-${acc.id}`).addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                // Position Y slider (for windows and frameouts)
                if (showHeight) {
                    document.getElementById(`pos-y-${acc.id}`).addEventListener('input', (e) => {
                        const val = parseFloat(e.target.value);
                        acc.posYft = val;
                        acc.posY = val * S;
                        document.getElementById(`height-input-${acc.id}`).value = val.toFixed(1);
                        if (acc.type === 'frameout') {
                            createBuilding();
                        } else {
                            rebuildAccessories();
                        }
                    });
                    
                    // Height input field
                    document.getElementById(`height-input-${acc.id}`).addEventListener('change', (e) => {
                        let val = parseFloat(e.target.value) || 0;
                        val = Math.max(0, Math.min(maxH, val)); // Clamp to range
                        acc.posYft = val;
                        acc.posY = val * S;
                        e.target.value = val.toFixed(1);
                        document.getElementById(`pos-y-${acc.id}`).value = val;
                        if (acc.type === 'frameout') {
                            createBuilding();
                        } else {
                            rebuildAccessories();
                        }
                    });
                    
                    // Prevent click from propagating to item selection
                    document.getElementById(`height-input-${acc.id}`).addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                }
            });
            
            document.querySelectorAll('.duplicate-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const id = parseInt(btn.dataset.id);
                    const acc = accessories.find(a => a.id === id);
                    if (acc) {
                        const S = 1/3;
                        // Create duplicate with slight offset
                        const newAcc = {
                            id: accessoryIdCounter++,
                            type: acc.type,
                            wall: acc.wall,
                            width: acc.width,
                            height: acc.height,
                            label: acc.label,
                            posX: (acc.posX || 0) + 1 * S,
                            posY: acc.posY || 0,
                            posXft: (acc.posXft || 0) + 1,
                            posYft: acc.posYft || 0
                        };
                        accessories.push(newAcc);
                        selectedAccessoryId = newAcc.id;
                        updateAccessoriesList();
                        if (acc.type === 'frameout') {
                            createBuilding();
                        } else {
                            rebuildAccessories();
                        }
                    }
                });
            });
            
            document.querySelectorAll('.remove-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const id = parseInt(btn.dataset.id);
                    const acc = accessories.find(a => a.id === id);
                    const isFrameout = acc && acc.type === 'frameout';
                    if (selectedAccessoryId === id) selectedAccessoryId = null;
                    accessories = accessories.filter(a => a.id !== id);
                    updateAccessoriesList();
                    if (isFrameout) {
                        createBuilding();
                    } else {
                        rebuildAccessories();
                    }
                });
            });
        }
        
        let dragging = false, panning = false, lastMouse = { x: 0, y: 0 };
        let orbit = { theta: 0.6, phi: 1.1, radius: 100 };
        let target = new THREE.Vector3(0, 4, 0);
        
        function setupControls() {
            const c = renderer.domElement;
            let touchStartDistance = 0;
            let lastTouch = null;
            let touchCount = 0;
            
            function getMousePos(e) {
                const rect = c.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            }
            
            function getTouchPos(touch) {
                const rect = c.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
            }
            
            function getIntersectedAccessory(clientX, clientY) {
                const rect = c.getBoundingClientRect();
                mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                
                for (let group of accessoryMeshes) {
                    const meshes = [];
                    group.traverse(child => { if (child.isMesh) meshes.push(child); });
                    const intersects = raycaster.intersectObjects(meshes);
                    if (intersects.length > 0) {
                        return group.userData.accessoryId;
                    }
                }
                return null;
            }
            
            // Mouse events
            c.addEventListener('mousedown', e => {
                if (e.button === 0) {
                    const clickedId = getIntersectedAccessory(e.clientX, e.clientY);
                    if (clickedId !== null) {
                        selectedAccessoryId = clickedId;
                        isDraggingAccessory = true;
                        
                        // Find the accessory and update wall selector (but don't rotate camera)
                        const acc = accessories.find(a => a.id === clickedId);
                        if (acc) {
                            // Update selected wall and wall selector UI
                            selectedWall = acc.wall;
                            document.querySelectorAll('.wall-btn').forEach(b => {
                                b.classList.toggle('active', b.dataset.wall === acc.wall);
                            });
                        }
                        
                        updateAccessoriesList();
                        rebuildAccessories();
                    } else {
                        if (selectedAccessoryId !== null) {
                            selectedAccessoryId = null;
                            hideAccessoryOverlay();
                            updateAccessoriesList();
                            rebuildAccessories();
                        }
                        dragging = true;
                    }
                }
                if (e.button === 2) panning = true;
                lastMouse = { x: e.clientX, y: e.clientY };
            });
            
            c.addEventListener('mouseup', () => { 
                dragging = false; 
                panning = false; 
                isDraggingAccessory = false;
            });
            c.addEventListener('mouseleave', () => { 
                dragging = false; 
                panning = false; 
                isDraggingAccessory = false;
            });
            
            c.addEventListener('mousemove', e => {
                const dx = e.clientX - lastMouse.x;
                const dy = e.clientY - lastMouse.y;
                
                if (isDraggingAccessory && selectedAccessoryId !== null) {
                    handleAccessoryDrag(dx, dy);
                } else if (dragging) { 
                    orbit.theta -= dx * 0.005; 
                    orbit.phi = Math.max(0.2, Math.min(Math.PI - 0.2, orbit.phi - dy * 0.005)); 
                }
                
                if (panning) { 
                    target.x -= dx * 0.05; 
                    target.y += dy * 0.05; 
                }
                
                lastMouse = { x: e.clientX, y: e.clientY };
                updateCam();
                
                if (!dragging && !panning && !isDraggingAccessory) {
                    const hoverId = getIntersectedAccessory(e.clientX, e.clientY);
                    c.style.cursor = hoverId !== null ? 'pointer' : 'grab';
                }
            });
            
            // Touch events
            c.addEventListener('touchstart', e => {
                e.preventDefault();
                touchCount = e.touches.length;
                
                if (touchCount === 1) {
                    const touch = e.touches[0];
                    const clickedId = getIntersectedAccessory(touch.clientX, touch.clientY);
                    if (clickedId !== null) {
                        selectedAccessoryId = clickedId;
                        isDraggingAccessory = true;
                        
                        // Find the accessory and update wall selector (but don't rotate camera)
                        const acc = accessories.find(a => a.id === clickedId);
                        if (acc) {
                            selectedWall = acc.wall;
                            document.querySelectorAll('.wall-btn').forEach(b => {
                                b.classList.toggle('active', b.dataset.wall === acc.wall);
                            });
                        }
                        
                        updateAccessoriesList();
                        rebuildAccessories();
                    } else {
                        if (selectedAccessoryId !== null) {
                            selectedAccessoryId = null;
                            hideAccessoryOverlay();
                            updateAccessoriesList();
                            rebuildAccessories();
                        }
                        dragging = true;
                    }
                    lastTouch = { x: touch.clientX, y: touch.clientY };
                } else if (touchCount === 2) {
                    dragging = false;
                    isDraggingAccessory = false;
                    panning = true;
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                    lastTouch = {
                        x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                        y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                    };
                }
            }, { passive: false });
            
            c.addEventListener('touchmove', e => {
                e.preventDefault();
                
                if (e.touches.length === 1 && (dragging || isDraggingAccessory)) {
                    const touch = e.touches[0];
                    const dx = touch.clientX - lastTouch.x;
                    const dy = touch.clientY - lastTouch.y;
                    
                    if (isDraggingAccessory && selectedAccessoryId !== null) {
                        handleAccessoryDrag(dx, dy);
                    } else if (dragging) {
                        orbit.theta -= dx * 0.005;
                        orbit.phi = Math.max(0.2, Math.min(Math.PI - 0.2, orbit.phi - dy * 0.005));
                    }
                    
                    lastTouch = { x: touch.clientX, y: touch.clientY };
                    updateCam();
                } else if (e.touches.length === 2) {
                    // Pinch to zoom
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const delta = touchStartDistance - distance;
                    orbit.radius = Math.max(30, Math.min(300, orbit.radius + delta * 0.3));
                    touchStartDistance = distance;
                    
                    // Two-finger pan
                    const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    const panDx = midX - lastTouch.x;
                    const panDy = midY - lastTouch.y;
                    target.x -= panDx * 0.03;
                    target.y += panDy * 0.03;
                    lastTouch = { x: midX, y: midY };
                    
                    updateCam();
                }
            }, { passive: false });
            
            c.addEventListener('touchend', e => {
                if (e.touches.length === 0) {
                    dragging = false;
                    panning = false;
                    isDraggingAccessory = false;
                    touchCount = 0;
                } else if (e.touches.length === 1) {
                    panning = false;
                    dragging = true;
                    lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            });
            
            function handleAccessoryDrag(dx, dy) {
                const acc = accessories.find(a => a.id === selectedAccessoryId);
                if (acc) {
                    const S = 1/3;
                    let wallWidth, wallHeight;
                    
                    // Get wall dimensions based on wall type
                    if (acc.wall === 'front' || acc.wall === 'back') {
                        wallWidth = params.width;
                        wallHeight = params.height;
                    } else if (acc.wall === 'left' || acc.wall === 'right') {
                        wallWidth = params.length;
                        wallHeight = params.height;
                    }
                    // Lean-to Left
                    else if (acc.wall === 'lt-left-side') {
                        wallWidth = leanTos.left.length;
                        wallHeight = leanTos.left.height;
                    } else if (acc.wall === 'lt-left-front' || acc.wall === 'lt-left-back') {
                        wallWidth = leanTos.left.width;
                        wallHeight = leanTos.left.height;
                    }
                    // Lean-to Right
                    else if (acc.wall === 'lt-right-side') {
                        wallWidth = leanTos.right.length;
                        wallHeight = leanTos.right.height;
                    } else if (acc.wall === 'lt-right-front' || acc.wall === 'lt-right-back') {
                        wallWidth = leanTos.right.width;
                        wallHeight = leanTos.right.height;
                    }
                    // Lean-to Front
                    else if (acc.wall === 'lt-front-front') {
                        wallWidth = leanTos.front.width;
                        wallHeight = leanTos.front.height;
                    } else if (acc.wall === 'lt-front-left' || acc.wall === 'lt-front-right') {
                        wallWidth = leanTos.front.depth;
                        wallHeight = leanTos.front.height;
                    }
                    // Lean-to Back
                    else if (acc.wall === 'lt-back-back') {
                        wallWidth = leanTos.back.width;
                        wallHeight = leanTos.back.height;
                    } else if (acc.wall === 'lt-back-left' || acc.wall === 'lt-back-right') {
                        wallWidth = leanTos.back.depth;
                        wallHeight = leanTos.back.height;
                    }
                    
                    const halfRange = (wallWidth - acc.width) / 2;
                    
                    // Get drag multiplier from wall config
                    const config = getWallConfig(acc.wall);
                    const movement = dx * config.drag * 0.05;
                    acc.posXft = Math.max(-halfRange, Math.min(halfRange, (acc.posXft || 0) + movement));
                    acc.posX = acc.posXft * S;
                    
                    if (acc.type === 'window' || acc.type === 'frameout') {
                        const maxH = (wallHeight || params.height) - acc.height;
                        acc.posYft = Math.max(0, Math.min(maxH, (acc.posYft || 0) - dy * 0.05));
                        acc.posY = acc.posYft * S;
                    }
                    
                    updateAccessoriesList();
                    if (acc.type === 'frameout') {
                        createBuilding();
                    } else {
                        rebuildAccessories();
                    }
                }
            }
            
            c.addEventListener('wheel', e => { 
                e.preventDefault(); 
                orbit.radius = Math.max(30, Math.min(300, orbit.radius + e.deltaY * 0.05)); 
                updateCam(); 
            }, { passive: false });
            c.addEventListener('contextmenu', e => e.preventDefault());
            
            // Arrow key controls for precise accessory positioning
            document.addEventListener('keydown', e => {
                if (selectedAccessoryId === null) return;
                
                const acc = accessories.find(a => a.id === selectedAccessoryId);
                if (!acc) return;
                
                const S = 1/3;
                let wallWidth, wallHeight;
                
                // Get wall dimensions
                if (acc.wall === 'front' || acc.wall === 'back') {
                    wallWidth = params.width;
                    wallHeight = params.height;
                } else if (acc.wall === 'left' || acc.wall === 'right') {
                    wallWidth = params.length;
                    wallHeight = params.height;
                } else if (acc.wall.startsWith('lt-left-')) {
                    wallWidth = acc.wall === 'lt-left-side' ? leanTos.left.length : leanTos.left.width;
                    wallHeight = leanTos.left.height;
                } else if (acc.wall.startsWith('lt-right-')) {
                    wallWidth = acc.wall === 'lt-right-side' ? leanTos.right.length : leanTos.right.width;
                    wallHeight = leanTos.right.height;
                } else if (acc.wall.startsWith('lt-front-')) {
                    wallWidth = acc.wall === 'lt-front-front' ? leanTos.front.width : leanTos.front.depth;
                    wallHeight = leanTos.front.height;
                } else if (acc.wall.startsWith('lt-back-')) {
                    wallWidth = acc.wall === 'lt-back-back' ? leanTos.back.width : leanTos.back.depth;
                    wallHeight = leanTos.back.height;
                }
                
                const halfRange = (wallWidth - acc.width) / 2;
                const step = e.shiftKey ? 0.1 : 0.5; // Shift for fine control
                let changed = false;
                
                if (e.key === 'ArrowLeft') {
                    acc.posXft = Math.max(-halfRange, (acc.posXft || 0) - step);
                    acc.posX = acc.posXft * S;
                    changed = true;
                    e.preventDefault();
                } else if (e.key === 'ArrowRight') {
                    acc.posXft = Math.min(halfRange, (acc.posXft || 0) + step);
                    acc.posX = acc.posXft * S;
                    changed = true;
                    e.preventDefault();
                } else if ((e.key === 'ArrowUp' || e.key === 'ArrowDown') && (acc.type === 'window' || acc.type === 'frameout')) {
                    const maxH = (wallHeight || params.height) - acc.height;
                    if (e.key === 'ArrowUp') {
                        acc.posYft = Math.min(maxH, (acc.posYft || 0) + step);
                    } else {
                        acc.posYft = Math.max(0, (acc.posYft || 0) - step);
                    }
                    acc.posY = acc.posYft * S;
                    changed = true;
                    e.preventDefault();
                } else if (e.key === 'Delete' || e.key === 'Backspace') {
                    const isFrameout = acc.type === 'frameout';
                    accessories = accessories.filter(a => a.id !== selectedAccessoryId);
                    selectedAccessoryId = null;
                    hideAccessoryOverlay();
                    updateAccessoriesList();
                    if (isFrameout) {
                        createBuilding();
                    } else {
                        rebuildAccessories();
                    }
                    e.preventDefault();
                    return;
                }
                
                if (changed) {
                    updateAccessoriesList();
                    if (acc.type === 'frameout') {
                        createBuilding();
                    } else {
                        rebuildAccessories();
                    }
                }
            });
            
            updateCam();
        }
        
        function updateCam() {
            camera.position.set(target.x + orbit.radius * Math.sin(orbit.phi) * Math.cos(orbit.theta), target.y + orbit.radius * Math.cos(orbit.phi), target.z + orbit.radius * Math.sin(orbit.phi) * Math.sin(orbit.theta));
            camera.lookAt(target);
        }
        
        // Smoothly rotate camera to view a specific wall
        // Wall configuration: camera theta angle and drag multiplier for each wall type
        function getWallConfig(wallName) {
            // Camera theta determines where camera orbits to
            // theta=0: camera at +X axis (sees right side)
            // theta=PI/2: camera at +Z axis (sees front)
            // theta=PI: camera at -X axis (sees left side)
            // theta=-PI/2: camera at -Z axis (sees back)
            
            const configs = {
                // Main building walls - camera faces the wall from outside
                'front': { theta: Math.PI/2, drag: 1 },
                'back': { theta: -Math.PI/2, drag: 1 },
                'left': { theta: Math.PI, drag: 1 },
                'right': { theta: 0, drag: 1 },
                
                // Left lean-to - on the left side (-X) of building
                'lt-left-side': { theta: Math.PI, drag: 1 },           // Outer sidewall faces -X
                'lt-left-front': { theta: Math.PI * 3/4, drag: 1 },    // Front endwall - diagonal view (front-left)
                'lt-left-back': { theta: -Math.PI * 3/4, drag: 1 },    // Back endwall - diagonal view (back-left)
                
                // Right lean-to - on the right side (+X) of building
                'lt-right-side': { theta: 0, drag: 1 },                // Outer sidewall faces +X
                'lt-right-front': { theta: Math.PI/4, drag: 1 },       // Front endwall - diagonal view (front-right)
                'lt-right-back': { theta: -Math.PI/4, drag: 1 },       // Back endwall - diagonal view (back-right)
                
                // Front lean-to - on the front side (+Z) of building
                'lt-front-front': { theta: Math.PI/2, drag: 1 },       // Outer wall faces +Z
                'lt-front-left': { theta: Math.PI * 3/4, drag: 1 },    // Left endwall - diagonal view
                'lt-front-right': { theta: Math.PI/4, drag: 1 },       // Right endwall - diagonal view
                
                // Back lean-to - on the back side (-Z) of building
                'lt-back-back': { theta: -Math.PI/2, drag: 1 },        // Outer wall faces -Z
                'lt-back-left': { theta: -Math.PI * 3/4, drag: 1 },    // Left endwall - diagonal view
                'lt-back-right': { theta: -Math.PI/4, drag: 1 },       // Right endwall - diagonal view
                
                // Wrap corners - diagonal views
                'wrap-lf-side': { theta: Math.PI * 3/4, drag: 1 },
                'wrap-lf-front': { theta: Math.PI * 3/4, drag: 1 },
                'wrap-rf-side': { theta: Math.PI/4, drag: 1 },
                'wrap-rf-front': { theta: Math.PI/4, drag: 1 },
                'wrap-lb-side': { theta: -Math.PI * 3/4, drag: 1 },
                'wrap-lb-back': { theta: -Math.PI * 3/4, drag: 1 },
                'wrap-rb-side': { theta: -Math.PI/4, drag: 1 },
                'wrap-rb-back': { theta: -Math.PI/4, drag: 1 },
            };
            return configs[wallName] || { theta: 0, drag: 1 };
        }
        
        function rotateCameraToWall(wallName) {
            const config = getWallConfig(wallName);
            const targetTheta = config.theta;
            
            // Animate camera rotation
            const startTheta = orbit.theta;
            const startPhi = orbit.phi;
            const targetPhi = Math.PI / 3; // Slightly elevated view
            
            // Calculate target offset for lean-to walls so camera looks at the right location
            const S = 1/3;
            const W = params.width * S;
            const L = params.length * S;
            let targetOffsetX = 0;
            let targetOffsetZ = 0;
            
            // Left lean-to endwalls - shift target to the left
            if (wallName === 'lt-left-front' || wallName === 'lt-left-back') {
                const ltW = leanTos.left.width * S;
                targetOffsetX = -W/2 - ltW/2; // Center of left lean-to
            }
            // Right lean-to endwalls - shift target to the right  
            else if (wallName === 'lt-right-front' || wallName === 'lt-right-back') {
                const ltW = leanTos.right.width * S;
                targetOffsetX = W/2 + ltW/2; // Center of right lean-to
            }
            // Front lean-to endwalls - shift target forward
            else if (wallName === 'lt-front-left' || wallName === 'lt-front-right') {
                const ltD = leanTos.front.depth * S;
                targetOffsetZ = L/2 + ltD/2; // Center of front lean-to
            }
            // Back lean-to endwalls - shift target backward
            else if (wallName === 'lt-back-left' || wallName === 'lt-back-right') {
                const ltD = leanTos.back.depth * S;
                targetOffsetZ = -L/2 - ltD/2; // Center of back lean-to
            }
            
            // Normalize angles for shortest rotation path
            let deltaTheta = targetTheta - startTheta;
            while (deltaTheta > Math.PI) deltaTheta -= 2 * Math.PI;
            while (deltaTheta < -Math.PI) deltaTheta += 2 * Math.PI;
            
            const duration = 500;
            const startTime = Date.now();
            const startTargetX = target.x;
            const startTargetZ = target.z;
            
            function animateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(1, elapsed / duration);
                // Ease out cubic
                const eased = 1 - Math.pow(1 - progress, 3);
                
                orbit.theta = startTheta + deltaTheta * eased;
                orbit.phi = startPhi + (targetPhi - startPhi) * eased;
                
                // Animate target position
                target.x = startTargetX + (targetOffsetX - startTargetX) * eased;
                target.z = startTargetZ + (targetOffsetZ - startTargetZ) * eased;
                
                updateCam();
                
                if (progress < 1) {
                    requestAnimationFrame(animateRotation);
                }
            }
            
            animateRotation();
        }
        
        function setupEventListeners() {
            // View control buttons
            const initialOrbit = { theta: Math.PI / 4, phi: Math.PI / 3, radius: 80 };
            
            document.getElementById('btn-rotate-left').addEventListener('click', () => {
                orbit.theta -= Math.PI / 8;
                updateCam();
            });
            
            document.getElementById('btn-rotate-right').addEventListener('click', () => {
                orbit.theta += Math.PI / 8;
                updateCam();
            });
            
            document.getElementById('btn-zoom-in').addEventListener('click', () => {
                orbit.radius = Math.max(30, orbit.radius - 10);
                updateCam();
            });
            
            document.getElementById('btn-zoom-out').addEventListener('click', () => {
                orbit.radius = Math.min(300, orbit.radius + 10);
                updateCam();
            });
            
            document.getElementById('btn-reset-view').addEventListener('click', () => {
                // Animate back to initial view
                const startTheta = orbit.theta;
                const startPhi = orbit.phi;
                const startRadius = orbit.radius;
                const duration = 400;
                const startTime = Date.now();
                
                function animateReset() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(1, elapsed / duration);
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    orbit.theta = startTheta + (initialOrbit.theta - startTheta) * eased;
                    orbit.phi = startPhi + (initialOrbit.phi - startPhi) * eased;
                    orbit.radius = startRadius + (initialOrbit.radius - startRadius) * eased;
                    target.x = 0;
                    target.z = 0;
                    updateCam();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateReset);
                    }
                }
                animateReset();
            });
            
            // Tab navigation
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Remove active from all tabs and contents
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    // Add active to clicked tab and corresponding content
                    btn.classList.add('active');
                    document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
                });
            });
            
            // Space Evenly button - distributes accessories evenly on selected wall
            document.getElementById('center-all-btn').addEventListener('click', () => {
                const wallAccessories = accessories.filter(a => a.wall === selectedWall);
                if (wallAccessories.length < 2) return;
                
                // Get wall dimensions
                let wallWidth;
                if (selectedWall === 'front' || selectedWall === 'back') wallWidth = params.width;
                else if (selectedWall === 'left' || selectedWall === 'right') wallWidth = params.length;
                else if (selectedWall === 'lt-left-side') wallWidth = leanTos.left.length;
                else if (selectedWall === 'lt-left-front' || selectedWall === 'lt-left-back') wallWidth = leanTos.left.width;
                else if (selectedWall === 'lt-right-side') wallWidth = leanTos.right.length;
                else if (selectedWall === 'lt-right-front' || selectedWall === 'lt-right-back') wallWidth = leanTos.right.width;
                else if (selectedWall === 'lt-front-front') wallWidth = leanTos.front.width;
                else if (selectedWall === 'lt-front-left' || selectedWall === 'lt-front-right') wallWidth = leanTos.front.depth;
                else if (selectedWall === 'lt-back-back') wallWidth = leanTos.back.width;
                else if (selectedWall === 'lt-back-left' || selectedWall === 'lt-back-right') wallWidth = leanTos.back.depth;
                else wallWidth = params.width;
                
                const S = 1/3;
                
                // Sort by current position to maintain relative order
                wallAccessories.sort((a, b) => (a.posXft || 0) - (b.posXft || 0));
                
                // Calculate total width of all accessories
                const totalAccWidth = wallAccessories.reduce((sum, a) => sum + a.width, 0);
                
                // Calculate available space and gap between accessories
                const availableSpace = wallWidth - totalAccWidth;
                const numGaps = wallAccessories.length + 1; // gaps on both ends and between
                const gap = availableSpace / numGaps;
                
                // Position each accessory
                let currentPos = -wallWidth / 2 + gap;
                wallAccessories.forEach(acc => {
                    currentPos += acc.width / 2; // Move to center of accessory
                    acc.posXft = currentPos;
                    acc.posX = currentPos * S;
                    currentPos += acc.width / 2 + gap; // Move past accessory plus gap
                });
                
                updateAccessoriesList();
                if (wallAccessories.some(a => a.type === 'frameout')) {
                    createBuilding();
                } else {
                    rebuildAccessories();
                }
            });
            
            document.getElementById('width').addEventListener('input', e => { params.width = +e.target.value; document.getElementById('width-value').textContent = params.width; updateStats(); createBuilding(); });
            document.getElementById('length').addEventListener('input', e => { params.length = +e.target.value; document.getElementById('length-value').textContent = params.length; updateStats(); createBuilding(); });
            document.getElementById('height').addEventListener('input', e => { params.height = +e.target.value; document.getElementById('height-value').textContent = params.height; createBuilding(); });
            document.getElementById('pitch').addEventListener('input', e => { params.pitch = +e.target.value; document.getElementById('pitch-value').textContent = params.pitch; createBuilding(); });
            document.getElementById('bay').addEventListener('change', e => { params.baySpacing = +e.target.value; document.getElementById('bay-value').textContent = params.baySpacing; createBuilding(); });
            
            // Front/Back bay spacing controls
            document.getElementById('toggle-front-back-bays').addEventListener('change', e => {
                params.showFrontBackBays = e.target.checked;
                document.getElementById('front-back-bay-controls').style.display = e.target.checked ? 'block' : 'none';
                createBuilding();
            });
            document.getElementById('front-back-bay-spacing').addEventListener('change', e => {
                params.frontBackBaySpacing = +e.target.value;
                document.getElementById('front-back-bay-value').textContent = params.frontBackBaySpacing;
                createBuilding();
            });
            
            // Overhang controls
            document.getElementById('eave-overhang').addEventListener('change', e => {
                params.eaveOverhang = +e.target.value;
                const display = params.eaveOverhang === 0 ? '0' : 
                    params.eaveOverhang === 0.5 ? '6"' :
                    params.eaveOverhang % 1 === 0.5 ? `${Math.floor(params.eaveOverhang)}' 6"` :
                    `${params.eaveOverhang} ft`;
                document.getElementById('eave-overhang-value').textContent = display;
                createBuilding();
            });
            
            document.getElementById('gable-overhang').addEventListener('change', e => {
                params.gableOverhang = +e.target.value;
                const display = params.gableOverhang === 0 ? '0' : 
                    params.gableOverhang === 0.5 ? '6"' :
                    params.gableOverhang % 1 === 0.5 ? `${Math.floor(params.gableOverhang)}' 6"` :
                    `${params.gableOverhang} ft`;
                document.getElementById('gable-overhang-value').textContent = display;
                createBuilding();
            });
            
            // Endwall inset controls
            document.getElementById('front-inset').addEventListener('change', e => {
                params.frontInset = +e.target.value;
                document.getElementById('front-inset-value').textContent = params.frontInset;
                document.getElementById('front-inset-walls').style.display = params.frontInset > 0 ? 'block' : 'none';
                createBuilding();
            });
            
            document.getElementById('back-inset').addEventListener('change', e => {
                params.backInset = +e.target.value;
                document.getElementById('back-inset-value').textContent = params.backInset;
                document.getElementById('back-inset-walls').style.display = params.backInset > 0 ? 'block' : 'none';
                createBuilding();
            });
            
            // Inset wall toggles
            document.getElementById('front-inset-left').addEventListener('change', e => {
                params.frontInsetLeftWall = e.target.checked;
                createBuilding();
            });
            document.getElementById('front-inset-right').addEventListener('change', e => {
                params.frontInsetRightWall = e.target.checked;
                createBuilding();
            });
            document.getElementById('back-inset-left').addEventListener('change', e => {
                params.backInsetLeftWall = e.target.checked;
                createBuilding();
            });
            document.getElementById('back-inset-right').addEventListener('change', e => {
                params.backInsetRightWall = e.target.checked;
                createBuilding();
            });
            
            ['front', 'back', 'left', 'right', 'roof', 'framing'].forEach(key => {
                document.getElementById(`toggle-${key}`).addEventListener('change', e => {
                    params[`show${key.charAt(0).toUpperCase() + key.slice(1)}`] = e.target.checked;
                    if (groups[key]) groups[key].visible = e.target.checked;
                    // Also toggle front/back bay framing when main framing is toggled
                    if (key === 'framing' && groups.frontBackBayFraming) {
                        groups.frontBackBayFraming.visible = e.target.checked && params.showFrontBackBays;
                    }
                });
            });
            
            ['wall', 'roof', 'trim', 'wainscot'].forEach(key => {
                document.querySelectorAll(`#${key}-colors .color-swatch`).forEach(sw => {
                    sw.addEventListener('click', () => {
                        document.querySelectorAll(`#${key}-colors .color-swatch`).forEach(s => s.classList.remove('active'));
                        sw.classList.add('active');
                        const colorVal = sw.dataset.color;
                        // Handle special textures (camo, wood) as strings, otherwise parse as hex
                        if (colorVal === 'camo' || colorVal === 'wood') {
                            colors[key] = colorVal;
                        } else {
                            colors[key] = parseInt(colorVal.replace('#', '0x'));
                        }
                        createBuilding();
                    });
                });
            });
            
            // Wainscot toggle
            document.getElementById('toggle-wainscot').addEventListener('change', e => {
                params.showWainscot = e.target.checked;
                document.getElementById('wainscot-controls').style.display = e.target.checked ? 'block' : 'none';
                createBuilding();
            });
            
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
            
            // Lean-to controls
            document.querySelectorAll('.leanto-header').forEach(header => {
                header.addEventListener('click', () => {
                    const side = header.dataset.leanto;
                    leanTos[side].enabled = !leanTos[side].enabled;
                    header.classList.toggle('active', leanTos[side].enabled);
                    document.getElementById(`leanto-${side}-controls`).classList.toggle('visible', leanTos[side].enabled);
                    // Reset wrap corners when lean-to is disabled
                    if (!leanTos[side].enabled) {
                        if (side === 'left') { wrapCorners.leftFront = false; wrapCorners.leftBack = false; }
                        if (side === 'right') { wrapCorners.rightFront = false; wrapCorners.rightBack = false; }
                        if (side === 'front') { wrapCorners.leftFront = false; wrapCorners.rightFront = false; }
                        if (side === 'back') { wrapCorners.leftBack = false; wrapCorners.rightBack = false; }
                    }
                    updateStats();
                    updateLeantoWallSelector();
                    updateWrapCornersUI();
                    createBuilding();
                });
            });
            
            // Left lean-to controls
            document.getElementById('leanto-left-width').addEventListener('input', e => {
                leanTos.left.width = +e.target.value;
                document.getElementById('leanto-left-width-val').textContent = leanTos.left.width + ' ft';
                updateStats();
                createBuilding();
            });
            document.getElementById('leanto-left-length').addEventListener('input', e => {
                leanTos.left.length = +e.target.value;
                document.getElementById('leanto-left-length-val').textContent = leanTos.left.length + ' ft';
                updateStats();
                createBuilding();
            });
            document.getElementById('leanto-left-offset').addEventListener('input', e => {
                leanTos.left.offset = +e.target.value;
                document.getElementById('leanto-left-offset-val').textContent = leanTos.left.offset + ' ft';
                createBuilding();
            });
            document.getElementById('leanto-left-height').addEventListener('input', e => {
                leanTos.left.height = +e.target.value;
                document.getElementById('leanto-left-height-val').textContent = leanTos.left.height + ' ft';
                updateWrapCornersUI();
                createBuilding();
            });
            document.getElementById('leanto-left-pitch').addEventListener('input', e => {
                leanTos.left.pitch = +e.target.value;
                document.getElementById('leanto-left-pitch-val').textContent = leanTos.left.pitch + ':12';
                updateWrapCornersUI();
                createBuilding();
            });
            
            // Right lean-to controls
            document.getElementById('leanto-right-width').addEventListener('input', e => {
                leanTos.right.width = +e.target.value;
                document.getElementById('leanto-right-width-val').textContent = leanTos.right.width + ' ft';
                updateStats();
                createBuilding();
            });
            document.getElementById('leanto-right-length').addEventListener('input', e => {
                leanTos.right.length = +e.target.value;
                document.getElementById('leanto-right-length-val').textContent = leanTos.right.length + ' ft';
                updateStats();
                createBuilding();
            });
            document.getElementById('leanto-right-offset').addEventListener('input', e => {
                leanTos.right.offset = +e.target.value;
                document.getElementById('leanto-right-offset-val').textContent = leanTos.right.offset + ' ft';
                createBuilding();
            });
            document.getElementById('leanto-right-height').addEventListener('input', e => {
                leanTos.right.height = +e.target.value;
                document.getElementById('leanto-right-height-val').textContent = leanTos.right.height + ' ft';
                updateWrapCornersUI();
                createBuilding();
            });
            document.getElementById('leanto-right-pitch').addEventListener('input', e => {
                leanTos.right.pitch = +e.target.value;
                document.getElementById('leanto-right-pitch-val').textContent = leanTos.right.pitch + ':12';
                updateWrapCornersUI();
                createBuilding();
            });
            
            // Front lean-to controls
            document.getElementById('leanto-front-depth').addEventListener('input', e => {
                leanTos.front.depth = +e.target.value;
                document.getElementById('leanto-front-depth-val').textContent = leanTos.front.depth + ' ft';
                updateStats();
                createBuilding();
            });
            document.getElementById('leanto-front-width').addEventListener('input', e => {
                leanTos.front.width = +e.target.value;
                document.getElementById('leanto-front-width-val').textContent = leanTos.front.width + ' ft';
                updateStats();
                createBuilding();
            });
            document.getElementById('leanto-front-offset').addEventListener('input', e => {
                leanTos.front.offset = +e.target.value;
                document.getElementById('leanto-front-offset-val').textContent = leanTos.front.offset + ' ft';
                createBuilding();
            });
            document.getElementById('leanto-front-height').addEventListener('input', e => {
                leanTos.front.height = +e.target.value;
                document.getElementById('leanto-front-height-val').textContent = leanTos.front.height + ' ft';
                updateWrapCornersUI();
                createBuilding();
            });
            document.getElementById('leanto-front-pitch').addEventListener('input', e => {
                leanTos.front.pitch = +e.target.value;
                document.getElementById('leanto-front-pitch-val').textContent = leanTos.front.pitch + ':12';
                updateWrapCornersUI();
                createBuilding();
            });
            
            // Back lean-to controls
            document.getElementById('leanto-back-depth').addEventListener('input', e => {
                leanTos.back.depth = +e.target.value;
                document.getElementById('leanto-back-depth-val').textContent = leanTos.back.depth + ' ft';
                updateStats();
                createBuilding();
            });
            document.getElementById('leanto-back-width').addEventListener('input', e => {
                leanTos.back.width = +e.target.value;
                document.getElementById('leanto-back-width-val').textContent = leanTos.back.width + ' ft';
                updateStats();
                createBuilding();
            });
            document.getElementById('leanto-back-offset').addEventListener('input', e => {
                leanTos.back.offset = +e.target.value;
                document.getElementById('leanto-back-offset-val').textContent = leanTos.back.offset + ' ft';
                createBuilding();
            });
            document.getElementById('leanto-back-height').addEventListener('input', e => {
                leanTos.back.height = +e.target.value;
                document.getElementById('leanto-back-height-val').textContent = leanTos.back.height + ' ft';
                createBuilding();
            });
            document.getElementById('leanto-back-pitch').addEventListener('input', e => {
                leanTos.back.pitch = +e.target.value;
                document.getElementById('leanto-back-pitch-val').textContent = leanTos.back.pitch + ':12';
                createBuilding();
            });
            
            // Lean-to wall toggles
            document.querySelectorAll('.leanto-wall-toggle').forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const side = toggle.dataset.leanto;
                    const wall = toggle.dataset.wall;
                    const prop = wall === 'endwalls' ? 'showEndwalls' : wall === 'overhang' ? 'showOverhang' : 'showSidewall';
                    leanTos[side][prop] = !leanTos[side][prop];
                    toggle.classList.toggle('active', leanTos[side][prop]);
                    createBuilding();
                });
            });
            
            // Accessory overlay buttons
            document.getElementById('overlay-duplicate').addEventListener('click', () => {
                if (selectedAccessoryId === null) return;
                const acc = accessories.find(a => a.id === selectedAccessoryId);
                if (acc) {
                    const S = 1/3;
                    const newAcc = {
                        id: accessoryIdCounter++,
                        type: acc.type,
                        wall: acc.wall,
                        width: acc.width,
                        height: acc.height,
                        label: acc.label,
                        posX: (acc.posX || 0) + 1 * S,
                        posY: acc.posY || 0,
                        posXft: (acc.posXft || 0) + 1,
                        posYft: acc.posYft || 0
                    };
                    accessories.push(newAcc);
                    selectedAccessoryId = newAcc.id;
                    updateAccessoriesList();
                    if (acc.type === 'frameout') {
                        createBuilding();
                    } else {
                        rebuildAccessories();
                    }
                }
            });
            
            document.getElementById('overlay-delete').addEventListener('click', () => {
                if (selectedAccessoryId === null) return;
                const acc = accessories.find(a => a.id === selectedAccessoryId);
                const isFrameout = acc && acc.type === 'frameout';
                accessories = accessories.filter(a => a.id !== selectedAccessoryId);
                selectedAccessoryId = null;
                hideAccessoryOverlay();
                updateAccessoriesList();
                if (isFrameout) {
                    createBuilding();
                } else {
                    rebuildAccessories();
                }
            });
            
            // Mobile menu toggle
            const mobileMenuBtn = document.getElementById('mobile-menu-btn');
            const controlPanel = document.getElementById('control-panel');
            const panelOverlay = document.getElementById('panel-overlay');
            
            function toggleMobileMenu() {
                mobileMenuBtn.classList.toggle('active');
                controlPanel.classList.toggle('open');
                panelOverlay.classList.toggle('visible');
            }
            
            mobileMenuBtn.addEventListener('click', toggleMobileMenu);
            panelOverlay.addEventListener('click', toggleMobileMenu);
            
            // Close menu when window resizes to desktop
            window.addEventListener('resize', () => {
                if (window.innerWidth > 768) {
                    mobileMenuBtn.classList.remove('active');
                    controlPanel.classList.remove('open');
                    panelOverlay.classList.remove('visible');
                }
            });
        }
        
        function updateStats() { 
            let sqft = params.width * params.length;
            if (leanTos.left.enabled) sqft += leanTos.left.width * leanTos.left.length;
            if (leanTos.right.enabled) sqft += leanTos.right.width * leanTos.right.length;
            if (leanTos.front.enabled) sqft += leanTos.front.depth * leanTos.front.width;
            if (leanTos.back.enabled) sqft += leanTos.back.depth * leanTos.back.width;
            document.getElementById('sqft-value').textContent = sqft.toLocaleString(); 
        }
        function animate() { 
            requestAnimationFrame(animate); 
            renderer.render(scene, camera); 
            // Update overlay position when camera moves
            if (selectedAccessoryId !== null) {
                updateAccessoryOverlay();
            }
        }
        
        // Snapshot functionality - capture building from 6 angles
        let capturedImages = [];
        let selectedSnapshots = new Set();
        
        async function captureSnapshots() {
            const btn = document.getElementById('snapshot-btn');
            const progressModal = document.getElementById('snapshot-progress');
            const statusText = document.getElementById('snapshot-status');
            const progressFill = document.getElementById('snapshot-progress-fill');
            
            btn.classList.add('loading');
            progressModal.classList.add('visible');
            capturedImages = [];
            
            // Calculate building bounds for camera positioning
            const S = 1/3;
            const W = params.width * S;
            const L = params.length * S;
            const H = params.height * S;
            
            // Account for lean-tos in bounds
            let minX = -W/2, maxX = W/2, minZ = -L/2, maxZ = L/2;
            const ltEaveOH = params.eaveOverhang * S;
            
            if (leanTos.left.enabled) {
                minX = -W/2 - leanTos.left.width * S - ltEaveOH;
            }
            if (leanTos.right.enabled) {
                maxX = W/2 + leanTos.right.width * S + ltEaveOH;
            }
            if (leanTos.front.enabled) {
                maxZ = L/2 + leanTos.front.depth * S + ltEaveOH;
            }
            if (leanTos.back.enabled) {
                minZ = -L/2 - leanTos.back.depth * S - ltEaveOH;
            }
            
            const centerX = (minX + maxX) / 2;
            const centerZ = (minZ + maxZ) / 2;
            const buildingWidth = maxX - minX;
            const buildingLength = maxZ - minZ;
            const maxDim = Math.max(buildingWidth, buildingLength, H);
            const distance = maxDim * 2;
            
            // Define 6 camera angles
            const angles = [
                { name: 'front', label: 'Front View', x: centerX, y: H * 0.6, z: maxZ + distance, lookAt: { x: centerX, y: H * 0.4, z: centerZ } },
                { name: 'back', label: 'Back View', x: centerX, y: H * 0.6, z: minZ - distance, lookAt: { x: centerX, y: H * 0.4, z: centerZ } },
                { name: 'left', label: 'Left Side', x: minX - distance, y: H * 0.6, z: centerZ, lookAt: { x: centerX, y: H * 0.4, z: centerZ } },
                { name: 'right', label: 'Right Side', x: maxX + distance, y: H * 0.6, z: centerZ, lookAt: { x: centerX, y: H * 0.4, z: centerZ } },
                { name: 'front-aerial', label: 'Front Aerial', x: centerX + distance * 0.7, y: H + distance * 0.8, z: maxZ + distance * 0.7, lookAt: { x: centerX, y: H * 0.3, z: centerZ } },
                { name: 'back-aerial', label: 'Back Aerial', x: centerX - distance * 0.7, y: H + distance * 0.8, z: minZ - distance * 0.7, lookAt: { x: centerX, y: H * 0.3, z: centerZ } }
            ];
            
            // Create a higher resolution renderer for snapshots
            const snapshotWidth = 1920;
            const snapshotHeight = 1080;
            const snapshotRenderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            snapshotRenderer.setSize(snapshotWidth, snapshotHeight);
            snapshotRenderer.setPixelRatio(1);
            snapshotRenderer.setClearColor(0xf5f5f5);
            
            // Create a camera with the right aspect ratio
            const snapshotCamera = new THREE.PerspectiveCamera(45, snapshotWidth / snapshotHeight, 0.1, 1000);
            
            for (let i = 0; i < angles.length; i++) {
                const angle = angles[i];
                statusText.textContent = `Capturing ${angle.label} (${i + 1}/${angles.length})...`;
                progressFill.style.width = `${((i + 1) / angles.length) * 100}%`;
                
                // Position camera
                snapshotCamera.position.set(angle.x, angle.y, angle.z);
                snapshotCamera.lookAt(angle.lookAt.x, angle.lookAt.y, angle.lookAt.z);
                
                // Render
                snapshotRenderer.render(scene, snapshotCamera);
                
                // Capture image
                const dataURL = snapshotRenderer.domElement.toDataURL('image/png');
                capturedImages.push({ name: angle.name, label: angle.label, dataURL: dataURL });
                
                // Small delay to allow UI update
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            // Clean up snapshot renderer
            snapshotRenderer.dispose();
            
            // Hide progress, show preview
            progressModal.classList.remove('visible');
            progressFill.style.width = '0%';
            btn.classList.remove('loading');
            
            showSnapshotPreview();
        }
        
        function showSnapshotPreview() {
            const overlay = document.getElementById('snapshot-preview-overlay');
            const grid = document.getElementById('snapshot-grid');
            
            // Clear previous content
            grid.innerHTML = '';
            selectedSnapshots = new Set(capturedImages.map((_, i) => i)); // Select all by default
            
            // Create preview items
            capturedImages.forEach((img, index) => {
                const item = document.createElement('div');
                item.className = 'snapshot-item selected';
                item.dataset.index = index;
                item.innerHTML = `
                    <img src="${img.dataURL}" alt="${img.label}">
                    <div class="snapshot-item-label">
                        <span>${img.label}</span>
                        <span class="snapshot-item-check">✓</span>
                    </div>
                `;
                item.addEventListener('click', () => toggleSnapshotSelection(index));
                grid.appendChild(item);
            });
            
            overlay.classList.add('visible');
        }
        
        function toggleSnapshotSelection(index) {
            const item = document.querySelector(`.snapshot-item[data-index="${index}"]`);
            if (selectedSnapshots.has(index)) {
                selectedSnapshots.delete(index);
                item.classList.remove('selected');
            } else {
                selectedSnapshots.add(index);
                item.classList.add('selected');
            }
        }
        
        function selectAllSnapshots() {
            capturedImages.forEach((_, index) => {
                selectedSnapshots.add(index);
                document.querySelector(`.snapshot-item[data-index="${index}"]`).classList.add('selected');
            });
        }
        
        async function downloadSelectedSnapshots() {
            for (const index of selectedSnapshots) {
                const img = capturedImages[index];
                const link = document.createElement('a');
                link.download = `building-${img.name}-${Date.now()}.png`;
                link.href = img.dataURL;
                link.click();
                await new Promise(resolve => setTimeout(resolve, 300));
            }
        }
        
        async function downloadAsZip() {
            const statusText = document.getElementById('snapshot-status');
            const progressModal = document.getElementById('snapshot-progress');
            const progressFill = document.getElementById('snapshot-progress-fill');
            
            // Show progress
            progressModal.classList.add('visible');
            statusText.textContent = 'Creating ZIP file...';
            progressFill.style.width = '10%';
            
            // We'll use a simple approach - create a blob for each image and combine
            // Using JSZip library loaded dynamically
            
            // Load JSZip if not already loaded
            if (typeof JSZip === 'undefined') {
                statusText.textContent = 'Loading ZIP library...';
                await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            }
            
            progressFill.style.width = '20%';
            statusText.textContent = 'Adding images to ZIP...';
            
            const zip = new JSZip();
            const timestamp = new Date().toISOString().slice(0, 10);
            const folder = zip.folder(`building-snapshots-${timestamp}`);
            
            let processed = 0;
            const selectedArray = Array.from(selectedSnapshots);
            
            for (const index of selectedArray) {
                const img = capturedImages[index];
                // Convert data URL to blob
                const base64Data = img.dataURL.split(',')[1];
                folder.file(`${img.name}.png`, base64Data, { base64: true });
                
                processed++;
                progressFill.style.width = `${20 + (processed / selectedArray.length) * 60}%`;
                statusText.textContent = `Adding ${img.label}...`;
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            
            statusText.textContent = 'Generating ZIP file...';
            progressFill.style.width = '85%';
            
            // Generate the zip file
            const content = await zip.generateAsync({ type: 'blob' });
            
            progressFill.style.width = '95%';
            statusText.textContent = 'Downloading...';
            
            // Download the zip
            const link = document.createElement('a');
            link.href = URL.createObjectURL(content);
            link.download = `building-snapshots-${timestamp}.zip`;
            link.click();
            
            // Cleanup
            URL.revokeObjectURL(link.href);
            
            progressFill.style.width = '100%';
            statusText.textContent = 'Complete!';
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            progressModal.classList.remove('visible');
            progressFill.style.width = '0%';
        }
        
        function closeSnapshotPreview() {
            document.getElementById('snapshot-preview-overlay').classList.remove('visible');
        }
        
        // Add event listeners for snapshot functionality after DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('snapshot-btn').addEventListener('click', captureSnapshots);
            document.getElementById('snapshot-preview-close').addEventListener('click', closeSnapshotPreview);
            document.getElementById('snapshot-select-all').addEventListener('click', selectAllSnapshots);
            document.getElementById('snapshot-download-individual').addEventListener('click', downloadSelectedSnapshots);
            document.getElementById('snapshot-download-zip').addEventListener('click', downloadAsZip);
            
            // Close on overlay click
            document.getElementById('snapshot-preview-overlay').addEventListener('click', (e) => {
                if (e.target.id === 'snapshot-preview-overlay') closeSnapshotPreview();
            });
        });
        
        init();
    </script>
</body>
</html>
